<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MLX9064x Thermal Viewer</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 10px;
        }

        h1 {
            font-size: 2rem;
            margin: 0;
        }

        .subtitle {
            opacity: 0.9;
            font-size: 0.9rem;
        }

        .library-version {
            font-size: 0.9rem;
            opacity: 0.85;
            text-align: right;
        }

        .library-version .version-label {
            font-size: 0.75rem;
            opacity: 0.7;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 300px 300px;
            gap: 20px;
            margin-bottom: 20px;
        }

        /* Basic mode: 2 columns (hide advanced panel) */
        .main-grid.basic-mode {
            grid-template-columns: 1fr 300px;
        }

        /* Hide advanced panel and debug panel in basic mode */
        .basic-mode #advancedPanel {
            display: none;
        }

        .basic-mode .debug-panel {
            display: none;
        }

        .basic-mode .advanced-only {
            display: none;
        }

        .panel {
            background: #2a2a2a;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .panel-title {
            font-size: 1.2rem;
            margin-bottom: 15px;
            color: #667eea;
            border-bottom: 2px solid #667eea;
            padding-bottom: 5px;
        }

        #visualizationPanel {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #thermalCanvas {
            background: #000;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.3);
            max-width: 100%;
            height: auto;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
            width: 100%;
        }

        .stat-box {
            background: #1a1a1a;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-label {
            font-size: 0.8rem;
            opacity: 0.7;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #667eea;
        }

        .stat-value.large {
            font-size: 2.5rem;
            color: #4ade80;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9rem;
            opacity: 0.8;
        }

        /* Slider styles */
        .slider-group label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }

        .slider-group label span {
            color: #4ade80;
            font-weight: 600;
            min-width: 60px;
            text-align: right;
        }

        .slider-group input[type="range"] {
            width: 100%;
            margin-top: 5px;
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 5px;
            border-radius: 5px;
            background: #1e293b;
            outline: none;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        input[type="range"]:hover {
            opacity: 1;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4ade80;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4ade80;
            cursor: pointer;
        }

        button {
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            border: none;
            border-radius: 6px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }

        button.primary {
            background: #667eea;
            color: white;
        }

        button.primary:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.4);
        }

        button.secondary {
            background: #4ade80;
            color: #1a1a1a;
        }

        button.secondary:hover {
            background: #3bc66e;
        }

        button.danger {
            background: #ef4444;
            color: white;
        }

        button.danger:hover {
            background: #dc2626;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        select, input[type="range"] {
            width: 100%;
            padding: 8px;
            border-radius: 6px;
            border: 1px solid #444;
            background: #1a1a1a;
            color: #e0e0e0;
            font-size: 0.9rem;
        }

        input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .range-value {
            display: inline-block;
            margin-left: 10px;
            font-weight: bold;
            color: #667eea;
        }

        .status {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.85rem;
            font-weight: 600;
        }

        .status.connected {
            background: #4ade80;
            color: #1a1a1a;
        }

        .status.disconnected {
            background: #ef4444;
            color: white;
        }

        .status.capturing {
            background: #f59e0b;
            color: #1a1a1a;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        #chartPanel {
            grid-column: 1 / -1;
        }

        #advancedPanel .control-group label {
            color: #a0a0a0;
        }

        #advancedPanel select {
            margin-bottom: 10px;
        }

        #chartCanvas {
            max-height: 250px;
        }

        .debug-panel {
            grid-column: 1 / -1;
            max-height: 300px;
            overflow-y: auto;
        }

        #debugOutput {
            width: 100%;
            min-height: 250px;
            background: #000;
            color: #0f0;
            padding: 10px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            white-space: pre-wrap;
            overflow-x: auto;
        }

        .recording-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        @media (max-width: 1200px) {
            .main-grid {
                grid-template-columns: 1fr;
            }

            #chartPanel {
                grid-column: 1;
            }
        }

        /* Update Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            animation: fadeIn 0.3s;
        }

        .modal.show {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background: #2a2a2a;
            border-radius: 12px;
            padding: 30px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            animation: slideIn 0.3s;
        }

        @keyframes slideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #667eea;
        }

        .modal-header h2 {
            margin: 0;
            color: #667eea;
        }

        .modal-close {
            background: none;
            border: none;
            color: #e0e0e0;
            font-size: 1.5rem;
            cursor: pointer;
            width: auto;
            padding: 0;
            margin: 0;
        }

        .modal-close:hover {
            color: #667eea;
        }

        .version-info {
            background: #1a1a1a;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .version-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .version-row:last-child {
            margin-bottom: 0;
        }

        .version-label {
            opacity: 0.7;
        }

        .version-value {
            font-weight: bold;
            color: #4ade80;
        }

        .version-value.new {
            color: #667eea;
        }

        .update-progress {
            margin: 20px 0;
        }

        .progress-bar-container {
            width: 100%;
            height: 30px;
            background: #1a1a1a;
            border-radius: 15px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 0.85rem;
        }

        .progress-text {
            text-align: center;
            margin-top: 10px;
            color: #4ade80;
            font-size: 0.9rem;
        }

        .update-log {
            background: #000;
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            padding: 15px;
            border-radius: 6px;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 20px;
            white-space: pre-wrap;
        }

        .update-log-entry {
            margin-bottom: 5px;
        }

        .update-log-entry.error {
            color: #ff4444;
        }

        .update-log-entry.success {
            color: #4ade80;
        }

        .update-badge {
            position: absolute;
            top: 5px;
            right: 5px;
            background: #ef4444;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: bold;
            animation: pulse 2s infinite;
        }

        .manual-dfu-instructions {
            background: #1a1a1a;
            border-left: 4px solid #f59e0b;
            padding: 15px;
            margin-top: 20px;
            border-radius: 6px;
        }

        .manual-dfu-instructions h4 {
            color: #f59e0b;
            margin-top: 0;
        }

        .manual-dfu-instructions ol {
            margin: 10px 0;
            padding-left: 20px;
        }

        .manual-dfu-instructions li {
            margin-bottom: 8px;
        }

        .update-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .update-buttons button {
            flex: 1;
        }
    </style>

    <!-- DFU Firmware Update Scripts -->
    <script src="js/dfu.js"></script>
    <script src="js/dfuse.js"></script>
    <script src="js/firmware-updater.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <div>
                <h3>MLX9064x Thermal Viewer</h3>
                <div class="subtitle">Real-time people detection with MLX90642</div>
            </div>
            <div style="display: flex; gap: 20px; align-items: center;">
                <button class="primary" id="updateFirmwareBtn"  style="width: auto; padding: 10px 20px; position: relative;">
                    <span>Update Firmware</span>
                    <span id="updateBadge" class="update-badge" style="display: none;">!</span>
                </button>
                <div class="library-version">
                    <div class="version-label">ISP Library</div>
                    <div id="libraryVersion">--</div>
                </div>
            </div>
        </header>

        <div class="main-grid">
            <!-- Visualization Panel -->
            <div class="panel" id="visualizationPanel">
                <!-- <h2 class="panel-title">Thermal Heatmap</h2> -->
                <canvas id="thermalCanvas" width="640" height="480"></canvas>
                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="stat-label">People Est. (footprint)</div>
                        <div class="stat-value large" id="peopleCount">-</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Blobs</div>
                        <div class="stat-value large" id="blobCount">-</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Temperature Range</div>
                        <div class="stat-value" id="tempRange" style="font-size: 1rem;">-</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">ISP Time</div>
                        <div class="stat-value" id="processTime">-</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Frame Time (Total)</div>
                        <div class="stat-value" id="frameTime">-</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Actual FPS</div>
                        <div class="stat-value" id="actualFps">-</div>
                    </div>
                </div>
            </div>

            <!-- Control Panel -->
            <div class="panel" id="controlPanel">
                <h2 class="panel-title">Controls</h2>

                <!-- Algorithm Mode -->
                <div class="control-group">
                    <label>Algorithm Mode</label>
                    <select id="algoModeSelect">
                        <option value="1" selected>Default</option>
                        <option value="2">Simple</option>
                    </select>
                </div>

                <!-- Connection -->
                <div class="control-group">
                    <button class="primary" id="connectionToggle" >Connect</button>
                </div>

                <!-- Capture Controls -->
                <div class="control-group">
                    <button class="secondary" id="captureToggle"  disabled>Start Capture</button>
                </div>

                <!-- Frame Rate (advanced only - basic mode auto-syncs to sensor FPS) -->
                <div class="control-group advanced-only">
                    <label>Frame Rate: <span class="range-value" id="frameRateValue">8.0 Hz</span></label>
                    <input type="range" id="frameRateSlider" min="1.0" max="16.0" step="1.0" value="8"
                           >
                </div>

                <!-- Preset Configuration -->
                <div class="control-group" id="presetConfigGroup">
                    <label>Preset Configuration</label>
                    <select id="presetSelect" >
                        <option value="OBLIQUE|SHORT|LOW">OBLIQUE + SHORT + LOW</option>
                        <option value="OBLIQUE|SHORT|HIGH">OBLIQUE + SHORT + HIGH</option>
                        <option value="OBLIQUE|TALL|LOW">OBLIQUE + TALL + LOW</option>
                        <option value="OBLIQUE|TALL|HIGH">OBLIQUE + TALL + HIGH</option>
                        <option value="VERTICAL|SHORT|LOW">VERTICAL + SHORT + LOW</option>
                        <option value="VERTICAL|SHORT|HIGH">VERTICAL + SHORT + HIGH</option>
                        <option value="VERTICAL|TALL|LOW">VERTICAL + TALL + LOW</option>
                        <option value="VERTICAL|TALL|HIGH">VERTICAL + TALL + HIGH</option>
                    </select>
                </div>

                <!-- Simple Mode Controls (replaces Preset in Simple Mode) -->
                <div class="control-group slider-group simple-mode-only" style="display: none;">
                    <label>Hot Threshold <span id="thHotValue">1.8</span>°C</label>
                    <input type="range" id="thHotSlider" min="0" max="500" value="90" step="5">
                </div>

                <div class="control-group simple-mode-only" style="display: none;">
                    <div class="checkbox-group">
                        <input type="checkbox" id="motionValidationCheckbox">
                        <label for="motionValidationCheckbox">Motion Validation</label>
                    </div>
                </div>

                <div class="control-group" id="coldDetectionGroup">
                    <div class="checkbox-group">
                        <input type="checkbox" id="coldDetection" >
                        <label for="coldDetection">Enable Cold Detection</label>
                    </div>
                </div>

                <!-- Visualization -->
                <div class="control-group">
                    <label class="panel-title" style="font-size: 1rem; border-bottom: 1px solid #444; padding-bottom: 5px; margin-bottom: 10px; display: block;">Visualization</label>

                    <div class="checkbox-group">
                        <input type="checkbox" id="displayMotionMap">
                        <label for="displayMotionMap">Display Motion Map</label>
                    </div>

                    <div class="checkbox-group">
                        <input type="checkbox" id="fixedScale" checked>
                        <label for="fixedScale">Fixed Color Scale</label>
                    </div>

                    <div id="fixedScaleControls" style="display: block; margin-top: 10px; padding-left: 10px; border-left: 2px solid #444; margin-bottom: 10px;">
                         <div style="margin-bottom: 8px;">
                            <label style="display: inline-block; width: 60px;">Min °C:</label>
                            <input type="number" id="fixedMinTemp" value="22" step="1" style="width: 80px; display: inline-block;">
                        </div>
                        <div>
                            <label style="display: inline-block; width: 60px;">Max °C:</label>
                            <input type="number" id="fixedMaxTemp" value="33" step="1" style="width: 80px; display: inline-block;">
                        </div>
                    </div>

                    <div class="checkbox-group">
                        <input type="checkbox" id="smoothHeatmap">
                        <label for="smoothHeatmap">Smooth Heatmap (Bilinear)</label>
                    </div>
                    <div class="checkbox-group" style="margin-top: 8px;">
                        <input type="checkbox" id="flipHorizontal">
                        <label for="flipHorizontal">Flip Horizontal</label>
                    </div>
                    <div class="checkbox-group" style="margin-top: 5px;">
                        <input type="checkbox" id="flipVertical">
                        <label for="flipVertical">Flip Vertical</label>
                    </div>
                    <div class="checkbox-group" style="margin-top: 5px;">
                        <input type="checkbox" id="rotate90">
                        <label for="rotate90">Rotate 90°</label>
                    </div>
                </div>

                <!-- Recording Controls -->
                <div class="control-group">
                    <label>Recording</label>
                    <div class="recording-controls">
                        <button  id="recordBtn" disabled>Record</button>
                        <button  id="stopRecordBtn" disabled>Stop</button>
                        <button  id="saveRecordBtn" disabled>Save</button>
                    </div>
                </div>

                <!-- Frame Counter -->
                <div class="control-group">
                    <div class="stat-box">
                        <div class="stat-label">Frames Captured</div>
                        <div class="stat-value" id="frameCounter">0</div>
                    </div>
                </div>
            </div>

            <!-- Advanced Panel -->
            <div class="panel" id="advancedPanel">
                <h2 class="panel-title">Advanced</h2>

                <!-- Sensor Configuration -->
                <div class="control-group">
                    <label>Sensor Mode</label>
                    <select id="sensorMode" disabled>
                        <option value="CONTINUOUS">Continuous</option>
                        <option value="TRIGGER">Trigger/Step</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>Sensor Frame Rate</label>
                    <select id="sensorFps">
                        <option value="2">2 Hz</option>
                        <option value="3">4 Hz</option>
                        <option value="4" selected>8 Hz</option>
                        <option value="5">16 Hz</option>
                    </select>
                </div>

                <button class="primary" id="applySensorConfigBtn"  disabled>Apply Sensor Config</button>

                <div class="control-group" style="margin-top: 20px;">
                    <div class="stat-box">
                        <div class="stat-label">Sensor Status</div>
                        <div class="stat-value" id="sensorStatus" style="font-size: 0.9rem;">Not configured</div>
                    </div>
                </div>

                <!-- Runtime Parameters -->
                <div class="runtime-params-section" style="margin-top: 20px; border-top: 1px solid #444; padding-top: 15px;">
                    <h3 style="margin-bottom: 15px; color: #94a3b8;">Runtime Parameters</h3>

                    <!-- Detection Parameters -->
                    <div class="param-group">
                        <h4 style="color: #64748b; margin: 10px 0;">Detection</h4>

                        <div class="control-group slider-group">
                            <label>Footprint Size <span id="footprintValue">45</span> px</label>
                            <input type="range" id="footprintSlider" min="35" max="55" value="45" step="1">
                        </div>

                        <div class="control-group slider-group">
                            <label>Min Blob Area <span id="minAreaValue">15</span> px</label>
                            <input type="range" id="minAreaSlider" min="5" max="100" value="15" step="1">
                        </div>

                        <!-- Standard Mode Params -->
                        <div class="standard-mode-only">
                            <div class="control-group slider-group">
                                <label>Lower Threshold <span id="thresholdLValue">1.0</span>x</label>
                                <input type="range" id="thresholdLSlider" min="25" max="1024" value="256" step="1">
                            </div>

                            <div class="control-group slider-group">
                                <label>Upper Threshold <span id="thresholdHValue">1.0</span>x</label>
                                <input type="range" id="thresholdHSlider" min="25" max="1024" value="256" step="1">
                            </div>
                        </div>

                        <!-- Simple Mode Params -->
                        <div class="simple-mode-only" style="display: none;">
                            <div class="control-group slider-group">
                                <label>Cold Threshold <span id="thColdValue">0.0</span>°C</label>
                                <input type="range" id="thColdSlider" min="0" max="500" value="0" step="5">
                            </div>

                            <div class="control-group slider-group">
                                <label>Hysteresis (Strong) <span id="simpleHysteresisValue">1.00</span>x</label>
                                <input type="range" id="simpleHysteresisSlider" min="256" max="1024" value="256" step="1">
                            </div>

                            <div class="control-group slider-group">
                                <label>BG Learning <span id="simpleGammaEmaValue">0.10</span>x</label>
                                <input type="range" id="simpleGammaEmaSlider" min="3" max="128" value="26" step="1">
                            </div>

                            <div class="control-group slider-group">
                                <label>Motion Threshold <span id="motionThreshValue">1.0</span>°C</label>
                                <input type="range" id="motionThreshSlider" min="0" max="500" value="50" step="5">
                            </div>

                            <div class="control-group slider-group">
                                <label>Motion Persistence <span id="motionHystValue">60</span> s</label>
                                <input type="range" id="motionHystSlider" min="1" max="180" value="60" step="1">
                            </div>

                            <div class="control-group slider-group">
                                <label>Motion Density <span id="motionDensityValue">20</span>%</label>
                                <input type="range" id="motionDensitySlider" min="0" max="100" value="20" step="1">
                            </div>

                            <div class="control-group slider-group">
                                <label>Min Track Age <span id="trackAgeValue">1.0</span> s</label>
                                <input type="range" id="trackAgeSlider" min="0.1" max="5.0" value="1.0" step="0.1">
                            </div>

                            <div class="control-group slider-group">
                                <label>Max Missed <span id="trackMissedValue">2.0</span> s</label>
                                <input type="range" id="trackMissedSlider" min="0.1" max="10.0" value="2.0" step="0.1">
                            </div>
                        </div>
                    </div>

                    <!-- Temperature Range -->
                    <div class="param-group standard-mode-only">
                        <h4 style="color: #64748b; margin: 10px 0;">Temperature Range</h4>

                        <div class="control-group slider-group">
                            <label>Min Temperature <span id="tempMinValue">20.0</span>°C</label>
                            <input type="range" id="tempMinSlider" min="0" max="1500" value="0" step="50">
                        </div>

                        <div class="control-group slider-group">
                            <label>Max Temperature <span id="tempMaxValue">40.0</span>°C</label>
                            <input type="range" id="tempMaxSlider" min="0" max="2500" value="0" step="50">
                        </div>
                    </div>

                    <!-- LoG Processing (Advanced) -->
                    <div class="param-group standard-mode-only">
                        <h4 style="color: #64748b; margin: 10px 0;">LoG Processing (Advanced)</h4>

                        <div class="control-group slider-group">
                            <label>Cold Gate <span id="logGateLValue">50</span> px</label>
                            <input type="range" id="logGateLSlider" min="5" max="500" value="50" step="5">
                        </div>

                        <div class="control-group slider-group">
                            <label>Hot Gate <span id="logGateHValue">5</span> px</label>
                            <input type="range" id="logGateHSlider" min="5" max="100" value="5" step="1">
                        </div>

                        <div class="control-group slider-group">
                            <label>Cold Percentile <span id="percentileLValue">0.50</span></label>
                            <input type="range" id="percentileLSlider" min="0" max="256" value="128" step="1">
                        </div>

                        <div class="control-group slider-group">
                            <label>Hot Percentile <span id="percentileHValue">0.50</span></label>
                            <input type="range" id="percentileHSlider" min="0" max="256" value="128" step="1">
                        </div>
                    </div>

                    <!-- Background Learning -->
                    <div class="param-group standard-mode-only">
                        <h4 style="color: #64748b; margin: 10px 0;">Background Learning</h4>

                        <div class="control-group slider-group">
                            <label>gamma_ema: <span id="gammaEmaValue">0.10</span>× <span style="color: #64748b; font-size: 0.85em;"></span></label>
                            <input type="range" id="gammaEmaSlider" min="3" max="128" value="26" step="1">
                        </div>
                    </div>

                    <button class="secondary" id="resetParamsBtn" style="margin-top: 10px;">Reset to Defaults</button>
                </div>

            </div>

            <!-- Chart Panel -->
            <div class="panel" id="chartPanel">
                <h2 class="panel-title">People Count History</h2>
                <canvas id="chartCanvas"></canvas>
            </div>

            <!-- Debug Panel -->
            <div class="panel debug-panel">
                <h2 class="panel-title">Debug Output</h2>
                <textarea id="debugOutput" readonly></textarea>
            </div>
        </div>
    </div>

    <!-- Firmware Update Modal -->
    <div id="updateModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Firmware Update</h2>
                <button class="modal-close" >×</button>
            </div>

            <div id="updateStatus">
                <!-- Version Information -->
                <div class="version-info">
                    <div class="version-row">
                        <span class="version-label">Current Firmware:</span>
                        <span class="version-value" id="currentFirmwareVersion">--</span>
                    </div>
                    <div class="version-row">
                        <span class="version-label">Latest Firmware:</span>
                        <span class="version-value new" id="latestFirmwareVersion">--</span>
                    </div>
                    <div class="version-row" style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #444;">
                        <span class="version-label">Firmware Size:</span>
                        <span id="firmwareSize">--</span>
                    </div>
                </div>

                <!-- Windows Driver Note -->
                <div style="margin: 15px 0; padding: 12px; background: #1e3a5f; border-radius: 6px; border-left: 3px solid #60a5fa; font-size: 0.85rem;">
                    <strong style="color: #93c5fd;">Windows Users:</strong>
                    <span style="color: #cbd5e1;"> First-time setup requires USB drivers from</span>
                    <a href="https://www.st.com/en/development-tools/stm32cubeprog.html" target="_blank" style="color: #60a5fa; text-decoration: underline; margin-left: 4px;">STM32CubeProgrammer</a>
                </div>

                <!-- Progress Section (hidden initially) -->
                <div id="updateProgressSection" class="update-progress" style="display: none;">
                    <div class="progress-bar-container">
                        <div id="updateProgressBar" class="progress-bar">0%</div>
                    </div>
                    <div id="updateProgressText" class="progress-text">Initializing...</div>
                </div>

                <!-- Update Log -->
                <div id="updateLog" class="update-log"></div>

                <!-- Manual DFU Instructions (hidden initially) -->
                <div id="manualDfuInstructions" class="manual-dfu-instructions" style="display: none;">
                    <h4>⚠️ Manual DFU Mode Entry</h4>
                    <p>If automatic DFU entry fails, follow these steps:</p>
                    <ol>
                        <li>Disconnect USB cable from device</li>
                        <li>Press and HOLD the BOOT button on the board</li>
                        <li>While holding BOOT, connect USB cable</li>
                        <li>Release BOOT button</li>
                        <li>Click "Retry Update" below</li>
                    </ol>
                    <p style="margin-top: 10px; font-size: 0.9rem; opacity: 0.8;">
                        Device will enter DFU bootloader mode (STM32 BOOTLOADER)
                    </p>
                </div>
            </div>

            <!-- Manual DFU Mode Option (for Windows compatibility) -->
            <!-- COMMENTED OUT: Manual DFU mode - not needed for now
            <div style="margin: 20px 0; padding: 15px; background: #1e293b; border-radius: 8px; border: 1px solid #334155;">
                <label style="display: flex; align-items: center; cursor: pointer; font-size: 0.95rem;">
                    <input type="checkbox" id="manualDfuModeCheckbox" style="margin-right: 10px; width: 18px; height: 18px; cursor: pointer;">
                    <span><strong>Manual DFU Mode</strong></span>
                </label>
                <p style="margin: 10px 0 0 28px; opacity: 0.7; font-size: 0.85rem;">
                    Check this if automatic DFU mode fails. You'll manually enter DFU mode before flashing.
                </p>
                <div id="manualDfuInstructionsPreview" style="display: none; margin-top: 10px; padding: 10px; background: #0f172a; border-radius: 4px; font-size: 0.85rem;">
                    <strong>⚠️ Before clicking "Update Firmware", do these steps:</strong>
                    <ol style="margin: 5px 0 0 20px; padding: 0;">
                        <li>Disconnect USB cable from device</li>
                        <li>Press and HOLD the BOOT button on the board</li>
                        <li>While holding BOOT, connect USB cable</li>
                        <li>Release BOOT button</li>
                        <li>Now click "Update Firmware" button below ↓</li>
                    </ol>
                </div>
            </div>
            -->

            <!-- Action Buttons -->
            <div class="update-buttons">
                <button id="checkUpdateBtn" class="primary" >
                    Check for Updates
                </button>
                <button id="startUpdateBtn" class="secondary"  disabled>
                    Update Firmware
                </button>
                <button id="closeModalBtn" class="primary" >
                    Close
                </button>
            </div>

                                <!-- Upload firmware section -->
                                <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid rgba(255,255,255,0.1);">
                                    <p style="font-size: 0.9rem; margin-bottom: 0.5rem; color: #aaa;">
                                        Upload firmware .hex directly from your computer
                                    </p>
                                    <input type="file" id="firmwareFileInput" accept=".hex" style="display: none;">
                                    <button id="chooseFirmwareBtn" class="btn btn-sm btn-outline-light" style="width: 100%;">
                                        <i class="bi bi-upload"></i> Select File...
                                    </button>
                                    <div id="selectedFileInfo" style="margin-top: 10px; font-size: 0.9rem;"></div>
                                </div>
        </div>
    </div>

    <script>
        /**
         * Application Configuration Constants
         * Centralized location for all magic numbers and settings
         */
        const CONFIG = {
            serial: {
                baudRate: 921600,
                defaultTimeout: 3000,
                longTimeout: 5000,
                stabilizationDelay: 1500,
                parameterApplyDelay: 100,
                dfuRebootDelay: 2000
            },
            capture: {
                defaultFrameRate: 8.0,
                minFrameRate: 1.0,
                maxFrameRate: 16.0,
                maxFrameTimeSamples: 10
            },
            rendering: {
                pixelSize: 20,
                defaultSmoothing: true
            },
            chart: {
                maxHistoryLength: 60,
                borderColor: '#4ade80',
                backgroundColor: 'rgba(74, 222, 128, 0.1)',
                borderWidth: 2,
                tension: 0.4
            },
            ui: {
                debugMaxLines: 1000
            }
        };


        /**
         * UIManager - Caches DOM elements and handles UI mode (basic/advanced)
         * @class
         */
        class UIManager {
            constructor() {
                this.cacheElements();
                this.advancedMode = this.detectAdvancedMode();
                this.setupEventListeners();

                // Load algo mode state immediately on startup so connect() knows what to do
                // even if app hasn't fully initialized yet
                const saved = localStorage.getItem('appSettings');
                if (saved) {
                     try {
                         const settings = JSON.parse(saved);
                         if (settings.algoMode) {
                             if (this.el.algoModeSelect) {
                                 this.el.algoModeSelect.value = settings.algoMode;
                             }
                             // Also update UI visibility immediately
                             this.applyAlgorithmModeUI(settings.algoMode);
                         }
                     } catch (e) { console.error('Error restoring initial UI state:', e); }
                }
            }

            /**
             * Cache all DOM element references for performance
             */
            cacheElements() {
                this.el = {
                    connectionToggle: document.getElementById('connectionToggle'),
                    captureToggle: document.getElementById('captureToggle'),
                    connectionStatus: document.getElementById('connectionStatus'),
                    peopleCount: document.getElementById('peopleCount'),
                    blobCount: document.getElementById('blobCount'),
                    tempRange: document.getElementById('tempRange'),
                    processTime: document.getElementById('processTime'),
                    frameTime: document.getElementById('frameTime'),
                    actualFps: document.getElementById('actualFps'),
                    frameCounter: document.getElementById('frameCounter'),
                    libraryVersion: document.getElementById('libraryVersion'),
                    recordBtn: document.getElementById('recordBtn'),
                    stopRecordBtn: document.getElementById('stopRecordBtn'),
                    saveRecordBtn: document.getElementById('saveRecordBtn'),
                    presetSelect: document.getElementById('presetSelect'),
                    coldDetection: document.getElementById('coldDetection'),
                    sensorMode: document.getElementById('sensorMode'),
                    sensorFps: document.getElementById('sensorFps'),
                    applySensorConfigBtn: document.getElementById('applySensorConfigBtn'),
                    advancedPanel: document.getElementById('advancedPanel'),
                    debugPanel: document.querySelector('.debug-panel'),
                    debugOutput: document.getElementById('debugOutput'),
                    frameRateSlider: document.getElementById('frameRateSlider'),
                    frameRateValue: document.getElementById('frameRateValue'),
                    algoModeSelect: document.getElementById('algoModeSelect'),
                    thHotSlider: document.getElementById('thHotSlider'),
                    thHotValue: document.getElementById('thHotValue'),
                    thColdSlider: document.getElementById('thColdSlider'),
                    thColdValue: document.getElementById('thColdValue'),
                    simpleHysteresisSlider: document.getElementById('simpleHysteresisSlider'),
                    simpleHysteresisValue: document.getElementById('simpleHysteresisValue'),
                    simpleGammaEmaSlider: document.getElementById('simpleGammaEmaSlider'),
                    simpleGammaEmaValue: document.getElementById('simpleGammaEmaValue'),
                    motionThreshSlider: document.getElementById('motionThreshSlider'),
                    motionThreshValue: document.getElementById('motionThreshValue'),
                    motionHystSlider: document.getElementById('motionHystSlider'),
                    motionHystValue: document.getElementById('motionHystValue'),
                    motionDensitySlider: document.getElementById('motionDensitySlider'),
                    motionDensityValue: document.getElementById('motionDensityValue'),
                    smoothHeatmap: document.getElementById('smoothHeatmap'),
                    displayMotionMap: document.getElementById('displayMotionMap'),
                    // Fixed Scale Controls
                    fixedScale: document.getElementById('fixedScale'),
                    fixedMinTemp: document.getElementById('fixedMinTemp'),
                    fixedMaxTemp: document.getElementById('fixedMaxTemp'),
                    fixedScaleControls: document.getElementById('fixedScaleControls'),

                    flipHorizontal: document.getElementById('flipHorizontal'),
                    flipVertical: document.getElementById('flipVertical'),
                    rotate90: document.getElementById('rotate90'),
                    updateFirmwareBtn: document.getElementById('updateFirmwareBtn'),
                    updateModal: document.getElementById('updateModal'),
                    checkUpdateBtn: document.getElementById('checkUpdateBtn'),
                    startUpdateBtn: document.getElementById('startUpdateBtn'),
                    closeModalBtn: document.getElementById('closeModalBtn')
                };

                this.el.standardModeParams = document.querySelectorAll('.standard-mode-only');
                this.el.simpleModeParams = document.querySelectorAll('.simple-mode-only');
                this.el.presetConfigGroup = document.getElementById('presetConfigGroup');
                this.el.coldDetectionGroup = document.getElementById('coldDetectionGroup');
            }

            /**
             * Detect advanced mode from URL parameter (priority) or localStorage (fallback)
             * URL parameter is ephemeral - doesn't persist across sessions
             * @returns {boolean} True if advanced mode should be enabled
             */
            detectAdvancedMode() {
                const urlParams = new URLSearchParams(window.location.search);

                // URL parameter takes precedence (ephemeral - for this session only)
                if (urlParams.has('advanced')) {
                    return true;
                }

                // No URL param: check if user manually toggled mode in previous session
                // (This would be set by a toggle button if we add one later)
                return localStorage.getItem('advancedMode') === 'true';
            }

            /**
             * Setup all event listeners (replaces inline onclick)
             */
            setupEventListeners() {
                // Connection
                if (this.el.connectionToggle) {
                    this.el.connectionToggle.addEventListener('click', () => app.toggleConnection());
                }

                // Capture
                if (this.el.captureToggle) {
                    this.el.captureToggle.addEventListener('click', () => app.toggleCapture());
                }

                // Recording
                if (this.el.recordBtn) {
                    this.el.recordBtn.addEventListener('click', () => app.startRecording());
                }
                if (this.el.stopRecordBtn) {
                    this.el.stopRecordBtn.addEventListener('click', () => app.stopRecording());
                }
                if (this.el.saveRecordBtn) {
                    this.el.saveRecordBtn.addEventListener('click', () => app.saveRecording());
                }

                // Preset
                if (this.el.presetSelect) {
                    this.el.presetSelect.addEventListener('change', () => {
                        app.applyPreset();
                        app.saveAppSettings();
                    });
                }
                if (this.el.coldDetection) {
                    this.el.coldDetection.addEventListener('change', () => {
                        app.applyPreset();
                        app.saveAppSettings();
                    });
                }

                // Sensor config
                if (this.el.applySensorConfigBtn) {
                    this.el.applySensorConfigBtn.addEventListener('click', () => app.applySensorConfig());
                }
                if (this.el.sensorMode) {
                    this.el.sensorMode.addEventListener('change', () => app.saveAppSettings());
                }
                if (this.el.sensorFps) {
                    this.el.sensorFps.addEventListener('change', () => app.saveAppSettings());
                }

                // Frame rate
                if (this.el.frameRateSlider) {
                    this.el.frameRateSlider.addEventListener('input', (e) => {
                        app.updateFrameRate(e.target.value);
                        app.saveAppSettings();
                    });
                }

                // Algorithm Mode
                if (this.el.algoModeSelect) {
                    this.el.algoModeSelect.addEventListener('change', (e) => {
                        app.changeAlgorithmMode(e.target.value);
                        app.saveAppSettings();
                    });
                }

                // Fixed Scale
                if (this.el.fixedScale) {
                    this.el.fixedScale.addEventListener('change', (e) => {
                         if (this.el.fixedScaleControls) {
                             this.el.fixedScaleControls.style.display = e.target.checked ? 'block' : 'none';
                         }
                         if (app) {
                             app.updateFixedScale();
                             // Redraw if not capturing
                             if (!app.capturing && app.currentFrameData) {
                                 app.redrawCurrentFrame();
                             }
                             app.saveAppSettings();
                         }
                    });
                }

                const updateFixedScale = () => {
                    if (app) {
                         app.updateFixedScale();
                         if (!app.capturing && app.currentFrameData) {
                             app.redrawCurrentFrame();
                         }
                         app.saveAppSettings();
                    }
                };

                if (this.el.fixedMinTemp) this.el.fixedMinTemp.addEventListener('change', updateFixedScale);
                if (this.el.fixedMaxTemp) this.el.fixedMaxTemp.addEventListener('change', updateFixedScale);

                // Smoothing
                if (this.el.smoothHeatmap) {
                    this.el.smoothHeatmap.addEventListener('change', (e) => {
                        if (app && app.heatmapRenderer) {
                            app.heatmapRenderer.setSmoothing(e.target.checked);
                            // Re-render if not capturing
                            if (!app.capturing && app.currentFrameData) {
                                app.redrawCurrentFrame();
                            }
                            app.saveAppSettings();
                        }
                    });
                }

                // Display Motion Map
                if (this.el.displayMotionMap) {
                    this.el.displayMotionMap.addEventListener('change', (e) => {
                        if (app && app.heatmapRenderer) {
                            app.heatmapRenderer.setDisplayMotionMap(e.target.checked);
                            // Re-render if not capturing
                            if (!app.capturing && app.currentFrameData) {
                                app.redrawCurrentFrame();
                            }
                            app.saveAppSettings();
                        }
                    });
                }

                // Transforms
                const updateTransforms = () => {
                    if (app) {
                        app.updateTransforms();
                        app.saveAppSettings();
                    }
                };
                if (this.el.flipHorizontal) this.el.flipHorizontal.addEventListener('change', updateTransforms);
                if (this.el.flipVertical) this.el.flipVertical.addEventListener('change', updateTransforms);
                if (this.el.rotate90) this.el.rotate90.addEventListener('change', updateTransforms);

                // Firmware update
                if (this.el.updateFirmwareBtn) {
                    this.el.updateFirmwareBtn.addEventListener('click', () => app.showUpdateModal());
                }
                if (this.el.checkUpdateBtn) {
                    this.el.checkUpdateBtn.addEventListener('click', () => app.checkForUpdate());
                }
                if (this.el.startUpdateBtn) {
                    this.el.startUpdateBtn.addEventListener('click', () => app.startFirmwareUpdate());
                }

                // Close modal buttons
                document.querySelectorAll('.modal-close').forEach(btn => {
                    btn.addEventListener('click', () => app.closeUpdateModal());
                });
                if (this.el.closeModalBtn) {
                    this.el.closeModalBtn.addEventListener('click', () => app.closeUpdateModal());
                }

                // Local file upload
                const localFileBtn = document.getElementById('chooseFirmwareBtn');
                const firmwareFileInput = document.getElementById('firmwareFileInput');
                if (localFileBtn && firmwareFileInput) {
                    localFileBtn.addEventListener('click', () => {
                        firmwareFileInput.click();
                    });
                    firmwareFileInput.addEventListener('change', (e) => app.handleFirmwareFileSelect(e));
                }

                // Reset button
                const resetBtn = document.getElementById('resetParamsBtn');
                if (resetBtn) {
                    resetBtn.addEventListener('click', () => app.resetRuntimeParams());
                }
            }

            /**
             * Apply UI mode (basic vs advanced)
             * Adds/removes 'basic-mode' class to adjust grid layout
             */
            applyUIMode() {
                const mainGrid = document.querySelector('.main-grid');
                const statBoxes = document.querySelectorAll('.stat-box');
                const peopleCountBox = this.el.peopleCount?.closest('.stat-box');
                const blobCountBox = this.el.blobCount?.closest('.stat-box');
                const tempRangeBox = this.el.tempRange?.closest('.stat-box');

                if (this.advancedMode) {
                    // Advanced mode: show all controls, use 3-column grid
                    if (mainGrid) mainGrid.classList.remove('basic-mode');
                    if (this.el.debugPanel) this.el.debugPanel.style.display = 'block';
                    statBoxes.forEach(box => box.style.display = 'block');
                } else {
                    // Basic mode: show people count, blobs, temp range; hide timing metrics
                    if (mainGrid) mainGrid.classList.add('basic-mode');
                    if (this.el.debugPanel) this.el.debugPanel.style.display = 'none';

                    // Show only: people count, blobs, temperature range
                    // Hide: ISP time, frame time, actual FPS
                    statBoxes.forEach(box => {
                        if (box === peopleCountBox || box === blobCountBox || box === tempRangeBox) {
                            box.style.display = 'block';
                        } else {
                            box.style.display = 'none';
                        }
                    });
                }
            }

            /**
             * Update UI for selected algorithm mode
             * @param {number} mode - 0=Full, 1=Simplified, 2=Simple
             */
            applyAlgorithmModeUI(mode) {
                const isSimple = (parseInt(mode) === 2);

                // Toggle Standard params
                if (this.el.standardModeParams) {
                    this.el.standardModeParams.forEach(el => {
                        el.style.display = isSimple ? 'none' : 'block';
                    });
                }

                // Toggle Simple params
                if (this.el.simpleModeParams) {
                    this.el.simpleModeParams.forEach(el => {
                        el.style.display = isSimple ? 'block' : 'none';
                    });
                }

                // Toggle Preset and Cold Detection groups (Standard only)
                if (this.el.presetConfigGroup) {
                    this.el.presetConfigGroup.style.display = isSimple ? 'none' : 'block';
                }
                if (this.el.coldDetectionGroup) {
                    this.el.coldDetectionGroup.style.display = isSimple ? 'none' : 'block';
                }

                // Update selector if needed (to match what's being applied)
                if (this.el.algoModeSelect && this.el.algoModeSelect.value != mode) {
                    this.el.algoModeSelect.value = mode;
                }
            }

            /**
             * Update stats display with cached elements
             * @param {Object} data - Stats data
             */
            updateStats(data) {
                if (this.el.peopleCount) this.el.peopleCount.textContent = data.peopleCount;
                if (this.el.blobCount) this.el.blobCount.textContent = data.blobCount;
                if (this.el.tempRange && data.tempMin !== undefined) {
                    this.el.tempRange.textContent = `${data.tempMin.toFixed(1)}-${data.tempMax.toFixed(1)}°C`;
                }
                if (this.el.processTime && data.processingTime !== undefined) {
                    this.el.processTime.textContent = `${data.processingTime.toFixed(1)} ms`;
                }
            }

            /**
             * Update timing metrics
             * @param {number} frameTime - Frame time in ms
             * @param {number} fps - Frames per second
             */
            updateTiming(frameTime, fps) {
                if (this.el.frameTime) this.el.frameTime.textContent = `${frameTime.toFixed(0)} ms`;
                if (this.el.actualFps) this.el.actualFps.textContent = `${fps.toFixed(2)} Hz`;
            }

            /**
             * Update frame counter
             * @param {number} count - Frame count
             */
            updateFrameCounter(count) {
                if (this.el.frameCounter) this.el.frameCounter.textContent = count;
            }

            /**
             * Set connection state
             * @param {boolean} connected
             */
            setConnectionState(connected) {
                const controls = [
                    this.el.captureToggle,
                    this.el.presetSelect,
                    // this.el.sensorMode, // Always disabled per user request
                    this.el.sensorFps,
                    this.el.applySensorConfigBtn
                ];
                controls.forEach(el => {
                    if (el) el.disabled = !connected;
                });

                // Algorithm Mode: Disabled when connected (must change offline)
                if (this.el.algoModeSelect) {
                    this.el.algoModeSelect.disabled = connected;
                }
            }

            /**
             * Set capture state
             * @param {boolean} capturing
             */
            setCaptureState(capturing) {
                if (this.el.recordBtn) this.el.recordBtn.disabled = !capturing;
                if (this.el.presetSelect) this.el.presetSelect.disabled = capturing;
            }
        }



        'use strict';

        /**
         * SerialManager - Handles Web Serial API communication with MLX9064x device
         * @class
         * @description Manages serial port connection, command transmission, and response parsing
         */
        class SerialManager {
            constructor() {
                this.port = null;
                this.reader = null;
                this.writer = null;
                this.connected = false;
            }

            /**
             * Check if Web Serial API is supported
             */
            isSupported() {
                return 'serial' in navigator;
            }

            /**
             * Check if currently connected to device
             */
            isConnected() {
                return this.connected;
            }

            /**
             * Request serial port from user
             * Auto-connects to MELEXISIO device if it's the only authorized port
             */
            async requestPort() {
                if (!this.isSupported()) {
                    throw new Error('Web Serial API not supported. Use Chrome or Edge browser.');
                }

                try {
                    // First, check if we have any previously authorized ports
                    const ports = await navigator.serial.getPorts();

                    // If exactly one port is authorized, check if it's MELEXISIO
                    if (ports.length === 1) {
                        const portInfo = ports[0].getInfo();
                        // Check for MELEXISIO device (look for productId in the device name)
                        // The device shows as "cu.usbmodemMELEXISIO1" on macOS
                        // We can't directly check the name, but if there's only one port, assume it's our device
                        console.log('Found single authorized port, auto-connecting...');
                        this.port = ports[0];
                        return this.port;
                    }

                    // If no authorized ports or multiple ports, show picker dialog
                    // Request ANY serial port (no filter)
                    // This shows all available ports in the picker dialog
                    this.port = await navigator.serial.requestPort();
                    return this.port;
                } catch (error) {
                    throw new Error(`Port selection failed: ${error.message}`);
                }
            }

            /**
             * Connect to serial port
             */
            async connect(baudRate = 921600) {
                if (!this.port) {
                    throw new Error('No port selected. Call requestPort() first.');
                }

                try {
                    await this.port.open({
                        baudRate: baudRate,
                        dataBits: 8,
                        stopBits: 1,
                        parity: 'none',
                        flowControl: 'none'
                    });

                    this.reader = this.port.readable.getReader();
                    this.writer = this.port.writable.getWriter();
                    this.connected = true;

                    console.log('Serial port connected:', baudRate, 'baud');

                    // Set DTR/RTS signals (some USB CDC devices need this to wake up)
                    try {
                        await this.port.setSignals({ dataTerminalReady: true, requestToSend: false });
                        console.log('DTR signal set to HIGH');
                    } catch (error) {
                        console.log('Note: Could not set DTR signal (this may be OK):', error.message);
                    }

                    // Delay for device to stabilize (USB CDC enumeration can be slow)
                    console.log('Waiting for device to stabilize...');
                    await new Promise(resolve => setTimeout(resolve, 500));

                    // Note: Minimal working test doesn't flush, let's skip it for now
                    // await this.flushInput(1000);
                    console.log('Skipping buffer flush to match working test pattern');
                } catch (error) {
                    throw new Error(`Connection failed: ${error.message}`);
                }
            }

            /**
             * Flush input buffer by reading and discarding data for a short time
             */
            async flushInput(timeMs = 1000) {
                const startTime = Date.now();
                const decoder = new TextDecoder();
                let bytesDiscarded = 0;

                console.log('Flushing input buffer for', timeMs, 'ms...');

                while (Date.now() - startTime < timeMs) {
                    try {
                        const readPromise = this.reader.read();
                        const timeoutPromise = new Promise((_, reject) =>
                            setTimeout(() => reject(new Error('timeout')), 100)
                        );

                        const result = await Promise.race([readPromise, timeoutPromise]);
                        if (!result.done && result.value) {
                            const text = decoder.decode(result.value);
                            bytesDiscarded += result.value.length;
                            console.log('Flushed:', text.substring(0, 80).replace(/\n/g, '\\n').replace(/\r/g, '\\r'));
                        }
                    } catch (error) {
                        // Timeout is expected when buffer is empty
                        if (error.message === 'timeout') {
                            console.log('Buffer empty (timeout after', Date.now() - startTime, 'ms)');
                            break;
                        } else {
                            console.error('Flush error:', error);
                        }
                    }
                }

                console.log('Input buffer flushed. Discarded', bytesDiscarded, 'bytes');
            }

            /**
             * Disconnect from serial port
             */
            async disconnect() {
                if (this.reader) {
                    await this.reader.cancel();
                    this.reader.releaseLock();
                    this.reader = null;
                }

                if (this.writer) {
                    this.writer.releaseLock();
                    this.writer = null;
                }

                if (this.port) {
                    await this.port.close();
                    this.port = null;
                }

                this.connected = false;
                console.log('Serial port disconnected');
            }

            /**
             * Reconnect (close and reopen) without losing port reference
             */
            async reconnect(baudRate = 921600) {
                if (!this.port) {
                    throw new Error('No port to reconnect. Must connect first.');
                }

                // Close readers/writers
                if (this.reader) {
                    await this.reader.cancel();
                    this.reader.releaseLock();
                    this.reader = null;
                }

                if (this.writer) {
                    this.writer.releaseLock();
                    this.writer = null;
                }

                // Close port but keep reference
                if (this.port) {
                    await this.port.close();
                }

                this.connected = false;
                console.log('Serial port closed for reconnect');

                // Wait 1 second for device to reset
                await new Promise(resolve => setTimeout(resolve, 1000));

                // Reopen same port
                await this.port.open({
                    baudRate: baudRate,
                    dataBits: 8,
                    stopBits: 1,
                    parity: 'none',
                    flowControl: 'none'
                });

                this.reader = this.port.readable.getReader();
                this.writer = this.port.writable.getWriter();
                this.connected = true;

                console.log('Serial port reconnected');
            }

            /**
             * Send SCPI command and read response until prompt
             */
            async sendCommand(command, timeoutMs = 3000) {
                if (!this.connected) {
                    throw new Error('Not connected to device');
                }

                // Send command
                const cmdWithNewline = command.endsWith('\n') ? command : command + '\n';
                const encoder = new TextEncoder();
                const encoded = encoder.encode(cmdWithNewline);

                console.debug('Sending command:', command, `(${encoded.length} bytes)`);
                await this.writer.write(encoded);
                console.debug('Command sent, waiting for response...');

                // Read response until prompt
                const response = await this.readUntilPrompt(timeoutMs);
                return response;
            }

            /**
             * Test basic communication by sending newline and reading any response
             */
            async testCommunication(timeoutMs = 3000) {
                console.log('=== COMMUNICATION TEST ===');

                // Check port signals
                try {
                    const signals = await this.port.getSignals();
                    console.log('Port signals:', signals);
                } catch (error) {
                    console.warn('Could not read port signals:', error.message);
                }

                const encoder = new TextEncoder();
                const testData = encoder.encode('\r\n');

                console.log('Sending test command:', Array.from(testData).map(b => `0x${b.toString(16)}`).join(' '));

                try {
                    await this.writer.write(testData);
                    console.log('✓ Write completed successfully');
                } catch (error) {
                    console.error('✗ Write FAILED:', error);
                    return false;
                }

                // Try to flush writer (some implementations support this)
                try {
                    if (this.writer.ready) {
                        await this.writer.ready;
                        console.log('✓ Writer ready');
                    }
                } catch (error) {
                    console.log('Note: Writer ready check failed (may be OK):', error.message);
                }

                console.log('Waiting for ANY response (exact pattern from working test)...');
                const startTime = Date.now();
                const decoder = new TextDecoder();
                let receivedAny = false;

                // EXACT pattern from working minimal test
                for (let i = 0; i < 10; i++) {
                    try {
                        const { value, done } = await Promise.race([
                            this.reader.read(),
                            new Promise((_, reject) => setTimeout(() => reject('timeout'), 500))
                        ]);

                        if (value && value.length > 0) {
                            const text = decoder.decode(value);
                            console.log('✓ RECEIVED (attempt', i + ', bytes:', value.length + '):',
                                       text.replace(/\r/g, '\\r').replace(/\n/g, '\\n'));
                            console.log('✓ Raw bytes:', Array.from(value).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));
                            receivedAny = true;
                            break;
                        }

                        if (done) {
                            console.log('Stream ended (done=true)');
                            break;
                        }
                    } catch (e) {
                        // Timeout rejection - expected, continue
                        if (i % 3 === 0) {
                            console.log('  Waiting... attempt', i);
                        }
                    }
                }

                const elapsed = Date.now() - startTime;

                if (!receivedAny) {
                    console.error('✗ NO RESPONSE from device after 10 attempts (', elapsed, 'ms)!');
                    console.error('');
                    console.error('CRITICAL: Port is open but device is not responding.');
                    console.error('');
                    console.error('Most likely causes:');
                    console.error('  1. Another program has exclusive access (check below)');
                    console.error('  2. Device needs reset (press RESET button)');
                    console.error('  3. Chrome security restrictions');
                    console.error('');
                    console.error('Run this in Terminal to check for port locks:');
                    console.error('  lsof | grep cu.usbmodem');
                    console.error('');
                    console.error('If you see any processes, kill them and reconnect.');
                } else {
                    console.log('✓ Communication working!');
                }

                return receivedAny;
            }

            /**
             * Read lines from serial port until prompt is detected
             */
            async readUntilPrompt(timeoutMs = 3000) {
                // Match prompt: (OK)> or (ERROR)> or (E2BIG)> etc., with optional leading/trailing whitespace
                // Supports errno names (E2BIG, EINVAL, etc.) in addition to standard prompts
                const promptRegex = /\((OK|ERROR|BUSY|TIMEOUT|CRC|ERR:\d+|E[A-Z0-9]+)\)>/;
                const decoder = new TextDecoder();
                let buffer = '';
                let lines = [];
                const startTime = Date.now();
                let debugLineCount = 0;
                let chunkCount = 0;

                console.debug('Reading until prompt... (timeout:', timeoutMs, 'ms)');

                while (true) {
                    // Check timeout
                    const elapsed = Date.now() - startTime;
                    if (elapsed > timeoutMs) {
                        console.error('TIMEOUT after', elapsed, 'ms. Received', lines.length, 'lines:');
                        lines.forEach((line, i) => console.log(`  Line ${i}: ${line.substring(0, 80)}`));
                        console.error('Remaining buffer:', buffer.substring(0, 100));
                        throw new Error('Command timeout: no prompt received');
                    }

                    // Read chunk (blocking read, no timeout race)
                    let chunk;
                    try {
                        const result = await this.reader.read();
                        if (result.done) {
                            throw new Error('Serial port closed unexpectedly');
                        }
                        chunk = result.value;
                    } catch (error) {
                        console.error('Read error:', error);
                        throw error;
                    }

                    if (!chunk || chunk.length === 0) {
                        // No data, wait a bit and try again
                        await new Promise(r => setTimeout(r, 50));
                        continue;
                    }

                    // Decode and buffer
                    const newData = decoder.decode(chunk, { stream: true });
                    buffer += newData;
                    chunkCount++;

                    // Debug: Show first few chunks
                    if (chunkCount <= 5) {
                        console.debug('Chunk', chunkCount + ':',
                                   newData.substring(0, 80).replace(/\n/g, '\\n').replace(/\r/g, '\\r'),
                                   '(', chunk.length, 'bytes)');
                    }

                    // Extract complete lines (split on \n or \r\n)
                    const lineMatches = buffer.split(/\r?\n/);

                    // Keep last incomplete line in buffer
                    buffer = lineMatches.pop() || '';

                    for (const line of lineMatches) {
                        const trimmedLine = line.trim();
                        if (trimmedLine) {
                            lines.push(trimmedLine);
                            debugLineCount++;

                            // Debug: Show first few lines
                            if (debugLineCount <= 10) {
                                // Truncate line if it's too long to avoid flooding console with big data blocks
                                const displayLine = trimmedLine.length > 200 ? trimmedLine.substring(0, 200) + '... [truncated]' : trimmedLine;
                                console.debug(`Line ${debugLineCount}: "${displayLine}"`);
                            }

                            // Check for prompt (now checks anywhere in line)
                            if (promptRegex.test(trimmedLine)) {
                                console.debug('✓ Prompt detected:', trimmedLine);
                                console.debug('✓ Total lines received:', lines.length);
                                return lines.join('\n');
                            }
                        }
                    }

                    // Also check buffer for prompt (in case no newline after prompt)
                    if (promptRegex.test(buffer.trim())) {
                        console.debug('✓ Prompt detected in buffer:', buffer.trim());
                        if (buffer.trim()) {
                            lines.push(buffer.trim());
                        }
                        console.debug('✓ Total lines received:', lines.length);
                        return lines.join('\n');
                    }
                }
            }
        }

        /**
         * ThermalParser - Parses SCPI ONCE2 ASCII output into structured thermal data
         * @class
         * @description Extracts thermal frames, foreground masks, and metadata from SCPI responses
         */
        class ThermalParser {
            constructor() {
                this.frameWidth = 32;
                this.frameHeight = 24;
            }

            /**
             * Parse JSON output from CAPTURE 2 command
             * Returns structured thermal data compatible with existing renderers
             */
            parseJSON(text) {
                try {
                    // Extract JSON object (find first '{' and last '}')
                    const startIndex = text.indexOf('{');
                    const endIndex = text.lastIndexOf('}');

                    if (startIndex === -1 || endIndex === -1) {
                        // Fallback: check if it looks like the old format (just in case)
                        if (text.includes('People:')) {
                            return this.parseONCE2(text);
                        }
                        throw new Error('No JSON object found in response');
                    }

                    const jsonText = text.substring(startIndex, endIndex + 1);
                    const data = JSON.parse(jsonText);

                    // Map JSON data to application format
                    const result = {
                        thermalFrame: [],
                        foregroundMask: [],
                        motionMask: [], // New: Motion mask
                        peopleCount: data.meta.people,
                        activityCount: data.meta.people_act,
                        blobCount: data.meta.blobs,
                        blobs: data.blobs,
                        tempMin: data.meta.temp_min,
                        tempMax: data.meta.temp_max,
                        processingTime: data.meta.time,
                        scaleInfo: {
                            minTemp: data.meta.temp_min,
                            maxTemp: data.meta.temp_max,
                            minDigit: 0,
                            maxDigit: 255
                        }
                    };

                    // Reconstruct 2D thermal frame from flat array
                    const width = 32;
                    const height = 24;
                    let minVal = Infinity;
                    let maxVal = -Infinity;

                    for (let y = 0; y < height; y++) {
                        const row = [];
                        const maskRow = new Array(width).fill(false);
                        const motionRow = new Array(width).fill(false);

                        for (let x = 0; x < width; x++) {
                            const val = data.frame[y * width + x];
                            row.push(val);

                            if (val < minVal) minVal = val;
                            if (val > maxVal) maxVal = val;
                        }
                        result.thermalFrame.push(row);
                        result.foregroundMask.push(maskRow);
                        result.motionMask.push(motionRow);
                    }

                    // Update scale info for auto-scaling heatmap
                    result.scaleInfo.minDigit = minVal;
                    result.scaleInfo.maxDigit = maxVal;

                    // Reconstruct motion mask from hex string
                    if (data.motion_mask) {
                        for (let y = 0; y < height; y++) {
                            const hexRow = data.motion_mask.substring(y * 8, (y + 1) * 8);
                            if (hexRow.length === 8) {
                                const rowBits = parseInt(hexRow, 16);
                                for (let x = 0; x < width; x++) {
                                    if ((rowBits >>> x) & 1) {
                                        result.motionMask[y][x] = true;
                                    }
                                }
                            }
                        }
                    }

                    // Reconstruct foreground mask from blob hex strings
                    if (data.blobs && Array.isArray(data.blobs)) {
                        for (const blob of data.blobs) {
                            if (blob.mask) {
                                // Mask is 192 chars (24 rows * 8 chars)
                                for (let y = 0; y < height; y++) {
                                    const hexRow = blob.mask.substring(y * 8, (y + 1) * 8);
                                    if (hexRow.length === 8) {
                                        // Parse 32-bit integer from hex
                                        const rowBits = parseInt(hexRow, 16);

                                        for (let x = 0; x < width; x++) {
                                            // Check if bit is set (assuming LSB is x=0)
                                            if ((rowBits >>> x) & 1) {
                                                result.foregroundMask[y][x] = true;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                    return result;
                } catch (error) {
                    console.error('JSON Parse Error:', error);
                    throw new Error('Failed to parse JSON output: ' + error.message);
                }
            }

            /**
             * Parse ONCE2 command output
             * Returns: {
             *   thermalFrame: [[int16]], // 24x32 array (digit 0-9)
             *   foregroundMask: [[bool]], // 24x32 array (true=detected)
             *   peopleCount: int,
             *   activityCount: int,
             *   blobCount: int,
             *   tempMin: float,
             *   tempMax: float,
             *   processingTime: float,
             *   scaleInfo: {minTemp, maxTemp} // For digit→temp mapping
             * }
             */
            parseONCE2(text) {
                // Check for error responses
                if (text.includes('[ERROR]') || text.includes('not initialized')) {
                    throw new Error('People detection not initialized or error response received');
                }

                const lines = text.split('\n');
                const result = {
                    thermalFrame: [],
                    foregroundMask: [],
                    peopleCount: 0,
                    activityCount: -1,
                    blobCount: 0,
                    tempMin: 0,
                    tempMax: 0,
                    processingTime: 0,
                    scaleInfo: { minTemp: 0, maxTemp: 0, minDigit: 0, maxDigit: 9 }
                };

                // Extract scale information
                const scaleMatch = text.match(/Scale: (\d)=([-\d.]+)°C.*?(\d)=([-\d.]+)°C/);
                if (scaleMatch) {
                    result.scaleInfo.minDigit = parseInt(scaleMatch[1]);
                    result.scaleInfo.minTemp = parseFloat(scaleMatch[2]);
                    result.scaleInfo.maxDigit = parseInt(scaleMatch[3]);
                    result.scaleInfo.maxTemp = parseFloat(scaleMatch[4]);
                }

                // Extract thermal frame rows (format: "NN: digit+ digit digit+ ...")
                // NOTE: Firmware outputs foreground clusters without spaces: "6+6+5+5+" not "6+ 6+ 5+ 5+"
                const rowRegex = /(\d{2}):\s+([\d+\s]+)/;
                for (const line of lines) {
                    const match = line.match(rowRegex);
                    if (match) {
                        const rowNum = parseInt(match[1]);
                        const rowData = match[2];

                        // Parse pixels: handle both "6+ 7+" (with spaces) and "6+7+" (without spaces)
                        // Strategy: Split by spaces, then further split any tokens containing '+' signs
                        const tokens = rowData.trim().split(/\s+/);
                        const thermalRow = [];
                        const maskRow = [];

                        for (const token of tokens) {
                            if (token.includes('+')) {
                                // Token contains foreground markers: split on '+' and process each digit
                                // "6+7+8+" -> ["6", "7", "8", ""]
                                // "6+7+8" -> ["6", "7", "8"]
                                const parts = token.split('+').filter(p => p !== '');
                                for (const part of parts) {
                                    const digit = parseInt(part);
                                    if (!isNaN(digit)) {
                                        thermalRow.push(digit);
                                        maskRow.push(true);  // Foreground

                                        // Debug first few foreground detections
                                        if (result.foregroundMask.length === 0) {
                                            console.log(`Found foreground at row ${rowNum}, token: "${token}" -> digit: ${digit}`);
                                        }
                                    }
                                }
                            } else {
                                // Background pixel (no '+')
                                const digit = parseInt(token);
                                if (!isNaN(digit)) {
                                    thermalRow.push(digit);
                                    maskRow.push(false);
                                }
                            }
                        }

                        result.thermalFrame.push(thermalRow);
                        result.foregroundMask.push(maskRow);
                    }
                }

                // Extract summary line
                // Format 1: "People: N (M) | Blobs: B | Temp: min-max°C | Time: Tms"
                // Format 2: "People: N | Blobs: B | Temp: min-max°C | Time: Tms"
                const summaryMatch = text.match(/People:\s+(\d+)(?:\s+\((\d+)\))?\s+\|\s+Blobs:\s+(\d+)\s+\|\s+Temp:\s+([-\d.]+)-([-\d.]+)°C\s+\|\s+Time:\s+([\d.]+)ms/);
                if (summaryMatch) {
                    result.peopleCount = parseInt(summaryMatch[1]);
                    result.activityCount = summaryMatch[2] ? parseInt(summaryMatch[2]) : -1;
                    result.blobCount = parseInt(summaryMatch[3]);
                    result.tempMin = parseFloat(summaryMatch[4]);
                    result.tempMax = parseFloat(summaryMatch[5]);
                    result.processingTime = parseFloat(summaryMatch[6]);
                }

                return result;
            }

            /**
             * Map digit (0-9) to actual temperature using scale info
             */
            digitToTemp(digit, scaleInfo) {
                const { minTemp, maxTemp, minDigit, maxDigit } = scaleInfo;
                const range = maxTemp - minTemp;
                const digitRange = maxDigit - minDigit;
                return minTemp + (digit - minDigit) * (range / digitRange);
            }
        }

        /**
         * HeatmapRenderer - Renders thermal data as color-coded heatmap canvas
         * @class
         * @description Visualizes 32x24 thermal pixels with blue-to-red gradient and optional bilinear smoothing
         */
        class HeatmapRenderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.pixelSize = 20;  // Each thermal pixel = 20x20 screen pixels
                this.smoothingEnabled = true;  // Default to smooth rendering
                this.flipX = false;
                this.flipY = false;
                this.rotate90 = false;
                this.displayMotionMap = false;

                // Fixed scale settings
                this.fixedScale = true;
                this.fixedMin = 20.0;
                this.fixedMax = 33.0;
            }

            setDisplayMotionMap(enabled) {
                this.displayMotionMap = enabled;
            }

            setTransforms(flipX, flipY, rotate90) {
                this.flipX = flipX;
                this.flipY = flipY;
                this.rotate90 = rotate90;
            }

            setFixedScale(enabled, min, max) {
                this.fixedScale = enabled;
                this.fixedMin = parseFloat(min);
                this.fixedMax = parseFloat(max);
            }

            /**
             * Get color for temperature value (0.0 to 1.0 normalized)
             */
            getColor(normalized) {
                // Clamp range to 0.0-1.0 (Blue to Red)
                if (normalized < 0) normalized = 0;
                if (normalized > 1) normalized = 1;

                // Blue → Cyan → Green → Yellow → Red gradient
                if (normalized < 0.25) {
                    // Blue to Cyan
                    const t = normalized / 0.25;
                    return `rgb(0, ${Math.floor(t * 255)}, 255)`;
                } else if (normalized < 0.5) {
                    // Cyan to Green
                    const t = (normalized - 0.25) / 0.25;
                    return `rgb(0, 255, ${Math.floor((1-t) * 255)})`;
                } else if (normalized < 0.75) {
                    // Green to Yellow
                    const t = (normalized - 0.5) / 0.25;
                    return `rgb(${Math.floor(t * 255)}, 255, 0)`;
                } else {
                    // Yellow to Red
                    const t = (normalized - 0.75) / 0.25;
                    return `rgb(255, ${Math.floor((1-t) * 255)}, 0)`;
                }
            }

            /**
             * Enable or disable smoothing
             */
            setSmoothing(enabled) {
                this.smoothingEnabled = enabled;
            }

            /**
             * Bilinear interpolation helper
             */
            bilinearInterpolate(x, y, thermalFrame, minDigit, digitRange) {
                // Get the four surrounding pixel values
                const x0 = Math.floor(x);
                const x1 = Math.min(x0 + 1, thermalFrame[0].length - 1);
                const y0 = Math.floor(y);
                const y1 = Math.min(y0 + 1, thermalFrame.length - 1);

                // Get normalized values for the four corners
                const getVal = (yi, xi) => {
                    if (!thermalFrame[yi] || thermalFrame[yi][xi] === undefined ||
                        isNaN(thermalFrame[yi][xi]) || thermalFrame[yi][xi] === null) {
                        return 0; // Default for invalid data
                    }
                    return (thermalFrame[yi][xi] - minDigit) / digitRange;
                };

                const q11 = getVal(y0, x0);
                const q21 = getVal(y0, x1);
                const q12 = getVal(y1, x0);
                const q22 = getVal(y1, x1);

                // Fractional parts
                const fx = x - x0;
                const fy = y - y0;

                // Bilinear interpolation
                const value = q11 * (1 - fx) * (1 - fy) +
                             q21 * fx * (1 - fy) +
                             q12 * (1 - fx) * fy +
                             q22 * fx * fy;

                return value;
            }

            /**
             * Render thermal heatmap
             */
            render(thermalFrame, scaleInfo, motionMask = null) {
                // Validate input data
                if (!thermalFrame || thermalFrame.length === 0 || !thermalFrame[0]) {
                    console.warn('Invalid thermal frame data - skipping render');
                    this.ctx.fillStyle = '#000';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    return;
                }

                let effectiveMinDigit = scaleInfo.minDigit;
                let effectiveDigitRange = scaleInfo.maxDigit - scaleInfo.minDigit || 1;

                // Apply fixed scaling if enabled
                if (this.fixedScale) {
                    const tempRange = scaleInfo.maxTemp - scaleInfo.minTemp;
                    const digitRange = scaleInfo.maxDigit - scaleInfo.minDigit;

                    if (Math.abs(tempRange) > 0.01) {
                        const tempToDigit = (t) => {
                            return scaleInfo.minDigit + (t - scaleInfo.minTemp) * digitRange / tempRange;
                        };

                        const dMin = tempToDigit(this.fixedMin);
                        const dMax = tempToDigit(this.fixedMax);

                        effectiveMinDigit = dMin;
                        effectiveDigitRange = dMax - dMin;

                        // Prevent division by zero
                        if (Math.abs(effectiveDigitRange) < 0.01) effectiveDigitRange = 1;
                    }
                }

                const srcW = thermalFrame[0].length;
                const srcH = thermalFrame.length;

                // Determine destination dimensions
                // If rotated 90 deg, Width and Height are swapped relative to source * scale
                const destW = this.rotate90 ? srcH * this.pixelSize : srcW * this.pixelSize;
                const destH = this.rotate90 ? srcW * this.pixelSize : srcH * this.pixelSize;

                // Resize canvas if necessary
                if (this.canvas.width !== destW || this.canvas.height !== destH) {
                    this.canvas.width = destW;
                    this.canvas.height = destH;
                }

                // Clear canvas
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                if (this.smoothingEnabled) {
                    // Smooth rendering with bilinear interpolation
                    const imageData = this.ctx.createImageData(this.canvas.width, this.canvas.height);
                    const data = imageData.data;

                    for (let py = 0; py < this.canvas.height; py++) {
                        for (let px = 0; px < this.canvas.width; px++) {
                            // 1. Apply screen-space flips
                            // We map current pixel (px,py) to a 'virtual' pixel (vx,vy) before rotation mapping
                            const vx = this.flipX ? (this.canvas.width - 1 - px) : px;
                            const vy = this.flipY ? (this.canvas.height - 1 - py) : py;

                            // 2. Map to source coordinates
                            let tx, ty;

                            if (this.rotate90) {
                                // 90 deg CW: Dest X axis is Source Y axis (inverted), Dest Y axis is Source X axis
                                // Source X = Dest Y
                                // Source Y = Source Height - 1 - Dest X
                                tx = vy / this.pixelSize;
                                ty = (this.canvas.width - 1 - vx) / this.pixelSize;
                            } else {
                                // No rotation
                                tx = vx / this.pixelSize;
                                ty = vy / this.pixelSize;
                            }

                            // Skip if outside thermal frame bounds (shouldn't happen with correct sizing, but safety)
                            if (tx < 0 || tx >= srcW || ty < 0 || ty >= srcH) {
                                continue;
                            }

                            // Get interpolated value
                            const normalized = this.bilinearInterpolate(tx, ty, thermalFrame, effectiveMinDigit, effectiveDigitRange);
                            const color = this.getColor(normalized);

                            // Determine opacity based on motion mask
                            // For smooth rendering, we sample the nearest pixel in the motion mask
                            let alpha = 255;
                            if (this.displayMotionMap && motionMask) {
                                const mx = Math.floor(tx);
                                const my = Math.floor(ty);
                                if (my >= 0 && my < motionMask.length && mx >= 0 && mx < motionMask[0].length) {
                                    if (!motionMask[my][mx]) {
                                        alpha = 204; // 80% opacity for static pixels (more visible)
                                    }
                                }
                            }

                            // Parse RGB values from color string
                            const matches = color.match(/\d+/g);
                            if (matches && matches.length >= 3) {
                                const idx = (py * this.canvas.width + px) * 4;
                                data[idx] = parseInt(matches[0]);     // R
                                data[idx + 1] = parseInt(matches[1]); // G
                                data[idx + 2] = parseInt(matches[2]); // B
                                data[idx + 3] = alpha;                // A
                            }
                        }
                    }

                    this.ctx.putImageData(imageData, 0, 0);
                } else {
                    // Pixelated rendering
                    // Iterate over SOURCE pixels and map them to DESTINATION rects
                    for (let sy = 0; sy < srcH; sy++) {
                        for (let sx = 0; sx < srcW; sx++) {
                            // Handle missing data or invalid values
                            if (!thermalFrame[sy] || thermalFrame[sy][sx] === undefined) continue;

                            const digit = thermalFrame[sy][sx];
                            if (isNaN(digit) || digit === null) continue;

                            // Calculate Dest coordinates (in Grid units)
                            let dx, dy;

                            if (this.rotate90) {
                                // 90 CW: dx = srcH - 1 - sy, dy = sx
                                dx = srcH - 1 - sy;
                                dy = sx;
                            } else {
                                dx = sx;
                                dy = sy;
                            }

                            // Apply Flips (in Grid units)
                            // Dest Grid Width/Height
                            const gridW = this.canvas.width / this.pixelSize;
                            const gridH = this.canvas.height / this.pixelSize;

                            if (this.flipX) dx = gridW - 1 - dx;
                            if (this.flipY) dy = gridH - 1 - dy;

                            const normalized = (digit - effectiveMinDigit) / effectiveDigitRange;
                            let color = this.getColor(normalized);

                            // Apply dimming for static pixels
                            if (this.displayMotionMap && motionMask && !motionMask[sy][sx]) {
                                // Convert rgb(...) to rgba(..., 0.8)
                                color = color.replace('rgb', 'rgba').replace(')', ', 0.8)');
                            }

                            this.ctx.fillStyle = color;
                            this.ctx.fillRect(
                                dx * this.pixelSize,
                                dy * this.pixelSize,
                                this.pixelSize,
                                this.pixelSize
                            );
                        }
                    }
                }
            }
        }

        /**
         * BlobOverlay - Draws detection blob overlays on thermal canvas
         * @class
         * @description Renders connected components, bounding boxes, centroids, and blob labels using flood-fill algorithm
         */
        class BlobOverlay {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.pixelSize = 20;
                this.flipX = false;
                this.flipY = false;
                this.rotate90 = false;
            }

            setTransforms(flipX, flipY, rotate90) {
                this.flipX = flipX;
                this.flipY = flipY;
                this.rotate90 = rotate90;
            }

            /**
             * Transform source coordinate to destination coordinate
             * @param {number} x - Source X coordinate
             * @param {number} y - Source Y coordinate
             * @param {number} srcH - Source Height
             */
            transformPoint(x, y, srcH) {
                // Grid Dimensions
                const gridW = this.canvas.width / this.pixelSize;
                const gridH = this.canvas.height / this.pixelSize;

                let dx, dy;
                if (this.rotate90) {
                    // 90 CW: x' = H - y, y' = x
                    dx = srcH - y;
                    dy = x;
                } else {
                    dx = x;
                    dy = y;
                }

                if (this.flipX) dx = gridW - dx;
                if (this.flipY) dy = gridH - dy;

                return { x: dx, y: dy };
            }

            /**
             * Get color for blob index (cycle through palette)
             */
            getBlobColor(index, alpha = 0.6) {
                const colors = [
                    [0, 255, 136],    // Neon green
                    [255, 0, 102],    // Neon pink
                    [0, 204, 255],    // Cyan
                    [255, 187, 0],    // Amber
                    [153, 102, 255],  // Purple
                    [255, 102, 0],    // Orange
                    [102, 255, 102],  // Light green
                    [255, 102, 178],  // Pink
                    [102, 178, 255],  // Light blue
                    [255, 255, 102]   // Yellow
                ];
                const [r, g, b] = colors[index % colors.length];
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            }

            /**
             * Render simple foreground overlay (uniform color for all detected pixels)
             */
            renderForegroundOverlay(foregroundMask) {
                // Validate input
                if (!foregroundMask || foregroundMask.length === 0) {
                    return;
                }

                const srcH = foregroundMask.length;

                // Simple semi-transparent overlay for all foreground pixels
                this.ctx.fillStyle = 'rgba(255, 255, 0, 0.25)';  // Light yellow

                for (let y = 0; y < foregroundMask.length; y++) {
                    if (!foregroundMask[y]) continue;
                    for (let x = 0; x < foregroundMask[y].length; x++) {
                        if (foregroundMask[y][x]) {
                            // Transform corners
                            const p1 = this.transformPoint(x, y, srcH);
                            const p2 = this.transformPoint(x + 1, y + 1, srcH);

                            const minX = Math.min(p1.x, p2.x);
                            const minY = Math.min(p1.y, p2.y);
                            const w = Math.abs(p2.x - p1.x);
                            const h = Math.abs(p2.y - p1.y);

                            this.ctx.fillRect(
                                minX * this.pixelSize,
                                minY * this.pixelSize,
                                w * this.pixelSize,
                                h * this.pixelSize
                            );
                        }
                    }
                }
            }

            /**
             * Calculate bounding boxes for connected foreground regions
             */
            calculateBoundingBoxes(foregroundMask) {
                const height = foregroundMask.length;
                const width = foregroundMask[0].length;
                const visited = Array(height).fill().map(() => Array(width).fill(false));
                const boxes = [];

                // Flood fill to find connected components
                const floodFill = (startY, startX) => {
                    const stack = [[startY, startX]];
                    let minX = width, maxX = 0, minY = height, maxY = 0;
                    let pixelCount = 0;
                    let sumX = 0, sumY = 0;

                    while (stack.length > 0) {
                        const [y, x] = stack.pop();

                        if (y < 0 || y >= height || x < 0 || x >= width) continue;
                        if (visited[y][x] || !foregroundMask[y][x]) continue;

                        visited[y][x] = true;
                        minX = Math.min(minX, x);
                        maxX = Math.max(maxX, x);
                        minY = Math.min(minY, y);
                        maxY = Math.max(maxY, y);
                        pixelCount++;
                        sumX += x;
                        sumY += y;

                        // Check 4-connected neighbors
                        stack.push([y-1, x], [y+1, x], [y, x-1], [y, x+1]);
                    }

                    return {
                        minX, maxX, minY, maxY,
                        centroidX: sumX / pixelCount,
                        centroidY: sumY / pixelCount,
                        area: pixelCount
                    };
                };

                // Find all connected components
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        if (foregroundMask[y][x] && !visited[y][x]) {
                            const box = floodFill(y, x);
                            if (box.area >= 5) {  // Filter small noise blobs
                                boxes.push(box);
                            }
                        }
                    }
                }

                return boxes;
            }

            /**
             * Draw contour around a blob mask
             */
            drawBlobContour(foregroundMask, blobLabels, blobId, color) {
                const height = foregroundMask.length;
                const width = foregroundMask[0].length;

                const drawLine = (x1, y1, x2, y2) => {
                    const p1 = this.transformPoint(x1, y1, height);
                    const p2 = this.transformPoint(x2, y2, height);

                    this.ctx.beginPath();
                    this.ctx.moveTo(p1.x * this.pixelSize, p1.y * this.pixelSize);
                    this.ctx.lineTo(p2.x * this.pixelSize, p2.y * this.pixelSize);
                    this.ctx.stroke();
                };

                // For each pixel in the blob, draw borders on edges that face background
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        if (blobLabels[y][x] === blobId) {
                            // Top edge
                            if (y === 0 || blobLabels[y-1][x] !== blobId) {
                                this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                                this.ctx.lineWidth = 4;
                                drawLine(x, y, x + 1, y);

                                this.ctx.strokeStyle = color;
                                this.ctx.lineWidth = 3;
                                drawLine(x, y, x + 1, y);
                            }
                            // Bottom edge
                            if (y === height - 1 || blobLabels[y+1][x] !== blobId) {
                                this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                                this.ctx.lineWidth = 4;
                                drawLine(x, y + 1, x + 1, y + 1);

                                this.ctx.strokeStyle = color;
                                this.ctx.lineWidth = 3;
                                drawLine(x, y + 1, x + 1, y + 1);
                            }
                            // Left edge
                            if (x === 0 || blobLabels[y][x-1] !== blobId) {
                                this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                                this.ctx.lineWidth = 4;
                                drawLine(x, y, x, y + 1);

                                this.ctx.strokeStyle = color;
                                this.ctx.lineWidth = 3;
                                drawLine(x, y, x, y + 1);
                            }
                            // Right edge
                            if (x === width - 1 || blobLabels[y][x+1] !== blobId) {
                                this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                                this.ctx.lineWidth = 4;
                                drawLine(x + 1, y, x + 1, y + 1);

                                this.ctx.strokeStyle = color;
                                this.ctx.lineWidth = 3;
                                drawLine(x + 1, y, x + 1, y + 1);
                            }
                        }
                    }
                }
            }

            /**
             * Render blob contours and labels (color-coded per blob)
             */
            renderBlobs(foregroundMask, peopleCount, firmwareBlobs = null) {
                // Validate input
                if (!foregroundMask || foregroundMask.length === 0) {
                    return;
                }

                let boxes;
                let blobLabels;

                const height = foregroundMask.length;
                const width = foregroundMask[0].length;
                blobLabels = Array(height).fill().map(() => Array(width).fill(-1));

                if (firmwareBlobs && Array.isArray(firmwareBlobs)) {
                    // Use firmware data directly (Preserves tracking IDs)
                    boxes = [];

                    firmwareBlobs.forEach((blob) => {
                        // Box structure from firmware JSON: "box":[minX, minY, w, h]
                        const [minX, minY, w, h] = blob.box;

                        boxes.push({
                            minX: minX,
                            maxX: minX + w - 1,
                            minY: minY,
                            maxY: minY + h - 1,
                            centroidX: blob.cx,
                            centroidY: blob.cy,
                            area: blob.area,
                            id: blob.id, // Keep original ID for consistent coloring
                            act: blob.act // Pass activity status
                        });

                        // Populate blobLabels from blob mask
                        if (blob.mask) {
                            for (let y = 0; y < height; y++) {
                                // Mask string is 192 chars (24 rows * 8 chars)
                                const hexRow = blob.mask.substring(y * 8, (y + 1) * 8);
                                if (hexRow.length === 8) {
                                    const rowBits = parseInt(hexRow, 16);
                                    for (let x = 0; x < width; x++) {
                                        if ((rowBits >>> x) & 1) {
                                            blobLabels[y][x] = blob.id;
                                        }
                                    }
                                }
                            }
                        }
                    });
                } else {
                    // Legacy: Calculate everything from mask (No tracking IDs)
                    boxes = this.calculateBoundingBoxes(foregroundMask);
                    if (boxes.length === 0) return;

                    const visited = Array(height).fill().map(() => Array(width).fill(false));
                    let blobIndex = 0;

                    // Flood fill to assign blob IDs
                    const floodFill = (startY, startX, id) => {
                        const stack = [[startY, startX]];
                        while (stack.length > 0) {
                            const [y, x] = stack.pop();
                            if (y < 0 || y >= height || x < 0 || x >= width) continue;
                            if (visited[y][x] || !foregroundMask[y][x]) continue;
                            visited[y][x] = true;
                            blobLabels[y][x] = id;
                            stack.push([y-1, x], [y+1, x], [y, x-1], [y, x+1]);
                        }
                    };

                    // Find all blobs
                    for (let y = 0; y < height; y++) {
                        for (let x = 0; x < width; x++) {
                            if (foregroundMask[y][x] && !visited[y][x]) {
                                floodFill(y, x, blobIndex);
                                blobIndex++;
                            }
                        }
                    }
                }

                // Draw contours and annotations for each blob
                boxes.forEach((box, index) => {
                    // Use firmware ID if available, otherwise index
                    const blobId = (box.id !== undefined) ? box.id : index;

                    // Get blob status
                    // box.act comes from firmware JSON ("true" or "false" string)
                    const isActive = (box.act === "true" || box.act === true);

                    // Get blob-specific color
                    // Active = Green, Inactive = Red
                    const blobColor = isActive ? 'rgba(0, 255, 0, 1.0)' : 'rgba(255, 50, 50, 1.0)';

                    // Draw contour (outline of blob mask)
                    // User requested green outline only -> Update: Now dynamic based on activity
                    this.drawBlobContour(foregroundMask, blobLabels, blobId, blobColor);

                    // Draw centroid crosshair
                    // Transform centroid
                    const cp = this.transformPoint(box.centroidX + 0.5, box.centroidY + 0.5, height);

                    const cx = cp.x * this.pixelSize;
                    const cy = cp.y * this.pixelSize;
                    const crossSize = 12;

                    // Crosshair shadow
                    this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                    this.ctx.lineWidth = 4;
                    this.ctx.beginPath();
                    this.ctx.moveTo(cx - crossSize, cy);
                    this.ctx.lineTo(cx + crossSize, cy);
                    this.ctx.moveTo(cx, cy - crossSize);
                    this.ctx.lineTo(cx, cy + crossSize);
                    this.ctx.stroke();

                    // Crosshair main (blob-specific color)
                    this.ctx.strokeStyle = blobColor;
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.moveTo(cx - crossSize, cy);
                    this.ctx.lineTo(cx + crossSize, cy);
                    this.ctx.moveTo(cx, cy - crossSize);
                    this.ctx.lineTo(cx, cy + crossSize);
                    this.ctx.stroke();

                    // Draw label with background (show ID + 1 for user-friendliness)
                    // Relocate to center point minus 1 thermal pixel (shifted up-left)
                    const labelX = (cp.x - 1) * this.pixelSize;
                    const labelY = (cp.y - 1) * this.pixelSize;

                    const label = `${blobId + 1}`;
                    this.ctx.font = 'bold 14px sans-serif';
                    const textWidth = this.ctx.measureText(label).width;
                    const boxPadding = 4;
                    const boxWidth = textWidth + (boxPadding * 2);
                    const boxHeight = 20;

                    // Draw centered background box at the target position
                    const boxX = labelX - (boxWidth / 2);
                    const boxY = labelY - (boxHeight / 2);

                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    this.ctx.fillRect(boxX, boxY, boxWidth, boxHeight);

                    // Draw border
                    this.ctx.strokeStyle = blobColor;
                    this.ctx.lineWidth = 1.5;
                    this.ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);

                    // Draw text centered
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillStyle = blobColor;
                    this.ctx.fillText(label, labelX, labelY);

                    // Reset text alignment for other draws
                    this.ctx.textAlign = 'start';
                    this.ctx.textBaseline = 'alphabetic';
                });
            }
        }

        /**
         * ThermalViewerApp - Main application orchestrator
         * @class
         * @description Coordinates serial communication, rendering, chart updates, and user interactions for real-time thermal people detection
         */
        class ThermalViewerApp {
            constructor() {
                this.serialManager = new SerialManager();
                this.ui = new UIManager();
                this.thermalParser = new ThermalParser();
                this.canvas = document.getElementById('thermalCanvas');
                this.heatmapRenderer = new HeatmapRenderer(this.canvas);
                this.blobOverlay = new BlobOverlay(this.canvas);

                this.capturing = false;
                this.frameRate = CONFIG.capture.defaultFrameRate;
                this.captureInterval = null;
                this.frameCount = 0;
                this.captureInProgress = false;  // Prevent overlapping requests

                // Timing metrics
                this.lastFrameStartTime = 0;
                this.lastFrameDuration = 0;
                this.avgFrameDuration = 0;
                this.frameTimeSamples = [];
                this.maxFrameTimeSamples = CONFIG.capture.maxFrameTimeSamples;

                // Chart setup
                this.chart = null;
                this.peopleHistory = [];
                this.frameHistory = [];
                this.maxHistoryLength = CONFIG.chart.maxHistoryLength;

                // Recording
                this.recording = false;
                this.recordedFrames = [];

                // Firmware updater
                this.firmwareUpdater = new FirmwareUpdater(this.serialManager);
                this.currentUpdateInfo = null;
                this.connectedViaProbe = false;  // Track if connected via probe for update modal

                this.algoMode = 1; // Default to Simplified

                // Tooltip for hover
                this.currentFrameData = null;
                this.createTooltip();
                this.canvas.addEventListener('mousemove', (e) => this.handleCanvasMouseMove(e));
                this.canvas.addEventListener('mouseleave', () => this.hideTooltip());

                this.initChart();
                this.initRuntimeParams();
                this.loadAppSettings();
                this.log('Application initialized. Click "Connect Device" to begin.');
            }

            createTooltip() {
                this.tooltip = document.createElement('div');
                this.tooltip.style.position = 'absolute';
                this.tooltip.style.display = 'none';
                this.tooltip.style.background = 'rgba(0, 0, 0, 0.6)';
                this.tooltip.style.color = '#fff';
                this.tooltip.style.padding = '6px 10px';
                this.tooltip.style.borderRadius = '4px';
                this.tooltip.style.pointerEvents = 'none';
                this.tooltip.style.zIndex = '1000';
                this.tooltip.style.fontSize = '0.8rem';
                this.tooltip.style.fontFamily = 'monospace';
                this.tooltip.style.border = '1px solid #444';
                this.tooltip.style.boxShadow = '0 4px 6px rgba(0,0,0,0.3)';
                document.body.appendChild(this.tooltip);
            }

            handleCanvasMouseMove(e) {
                if (!this.currentFrameData || !this.currentFrameData.thermalFrame) return;

                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                // Scale coordinates if canvas is resized via CSS
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;

                const canvasX = x * scaleX;
                const canvasY = y * scaleY;

                const pixelSize = this.heatmapRenderer.pixelSize;
                const flipX = this.heatmapRenderer.flipX;
                const flipY = this.heatmapRenderer.flipY;
                const rotate90 = this.heatmapRenderer.rotate90;
                const width = this.canvas.width;
                const height = this.canvas.height;

                // 1. Apply Screen Flips
                const vx = flipX ? (width - 1 - canvasX) : canvasX;
                const vy = flipY ? (height - 1 - canvasY) : canvasY;

                // 2. Map to Source Coords
                let tx, ty;
                if (rotate90) {
                    // 90 CW: Source X = Dest Y, Source Y = Dest Width - Dest X
                    tx = vy / pixelSize;
                    ty = (width - 1 - vx) / pixelSize;
                } else {
                    tx = vx / pixelSize;
                    ty = vy / pixelSize;
                }

                const gridX = Math.floor(tx);
                const gridY = Math.floor(ty);

                if (gridY >= 0 && gridX >= 0) {
                    const thermalFrame = this.currentFrameData.thermalFrame;
                    // Check bounds (Source dimensions)
                    if (gridY < thermalFrame.length && gridX < thermalFrame[0].length) {
                        const val = thermalFrame[gridY][gridX];
                        const scaleInfo = this.currentFrameData.scaleInfo;

                        const temp = this.thermalParser.digitToTemp(val, scaleInfo);

                        // Calculate normalized value for color (same logic as heatmap renderer)
                        let effectiveMinDigit = scaleInfo.minDigit;
                        let effectiveDigitRange = scaleInfo.maxDigit - scaleInfo.minDigit || 1;

                        if (this.heatmapRenderer.fixedScale) {
                            const tempRange = scaleInfo.maxTemp - scaleInfo.minTemp;
                            const digitRange = scaleInfo.maxDigit - scaleInfo.minDigit;

                            if (Math.abs(tempRange) > 0.01) {
                                const tempToDigit = (t) => {
                                    return scaleInfo.minDigit + (t - scaleInfo.minTemp) * digitRange / tempRange;
                                };

                                const dMin = tempToDigit(this.heatmapRenderer.fixedMin);
                                const dMax = tempToDigit(this.heatmapRenderer.fixedMax);

                                effectiveMinDigit = dMin;
                                effectiveDigitRange = dMax - dMin;
                                if (Math.abs(effectiveDigitRange) < 0.01) effectiveDigitRange = 1;
                            }
                        }

                        const normalized = (val - effectiveMinDigit) / effectiveDigitRange;
                        const tempColor = this.heatmapRenderer.getColor(normalized);

                        let tooltipText = `<span style="color: #e0e0e0">(${gridX}, ${gridY})</span> <span style="color: ${tempColor}; font-weight: bold; text-shadow: 0 0 2px rgba(0,0,0,0.8)">${temp.toFixed(1)}°C</span>`;

                        // Check if hovering over a blob
                        if (this.currentFrameData.blobs) {
                            for (const blob of this.currentFrameData.blobs) {
                                if (blob.mask) {
                                    // Check mask bit
                                    // Mask is hex string
                                    const hexRow = blob.mask.substring(gridY * 8, (gridY + 1) * 8);
                                    if (hexRow.length === 8) {
                                        const rowBits = parseInt(hexRow, 16);
                                        if ((rowBits >>> gridX) & 1) {
                                            // Hit! Add blob info
                                            tooltipText += `<br><span style="color: #667eea; font-size: 0.75rem">Area=${blob.area}</span>`;
                                            break;
                                        }
                                    }
                                }
                            }
                        }

                        this.tooltip.style.left = (e.pageX + 15) + 'px';
                        this.tooltip.style.top = (e.pageY + 15) + 'px';
                        this.tooltip.style.display = 'block';
                        this.tooltip.innerHTML = tooltipText;
                    } else {
                        this.hideTooltip();
                    }
                } else {
                    this.hideTooltip();
                }
            }

            hideTooltip() {
                this.tooltip.style.display = 'none';
            }

            /**
             * Update visual transforms (flip/rotate)
             */
            updateTransforms() {
                const flipH = document.getElementById('flipHorizontal').checked;
                const flipV = document.getElementById('flipVertical').checked;
                const rot90 = document.getElementById('rotate90').checked;

                this.heatmapRenderer.setTransforms(flipH, flipV, rot90);
                this.blobOverlay.setTransforms(flipH, flipV, rot90);

                // Redraw current frame if paused
                if (!this.capturing && this.currentFrameData) {
                     this.redrawCurrentFrame();
                }
            }

            /**
             * Redraw the current frame with updated settings
             */
            redrawCurrentFrame() {
                if (this.currentFrameData) {
                     this.heatmapRenderer.render(
                        this.currentFrameData.thermalFrame,
                        this.currentFrameData.scaleInfo,
                        this.currentFrameData.motionMask
                     );
                     // No longer using blue overlay - now dimming static pixels
                     // this.blobOverlay.renderMotionOverlay(this.currentFrameData.motionMask);
                     this.blobOverlay.renderForegroundOverlay(this.currentFrameData.foregroundMask);
                     this.blobOverlay.renderBlobs(
                        this.currentFrameData.foregroundMask,
                        this.currentFrameData.peopleCount,
                        this.currentFrameData.blobs
                     );
                }
            }

            /**
             * Initialize Chart.js time-series chart
             */
            initChart() {
                const ctx = document.getElementById('chartCanvas').getContext('2d');
                this.chart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'People Count',
                            data: [],
                            borderColor: '#4ade80',
                            backgroundColor: 'rgba(74, 222, 128, 0.1)',
                            borderWidth: 2,
                            tension: 0.4,
                            fill: true
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: { stepSize: 1, color: '#e0e0e0' },
                                grid: { color: '#444' }
                            },
                            x: {
                                ticks: { color: '#e0e0e0' },
                                grid: { color: '#444' }
                            }
                        },
                        plugins: {
                            legend: {
                                labels: { color: '#e0e0e0' }
                            }
                        }
                    }
                });
            }

            /**
             * Update chart with new data point
             */
            updateChart(frameNum, peopleCount) {
                this.frameHistory.push(frameNum);
                this.peopleHistory.push(peopleCount);

                // Keep only last N frames
                if (this.frameHistory.length > this.maxHistoryLength) {
                    this.frameHistory.shift();
                    this.peopleHistory.shift();
                }

                this.chart.data.labels = this.frameHistory;
                this.chart.data.datasets[0].data = this.peopleHistory;
                this.chart.update('none');  // Skip animation for performance
            }

            /**
             * Connect to device
             */
            async connect() {
                try {
                    this.log('Requesting serial port...');
                    await this.serialManager.requestPort();

                    this.log('Connecting at 921600 baud...');
                    await this.serialManager.connect(921600);

                    this.log('Testing basic communication...');
                    const commWorking = await this.serialManager.testCommunication(2000);
                    if (!commWorking) {
                        this.log('ERROR: Device not responding!');
                        this.log('Try these fixes:');
                        this.log('  1. Press RESET button on device');
                        this.log('  2. Disconnect USB cable, wait 3 seconds, reconnect');
                        this.log('  3. Close this page, re-flash firmware, reopen page');
                        throw new Error('Device not responding to commands');
                    }

                    this.log('Communication OK! Checking firmware version...');

                    // Query ISP library version
                    try {
                        const buildInfoResponse = await this.serialManager.sendCommand(':PeopleDetection:VERSION?', 2000);
                        this.log('ISP library build info:\n' + buildInfoResponse);

                        // Extract version from response (look for "Version X.Y.Z" pattern)
                        // Use flexible regex to match any version format (e.g. 0.3.2, 0.3, etc.)
                        const versionMatch = buildInfoResponse.match(/Version\s+([\d.]+)/);
                        if (versionMatch) {
                            const version = versionMatch[1];
                            document.getElementById('libraryVersion').textContent = 'v' + version;
                        }
                    } catch (error) {
                        this.log('Note: Could not get library version');
                        document.getElementById('libraryVersion').textContent = 'Unknown';
                    }

                    this.log('Initializing people detection...');

                    // Try DEINIT first in case previous session left it initialized
                    try {
                        this.log('Attempting DEINIT (cleanup from previous session)...');
                        await this.serialManager.sendCommand(':PeopleDetection:DEINIT', 3000);
                        this.log('Previous session cleaned up.');
                    } catch (error) {
                        this.log('DEINIT not needed (OK if not initialized)');
                        console.log('DEINIT error:', error.message);
                    }

                    // Ensure correct Algorithm Mode is set
                    if (this.algoMode !== undefined) {
                        this.log(`Setting Algorithm Mode: ${this.algoMode}`);
                        const modeResp = await this.serialManager.sendCommand(`:PeopleDetection:MODE ${this.algoMode}`, 2000);
                        if (modeResp.includes('ERROR')) {
                            this.log('⚠️ Failed to restore algorithm mode. Using default.');
                        }
                    }

                    // Send INIT command with retry logic (up to 3 attempts)
                    let initSuccess = false;
                    let maxRetries = 3;

                    for (let attempt = 1; attempt <= maxRetries; attempt++) {
                        // Full disconnect/reconnect before retry (except first attempt)
                        if (attempt > 1) {
                            this.log(`⚠️ Retry ${attempt}/${maxRetries}: Reconnecting serial port...`);

                            // Reconnect serial (close and reopen same port)
                            try {
                                await this.serialManager.reconnect();
                                this.log('Serial port reconnected.');
                            } catch (error) {
                                this.log('ERROR: Serial reconnect failed!');
                                throw error;
                            }

                            // Communication check
                            try {
                                await this.serialManager.sendCommand('*IDN?', 2000);
                                this.log('Communication check OK.');
                            } catch (error) {
                                this.log('ERROR: Device not responding after reconnect!');
                                throw error;
                            }
                        }

                        this.log(`Sending INIT command... (attempt ${attempt}/${maxRetries})`);
                        const initResponse = await this.serialManager.sendCommand(':PeopleDetection:INIT', 10000);
                        this.log('INIT response:\n' + initResponse);

                        // Get sensor configuration status
                        try {
                            const sensorResponse = await this.serialManager.sendCommand(':SENSOR:STATUS?', 2000);
                            this.log('Sensor status:\n' + sensorResponse);

                            // Parse the response to extract mode and frame rate
                            const lines = sensorResponse.split('\n');
                            let mode = 'Unknown';
                            let rate = 'Unknown';

                            for (const line of lines) {
                                if (line.includes('[INFO] MODE:')) {
                                    mode = line.split('MODE:')[1].trim();
                                } else if (line.includes('[INFO] RATE:')) {
                                    rate = line.split('RATE:')[1].trim();
                                }
                            }

                            // Update sensor status display
                            const statusElement = document.getElementById('sensorStatus');
                            if (mode !== 'Unknown' && rate !== 'Unknown') {
                                // Success - green status
                                statusElement.textContent = `${mode}, ${rate}`;
                                statusElement.style.color = '#00ff88';
                                initSuccess = true;
                                break; // Exit retry loop
                            } else {
                                // Yellow status - not configured, may need retry
                                statusElement.textContent = 'Not configured';
                                statusElement.style.color = '#ff8800';

                                if (attempt < maxRetries) {
                                    this.log(`⚠️ Sensor not configured, will retry with full disconnect/reconnect...`);
                                } else {
                                    this.log('❌ ERROR: Sensor failed to initialize after 3 attempts!');
                                    this.log('Device sensor may be faulty. Try power cycling the device.');
                                }
                            }
                        } catch (error) {
                            this.log('Note: Could not get sensor status (OK if firmware not updated)');
                            document.getElementById('sensorStatus').textContent = 'Unknown';
                            document.getElementById('sensorStatus').style.color = '#a0a0a0';
                            initSuccess = true; // Don't fail on status check error
                            break;
                        }
                    }

                    // If all retries failed, disconnect and inform user
                    if (!initSuccess) {
                        this.log('');
                        this.log('❌ Connection failed after 3 initialization attempts.');
                        this.log('');
                        this.log('The device responded but could not initialize the sensor.');
                        this.log('This may indicate corrupted firmware or a hardware issue.');
                        this.log('');
                        this.log('Recommended: Click "Update Firmware" to install the latest firmware.');
                        this.log('');

                        document.getElementById('sensorStatus').textContent = 'Init failed';
                        document.getElementById('sensorStatus').style.color = '#ef4444'; // Red

                        // Show update badge to draw attention to firmware update
                        const badge = document.getElementById('updateBadge');
                        if (badge) badge.style.display = 'flex';

                        // Fully disconnect - don't leave in confusing partial state
                        try {
                            await this.serialManager.disconnect();
                        } catch (e) {
                            console.log('Disconnect error (OK):', e);
                        }
                        this.updateConnectionState(false);

                        return; // Exit connect() - user is NOT connected
                    }

                    // Apply configuration based on mode
                    if (this.algoMode === 2) {
                        await this.applySimpleModeDefaults();
                    } else {
                        // Apply the currently selected preset immediately upon connection (Standard Mode)
                        await this.applyPreset();
                    }

                    // Sync runtime params to ensure UI matches device state
                    await this.syncRuntimeParamsFromDevice();

                    // Update UI
                    this.updateConnectionState(true);
                    this.log('Ready to capture. Click "Start Capture".');

                    // Auto-check for firmware updates (non-blocking)
                    setTimeout(() => this.autoCheckForUpdates(), 2000);
                } catch (error) {
                    this.log('ERROR: ' + error.message);
                    this.log('Check Console (F12) for detailed debug output');
                    console.error('Connection error:', error);
                }
            }

            /**
             * Disconnect from device
             */
            async disconnect() {
                try {
                    if (this.capturing) {
                        this.stopCapture();
                    }

                    this.log('Sending DEINIT...');
                    await this.serialManager.sendCommand(':PeopleDetection:DEINIT', 5000);

                    this.log('Disconnecting...');
                    await this.serialManager.disconnect();

                    this.updateConnectionState(false);

                    // Reset library version display
                    document.getElementById('libraryVersion').textContent = '--';

                    this.log('Disconnected.');
                } catch (error) {
                    this.log('ERROR: ' + error.message);
                    console.error(error);
                }
            }

            /**
             * Start continuous capture
             */
            async startCapture() {
                if (this.capturing) return;

                // First check system status to see if we're already initialized
                this.log('Checking People Detection status...');
                try {
                    const statusResponse = await this.serialManager.sendCommand(':PeopleDetection:STATUS?', 2000);
                    const isInitialized = statusResponse.includes('PD initialized: YES');

                    if (!isInitialized) {
                        this.log('People Detection not initialized. Initializing...');
                        const initResponse = await this.serialManager.sendCommand(':PeopleDetection:INIT', 10000);

                        // Check for memory errors first
                        if (initResponse.includes('(ENOMEM)>')) {
                            this.log('❌ ERROR: Out of memory! Failed to allocate buffers.');
                            this.log('');
                            this.log('📌 Solution: Reset the device to clear memory fragmentation:');
                            this.log('   1. Unplug the USB cable');
                            this.log('   2. Wait 3 seconds');
                            this.log('   3. Reconnect the USB cable');
                            this.log('   4. Reconnect in the web interface');
                            this.log('   5. Try "Start Capture" again');
                            this.log('');
                            this.log('If the problem persists after reset, try reducing max_blobs or other parameters.');
                            return;
                        }

                        if (initResponse.includes('[ERROR]') || initResponse.includes('(ERROR)>') ||
                            initResponse.includes('(E2BIG)>')) {
                            this.log('❌ ERROR: Initialization failed!');
                            this.log('Response: ' + initResponse);
                            return;
                        }

                        // MUST have (OK)> prompt to be successful
                        if (!initResponse.includes('(OK)>')) {
                            this.log('❌ ERROR: Initialization did not complete successfully');
                            this.log('Expected (OK)> prompt but got: ' + initResponse.slice(-20));
                            return;
                        }

                        // Check if already initialized (firmware will say so)
                        if (initResponse.includes('already initialized')) {
                            this.log('People Detection was already initialized');
                        } else {
                            this.log('✓ People Detection initialized successfully');

                            // Apply saved runtime parameters after initialization
                            const saved = localStorage.getItem('runtimeParams');
                            if (saved) {
                                this.log('Restoring saved runtime parameters...');
                                const params = JSON.parse(saved);

                                // Apply each saved parameter
                                if (params.footprint) await this.updateRuntimeParam(':PeopleDetection:TUNE:FOOTPRINT', params.footprint);
                                if (params.minArea) await this.updateRuntimeParam(':PeopleDetection:TUNE:MINAREA', params.minArea);
                                if (params.thresholdL) await this.updateRuntimeParam(':PeopleDetection:TUNE:THRESHOLD:LOWER', params.thresholdL);
                                if (params.thresholdH) await this.updateRuntimeParam(':PeopleDetection:TUNE:THRESHOLD:UPPER', params.thresholdH);
                                if (params.tempMin) await this.updateRuntimeParam(':PeopleDetection:TUNE:TEMP:MIN', params.tempMin);
                                if (params.tempMax) await this.updateRuntimeParam(':PeopleDetection:TUNE:TEMP:MAX', params.tempMax);
                                if (params.logGateL) await this.updateRuntimeParam(':PeopleDetection:TUNE:GATE:COLD', params.logGateL);
                                if (params.logGateH) await this.updateRuntimeParam(':PeopleDetection:TUNE:GATE:HOT', params.logGateH);
                                if (params.percentileL) await this.updateRuntimeParam(':PeopleDetection:TUNE:PERCENTILE:COLD', params.percentileL);
                                if (params.percentileH) await this.updateRuntimeParam(':PeopleDetection:TUNE:PERCENTILE:HOT', params.percentileH);
                                if (params.gammaEma) await this.updateRuntimeParam(':PeopleDetection:TUNE:LEARNING', params.gammaEma);

                                this.log('Runtime parameters restored');
                            }
                        }
                    } else {
                        this.log('People Detection already initialized');
                    }
                } catch (error) {
                    this.log('ERROR: Failed to initialize People Detection: ' + error.message);
                    this.log('Cannot start capture without initialization');
                    return;
                }

                this.capturing = true;
                this.frameCount = 0;
                this.updateCaptureState(true);
                this.log('Capture started at ' + this.frameRate + ' Hz');

                // Start capture loop
                this.captureInterval = setInterval(() => {
                    this.captureFrame();
                }, 1000 / this.frameRate);
            }

            /**
             * Stop continuous capture
             */
            stopCapture() {
                if (!this.capturing) return;

                this.capturing = false;
                if (this.captureInterval) {
                    clearInterval(this.captureInterval);
                    this.captureInterval = null;
                }
                this.updateCaptureState(false);
                this.log('Capture stopped. Total frames: ' + this.frameCount);
            }

            /**
             * Change algorithm mode (Full/Simplified/Simple)
             * @param {number} mode - 0=Full, 1=Simplified, 2=Simple
             */
            async changeAlgorithmMode(mode) {
                mode = parseInt(mode);
                this.algoMode = mode; // Store local state
                this.saveAppSettings(); // Persist

                // Update UI immediately (works offline)
                this.ui.applyAlgorithmModeUI(mode);

                if (!this.serialManager.isConnected()) {
                    this.log(`Algorithm mode set to ${mode} (Offline). Will apply on connect.`);
                    return;
                }

                const wasCapturing = this.capturing;
                if (wasCapturing) {
                    this.stopCapture();
                }

                this.log(`Changing algorithm mode to ${mode}...`);

                try {
                    // 1. Deinit
                    await this.serialManager.sendCommand(':PeopleDetection:DEINIT', 3000);

                    // 2. Set Mode
                    const modeResp = await this.serialManager.sendCommand(`:PeopleDetection:MODE ${mode}`, 2000);
                    if (modeResp.includes('ERROR')) {
                         throw new Error('Failed to set mode');
                    }

                    // 3. Init
                    const initResp = await this.serialManager.sendCommand(':PeopleDetection:INIT', 10000);
                    if (!initResp.includes('(OK)')) {
                         throw new Error('Failed to initialize');
                    }

                    this.log('Algorithm mode changed successfully');

                    // Sync params (to get new defaults)
                    await this.syncRuntimeParamsFromDevice();

                    // Restart capture if needed
                    if (wasCapturing) {
                        await this.startCapture();
                    }

                } catch (error) {
                    this.log(`ERROR changing mode: ${error.message}`);
                }
            }

            /**
             * Capture single frame
             */
            async captureFrame() {
                // Skip if previous frame still processing (prevent overlap at high frame rates)
                if (this.captureInProgress) {
                    console.warn('Frame capture still in progress, skipping...');
                    return;
                }

                this.captureInProgress = true;
                const frameStartTime = performance.now();

                try {
                    // Send CAPTURE 2 for JSON output (includes frame + blobs + mask + meta)
                    const response = await this.serialManager.sendCommand(':PeopleDetection:CAPTURE 2', 2000);

                    // Parse JSON response
                    const data = this.thermalParser.parseJSON(response);
                    this.currentFrameData = data; // Update current data for tooltip

                    // Debug: Check parsed data
                    console.debug('Parsed data:', {
                        thermalRows: data.thermalFrame.length,
                        foregroundRows: data.foregroundMask.length,
                        peopleCount: data.peopleCount,
                        blobCount: data.blobCount,
                        firstRow: data.thermalFrame[0]?.length,
                        firstForeground: data.foregroundMask[0]?.length,
                        sampleForeground: data.foregroundMask[15]?.slice(0, 10)
                    });

                    // Check smoothing checkbox and apply
                    const smoothingEnabled = document.getElementById('smoothHeatmap').checked;
                    this.heatmapRenderer.setSmoothing(smoothingEnabled);

                    // Check motion map checkbox and apply
                    const displayMotionMap = document.getElementById('displayMotionMap').checked;
                    this.heatmapRenderer.setDisplayMotionMap(displayMotionMap);

                    // Render heatmap
                    this.heatmapRenderer.render(
                        data.thermalFrame,
                        data.scaleInfo,
                        data.motionMask
                    );

                    // Render simple foreground overlay (uniform yellow)
                    this.blobOverlay.renderForegroundOverlay(data.foregroundMask);

                    // Render per-blob contours (each blob gets unique color)
                    this.blobOverlay.renderBlobs(data.foregroundMask, data.peopleCount, data.blobs);

                    // Update stats
                    this.updateStats(data);
                    this.frameCount++;
                    document.getElementById('frameCounter').textContent = this.frameCount;

                    // Update chart
                    this.updateChart(this.frameCount, data.peopleCount);

                    // Recording
                    if (this.recording) {
                        this.recordedFrames.push({
                            frameNum: this.frameCount,
                            timestamp: Date.now(),
                            data: data
                        });
                    }

                    // Calculate timing metrics
                    const frameEndTime = performance.now();
                    const frameDuration = frameEndTime - frameStartTime;
                    this.lastFrameDuration = frameDuration;

                    // Update rolling average
                    this.frameTimeSamples.push(frameDuration);
                    if (this.frameTimeSamples.length > this.maxFrameTimeSamples) {
                        this.frameTimeSamples.shift();
                    }
                    this.avgFrameDuration = this.frameTimeSamples.reduce((a, b) => a + b, 0) / this.frameTimeSamples.length;

                    // Update timing display
                    this.updateTimingStats();

                } catch (error) {
                    this.log('Frame capture error: ' + error.message);

                    // Check if it's an initialization error
                    if (error.message.includes('not initialized')) {
                        this.log('⚠️ People Detection not initialized!');
                        this.log('Stopping capture - please click "Start Capture" again');
                        this.stopCapture();
                        // Don't auto-reinitialize here as it causes loops with memory errors
                        return;
                    }

                    console.error(error);
                    // Don't stop capture on single frame error
                } finally {
                    // Always clear the in-progress flag
                    this.captureInProgress = false;
                }
            }

            /**
             * Update statistics display
             */
            updateStats(data) {
                document.getElementById('peopleCount').textContent = data.peopleCount;
                document.getElementById('blobCount').textContent = data.blobCount;
                document.getElementById('tempRange').textContent =
                    `${data.tempMin.toFixed(1)}-${data.tempMax.toFixed(1)}°C`;
                document.getElementById('processTime').textContent =
                    `${data.processingTime.toFixed(1)} ms`;
            }

            /**
             * Update timing statistics display
             */
            updateTimingStats() {
                // Frame time (total round-trip)
                document.getElementById('frameTime').textContent =
                    `${this.avgFrameDuration.toFixed(0)} ms`;

                // Actual FPS achieved
                const actualFps = this.avgFrameDuration > 0 ? 1000 / this.avgFrameDuration : 0;
                const requestedFps = this.frameRate;
                const fpsColor = actualFps < requestedFps * 0.8 ? 'orange' : 'inherit';  // Warn if <80% of target
                document.getElementById('actualFps').innerHTML =
                    `<span style="color: ${fpsColor}">${actualFps.toFixed(1)} Hz</span>`;

                // Log warning if frame time exceeds interval
                const targetInterval = 1000 / this.frameRate;
                if (this.lastFrameDuration > targetInterval * 1.1) {
                    console.warn(`Frame time (${this.lastFrameDuration.toFixed(0)}ms) exceeds interval (${targetInterval.toFixed(0)}ms) - frames may be skipped`);
                }
            }

            /**
             * Apply sensor configuration (mode and framerate)
             */
            async applySensorConfig() {
                try {
                    const mode = document.getElementById('sensorMode').value;
                    const fps = document.getElementById('sensorFps').value;
                    const fpsText = document.getElementById('sensorFps').options[document.getElementById('sensorFps').selectedIndex].text;

                    this.log('Applying sensor configuration...');
                    this.log(`  Mode: ${mode}`);
                    this.log(`  Frame Rate: ${fpsText} (fps=${fps})`);

                    // Send :SENSOR:CONFIG command
                    const configCmd = `:SENSOR:CONFIG ${mode} ${fps}`;
                    this.log(`Sending: ${configCmd}`);

                    const response = await this.serialManager.sendCommand(configCmd, 5000);
                    this.log('Sensor config response:\n' + response);

                    // Query sensor status to confirm configuration
                    try {
                        const statusResponse = await this.serialManager.sendCommand(':SENSOR:STATUS?', 2000);
                        this.log('Updated sensor status:\n' + statusResponse);

                        // Parse the response to extract mode and frame rate
                        const lines = statusResponse.split('\n');
                        let actualMode = 'Unknown';
                        let actualRate = 'Unknown';

                        for (const line of lines) {
                            if (line.includes('[INFO] MODE:')) {
                                actualMode = line.split('MODE:')[1].trim();
                            } else if (line.includes('[INFO] RATE:')) {
                                actualRate = line.split('RATE:')[1].trim();
                            }
                        }

                        // Update status display with actual values from sensor
                        const statusElement = document.getElementById('sensorStatus');
                        if (actualMode !== 'Unknown' && actualRate !== 'Unknown') {
                            statusElement.textContent = `${actualMode}, ${actualRate}`;
                            statusElement.style.color = '#4ade80';
                        } else {
                            statusElement.textContent = `${mode}, ${fpsText}`;
                            statusElement.style.color = '#4ade80';
                        }
                    } catch (error) {
                        // Fallback to showing what was requested
                        document.getElementById('sensorStatus').textContent = `${mode}, ${fpsText}`;
                        document.getElementById('sensorStatus').style.color = '#4ade80';
                    }

                    this.log('Sensor configuration applied successfully!');
                    this.log('Note: EEPROM settings persist across power cycles.');

                    // Auto-sync polling rate to match sensor FPS
                    const fpsMap = { '2': 2, '3': 4, '4': 8, '5': 16 };
                    const targetHz = fpsMap[fps] || 8;
                    this.updateFrameRate(targetHz);
                    document.getElementById('frameRateSlider').value = targetHz;
                    this.saveAppSettings();
                } catch (error) {
                    this.log('ERROR applying sensor config: ' + error.message);
                    document.getElementById('sensorStatus').textContent = 'Config failed';
                    document.getElementById('sensorStatus').style.color = '#ef4444';
                    console.error(error);
                }
            }

            /**
             * Apply preset configuration
             */
            async applyPreset() {
                // Skip if in Simple Mode (presets don't apply)
                if (this.algoMode === 2) {
                    this.log('Skipping preset application (Simple Mode active)');
                    return;
                }

                // Preset controls are disabled during capture, so this only runs when stopped
                try {
                    const preset = document.getElementById('presetSelect').value;
                    const [angle, height, sensitivity] = preset.split('|');
                    const coldDetection = document.getElementById('coldDetection').checked;

                    this.log('Applying preset configuration...');
                    this.log(`  Angle: ${angle}, Height: ${height}, Sensitivity: ${sensitivity}, Cold: ${coldDetection}`);

                    // Helper function to check for errors in response
                    const checkResponse = (response, commandName) => {
                        // WORKAROUND: Firmware has a bug where preset commands return E2BIG
                        // even when successful (they don't consume the argument from the buffer).
                        // Check for success messages instead of just error codes.
                        const successPatterns = {
                            'ANGLE': /Mount angle set to (VERTICAL|OBLIQUE)/,
                            'HEIGHT': /Mount height set to (SHORT|TALL)/,
                            'SENSITIVITY': /Sensitivity set to (LOW|HIGH)/,
                            'COLD': /Cold detection (ENABLED|DISABLED)/
                        };

                        // If we have a success pattern for this command, check for it
                        if (successPatterns[commandName]) {
                            if (successPatterns[commandName].test(response)) {
                                // Success message found, command worked despite E2BIG
                                return;
                            }
                        }

                        // Check for actual errors
                        if (response.includes('(ERROR)>')) {
                            throw new Error(`${commandName} failed: ERROR`);
                        }
                        if (response.includes('(ENOMEM)>')) {
                            throw new Error(`${commandName} failed: ENOMEM (out of memory)`);
                        }
                        // Only fail on E2BIG if we didn't see a success message
                        if (response.includes('(E2BIG)>') && !successPatterns[commandName]) {
                            throw new Error(`${commandName} failed: E2BIG (argument too large)`);
                        }
                        // For commands without success patterns, require (OK)>
                        if (!successPatterns[commandName] && !response.includes('(OK)>')) {
                            throw new Error(`${commandName} failed: unexpected response`);
                        }
                    };

                    // Send preset parameter commands with error checking and delays
                    const angleResponse = await this.serialManager.sendCommand(`:PeopleDetection:PRESET:ANGLE ${angle}`, 2000);
                    checkResponse(angleResponse, 'ANGLE');
                    await new Promise(resolve => setTimeout(resolve, 100));

                    const heightResponse = await this.serialManager.sendCommand(`:PeopleDetection:PRESET:HEIGHT ${height}`, 2000);
                    checkResponse(heightResponse, 'HEIGHT');
                    await new Promise(resolve => setTimeout(resolve, 100));

                    const sensitivityResponse = await this.serialManager.sendCommand(`:PeopleDetection:PRESET:SENSITIVITY ${sensitivity}`, 2000);
                    checkResponse(sensitivityResponse, 'SENSITIVITY');
                    await new Promise(resolve => setTimeout(resolve, 100));

                    const coldResponse = await this.serialManager.sendCommand(`:PeopleDetection:PRESET:COLD ${coldDetection ? 'ON' : 'OFF'}`, 2000);
                    checkResponse(coldResponse, 'COLD');
                    await new Promise(resolve => setTimeout(resolve, 100));

                    // Apply preset - this will use runtime update if initialized
                    const applyResponse = await this.serialManager.sendCommand(':PeopleDetection:PRESET:APPLY', 2000);
                    this.log('APPLY response:\n' + applyResponse);

                    // Check if runtime update was applied (no DEINIT/INIT needed)
                    if (applyResponse.includes('Runtime configuration updated')) {
                        this.log('Preset applied via runtime update!');

                        // Update UI sliders to match preset values
                        await this.syncRuntimeParamsFromDevice();
                    } else {
                        // Not initialized or runtime update not available
                        // Check if we need to initialize
                        if (applyResponse.includes('Call :PeopleDetection:INIT')) {
                            this.log('Initializing with new preset...');
                            const initResponse = await this.serialManager.sendCommand(':PeopleDetection:INIT', 5000);
                            this.log('INIT response:\n' + initResponse);

                            // Sync UI after initialization
                            await this.syncRuntimeParamsFromDevice();
                        }
                    }

                    this.log('Preset applied successfully!');
                } catch (error) {
                    this.log('ERROR applying preset: ' + error.message);
                    console.error(error);
                }
            }

            /**
             * Sync runtime parameter sliders with current device configuration
             */
            async syncRuntimeParamsFromDevice() {
                try {
                    // Query current config from device
                    const response = await this.serialManager.sendCommand(':PeopleDetection:DEBUG:CONFIG?', 2000);

                    // Parse response to extract current values
                    const lines = response.split('\n');
                    for (const line of lines) {
                        // Algorithm Mode
                        if (line.includes('algo_mode:')) {
                            const match = line.match(/(\d+)\s+\(/);
                            if (match) {
                                const mode = parseInt(match[1]);
                                this.ui.applyAlgorithmModeUI(mode);
                            }
                        }
                        // Footprint
                        else if (line.includes('area_std_footprint:')) {
                            const match = line.match(/(\d+)\s+pixels/);
                            if (match) {
                                const value = parseInt(match[1]);
                                document.getElementById('footprintSlider').value = value;
                                document.getElementById('footprintValue').textContent = value;
                            }
                        }
                        // Min blob area
                        else if (line.includes('min_blob_area:')) {
                            const match = line.match(/(\d+)\s+pixels/);
                            if (match) {
                                const value = parseInt(match[1]);
                                document.getElementById('minAreaSlider').value = value;
                                document.getElementById('minAreaValue').textContent = value;
                            }
                        }
                        // Lower threshold (fact_std_raw_l in Q8.8)
                        else if (line.includes('fact_std_raw_l:')) {
                            const match = line.match(/(\d+)\s+\(([\d.]+)x\)/);
                            if (match) {
                                const value = parseInt(match[1]);
                                document.getElementById('thresholdLSlider').value = value;
                                document.getElementById('thresholdLValue').textContent = match[2];
                            }
                        }
                        // Upper threshold (fact_std_raw_h in Q8.8)
                        else if (line.includes('fact_std_raw_h:')) {
                            const match = line.match(/(\d+)\s+\(([\d.]+)x\)/);
                            if (match) {
                                const value = parseInt(match[1]);
                                document.getElementById('thresholdHSlider').value = value;
                                document.getElementById('thresholdHValue').textContent = match[2];
                                // Also sync Simple Mode Hysteresis
                                if (document.getElementById('simpleHysteresisSlider')) {
                                    document.getElementById('simpleHysteresisSlider').value = value;
                                    document.getElementById('simpleHysteresisValue').textContent = match[2];
                                }
                            }
                        }
                        // Temperature min (Celsius × 50 format)
                        else if (line.includes('temp_range_min:')) {
                            const match = line.match(/(-?\d+)\s+\(([\d.]+)°C\)/);
                            if (match) {
                                const value = parseInt(match[1]);
                                document.getElementById('tempMinSlider').value = value;
                                document.getElementById('tempMinValue').textContent = match[2];
                            }
                        }
                        // Temperature max (Celsius × 50 format)
                        else if (line.includes('temp_range_max:')) {
                            const match = line.match(/(-?\d+)\s+\(([\d.]+)°C\)/);
                            if (match) {
                                const value = parseInt(match[1]);
                                document.getElementById('tempMaxSlider').value = value;
                                document.getElementById('tempMaxValue').textContent = match[2];
                            }
                        }
                        // Cold LoG gate (lim_area_frg_l)
                        else if (line.includes('lim_area_frg_l:')) {
                            const match = line.match(/(\d+)\s+pixels/);
                            if (match) {
                                const value = parseInt(match[1]);
                                document.getElementById('logGateLSlider').value = value;
                                document.getElementById('logGateLValue').textContent = value;
                            }
                        }
                        // Hot LoG gate (lim_area_frg_h)
                        else if (line.includes('lim_area_frg_h:')) {
                            const match = line.match(/(\d+)\s+pixels/);
                            if (match) {
                                const value = parseInt(match[1]);
                                document.getElementById('logGateHSlider').value = value;
                                document.getElementById('logGateHValue').textContent = value;
                            }
                        }
                        // Cold percentile (percentile_l in Q8.8)
                        else if (line.includes('percentile_l:')) {
                            const match = line.match(/(\d+)\s+\(([\d.]+),\s+cold\)/);
                            if (match) {
                                const value = parseInt(match[1]);
                                document.getElementById('percentileLSlider').value = value;
                                document.getElementById('percentileLValue').textContent = match[2];
                            }
                        }
                        // Hot percentile (percentile_h in Q8.8)
                        else if (line.includes('percentile_h:')) {
                            const match = line.match(/(\d+)\s+\(([\d.]+),\s+hot\)/);
                            if (match) {
                                const value = parseInt(match[1]);
                                document.getElementById('percentileHSlider').value = value;
                                document.getElementById('percentileHValue').textContent = match[2];
                            }
                        }
                        // Gamma EMA (BG Learning) - Handle extra text in parens
                        else if (line.includes('gamma_ema:')) {
                            // Match "26 (0.10x" part, ignoring trailing ", bg learning rate)"
                            const match = line.match(/(\d+)\s+\(([\d.]+)x/);
                            if (match) {
                                const value = parseInt(match[1]);
                                document.getElementById('gammaEmaSlider').value = value;
                                document.getElementById('gammaEmaValue').textContent = match[2];
                                // Also sync Simple Mode BG Learning
                                if (document.getElementById('simpleGammaEmaSlider')) {
                                    document.getElementById('simpleGammaEmaSlider').value = value;
                                    document.getElementById('simpleGammaEmaValue').textContent = match[2];
                                }
                            }
                        }
                        // Hot Threshold (Simple mode)
                        else if (line.includes('th_hot:')) {
                            const match = line.match(/(-?\d+)\s+\(([\d.]+)\s*(?:degC|°C)\)/);
                            if (match) {
                                const value = parseInt(match[1]);
                                document.getElementById('thHotSlider').value = value;
                                document.getElementById('thHotValue').textContent = match[2];
                            }
                        }
                        // Cold Threshold (Simple mode)
                        else if (line.includes('th_cold:')) {
                            const match = line.match(/(-?\d+)\s+\(([\d.]+)\s*(?:degC|°C)\)/);
                            if (match) {
                                const value = parseInt(match[1]);
                                document.getElementById('thColdSlider').value = value;
                                document.getElementById('thColdValue').textContent = match[2];
                            }
                        }
                        // Motion Threshold
                        else if (line.includes('motion_thresh:')) {
                            const match = line.match(/(-?\d+)\s+\(([\d.]+)\s*(?:degC|°C)\)/);
                            if (match) {
                                const value = parseInt(match[1]);
                                document.getElementById('motionThreshSlider').value = value;
                                document.getElementById('motionThreshValue').textContent = match[2];
                            }
                        }
                        // Motion Persistence
                        else if (line.includes('motion_hysteresis:')) {
                            const match = line.match(/(\d+)\s+frames/);
                            if (match) {
                                const frames = parseInt(match[1]);
                                const seconds = (frames / this.frameRate).toFixed(1);
                                // Update slider with seconds, but ensure it respects min/max
                                document.getElementById('motionHystSlider').value = seconds;
                                document.getElementById('motionHystValue').textContent = seconds;
                            }
                        }
                        // Track Age
                        else if (line.includes('track_age:')) {
                            const match = line.match(/(\d+)\s+frames/);
                            if (match) {
                                const frames = parseInt(match[1]);
                                const seconds = (frames / this.frameRate).toFixed(1);
                                document.getElementById('trackAgeSlider').value = seconds;
                                document.getElementById('trackAgeValue').textContent = seconds;
                            }
                        }
                        // Track Missed
                        else if (line.includes('track_missed:')) {
                            const match = line.match(/(\d+)\s+frames/);
                            if (match) {
                                const frames = parseInt(match[1]);
                                const seconds = (frames / this.frameRate).toFixed(1);
                                document.getElementById('trackMissedSlider').value = seconds;
                                document.getElementById('trackMissedValue').textContent = seconds;
                            }
                        }
                        // Motion Density
                        else if (line.includes('motion_density:')) {
                            const match = line.match(/(\d+)\s+\((\d+)%\)/);
                            if (match) {
                                const rawValue = parseInt(match[1]);
                                const pct = parseInt(match[2]);
                                document.getElementById('motionDensitySlider').value = pct;
                                document.getElementById('motionDensityValue').textContent = pct;
                                // Sync motion validation checkbox (checked = enabled = density > 0)
                                const checkbox = document.getElementById('motionValidationCheckbox');
                                if (checkbox) {
                                    checkbox.checked = (rawValue > 0);
                                    document.getElementById('motionDensitySlider').disabled = (rawValue === 0);
                                }
                            }
                        }
                    }

                    // Save updated params to localStorage
                    this.saveRuntimeParams();
                } catch (error) {
                    console.error('Failed to sync runtime params:', error);
                }
            }

            /**
             * Initialize runtime parameter sliders with event handlers
             */
            initRuntimeParams() {
                // Load saved parameters from localStorage
                this.loadRuntimeParams();

                // Add event handlers to all sliders
                const sliders = [
                    {
                        id: 'footprintSlider',
                        labelId: 'footprintValue',
                        cmd: ':PeopleDetection:TUNE:FOOTPRINT',
                        format: (v) => v
                    },
                    {
                        id: 'minAreaSlider',
                        labelId: 'minAreaValue',
                        cmd: ':PeopleDetection:TUNE:MINAREA',
                        format: (v) => v
                    },
                    {
                        id: 'thresholdLSlider',
                        labelId: 'thresholdLValue',
                        cmd: ':PeopleDetection:TUNE:THRESHOLD:LOWER',
                        format: (v) => (v / 256).toFixed(2)
                    },
                    {
                        id: 'thresholdHSlider',
                        labelId: 'thresholdHValue',
                        cmd: ':PeopleDetection:TUNE:THRESHOLD:UPPER',
                        format: (v) => (v / 256).toFixed(2)
                    },
                    {
                        id: 'tempMinSlider',
                        labelId: 'tempMinValue',
                        cmd: ':PeopleDetection:TUNE:TEMP:MIN',
                        format: (v) => v == 0 ? 'Auto' : (v / 50).toFixed(1)
                    },
                    {
                        id: 'tempMaxSlider',
                        labelId: 'tempMaxValue',
                        cmd: ':PeopleDetection:TUNE:TEMP:MAX',
                        format: (v) => v == 0 ? 'Auto' : (v / 50).toFixed(1)
                    },
                    {
                        id: 'logGateLSlider',
                        labelId: 'logGateLValue',
                        cmd: ':PeopleDetection:TUNE:GATE:COLD',
                        format: (v) => v
                    },
                    {
                        id: 'logGateHSlider',
                        labelId: 'logGateHValue',
                        cmd: ':PeopleDetection:TUNE:GATE:HOT',
                        format: (v) => v
                    },
                    {
                        id: 'percentileLSlider',
                        labelId: 'percentileLValue',
                        cmd: ':PeopleDetection:TUNE:PERCENTILE:COLD',
                        format: (v) => (v / 256).toFixed(2)
                    },
                    {
                        id: 'percentileHSlider',
                        labelId: 'percentileHValue',
                        cmd: ':PeopleDetection:TUNE:PERCENTILE:HOT',
                        format: (v) => (v / 256).toFixed(2)
                    },
                    {
                        id: 'gammaEmaSlider',
                        labelId: 'gammaEmaValue',
                        cmd: ':PeopleDetection:TUNE:LEARNING',
                        format: (v) => (v / 256).toFixed(2)
                    },
                    {
                        id: 'thHotSlider',
                        labelId: 'thHotValue',
                        cmd: ':PeopleDetection:TUNE:TH:HOT',
                        format: (v) => (v / 50).toFixed(1)
                    },
                    {
                        id: 'thColdSlider',
                        labelId: 'thColdValue',
                        cmd: ':PeopleDetection:TUNE:TH:COLD',
                        format: (v) => (v / 50).toFixed(1)
                    },
                    {
                        id: 'simpleHysteresisSlider',
                        labelId: 'simpleHysteresisValue',
                        cmd: ':PeopleDetection:TUNE:THRESHOLD:UPPER',
                        format: (v) => (v / 256).toFixed(2)
                    },
                    {
                        id: 'simpleGammaEmaSlider',
                        labelId: 'simpleGammaEmaValue',
                        cmd: ':PeopleDetection:TUNE:LEARNING',
                        format: (v) => (v / 256).toFixed(2)
                    },
                    {
                        id: 'motionThreshSlider',
                        labelId: 'motionThreshValue',
                        cmd: ':PeopleDetection:TUNE:MOTION:THRESH',
                        format: (v) => (v / 50).toFixed(1)
                    },
                    {
                        id: 'motionHystSlider',
                        labelId: 'motionHystValue',
                        cmd: ':PeopleDetection:TUNE:MOTION:HYST',
                        format: (v) => v,
                        isTime: true
                    },
                    {
                        id: 'motionDensitySlider',
                        labelId: 'motionDensityValue',
                        cmd: ':PeopleDetection:TUNE:MOTION:DENSITY',
                        format: (v) => v,
                        convert: (v) => Math.round(v * 255 / 100)  // Convert % to 0-255
                    },
                    {
                        id: 'trackAgeSlider',
                        labelId: 'trackAgeValue',
                        cmd: ':PeopleDetection:TUNE:TRACK:AGE',
                        format: (v) => v,
                        isTime: true
                    },
                    {
                        id: 'trackMissedSlider',
                        labelId: 'trackMissedValue',
                        cmd: ':PeopleDetection:TUNE:TRACK:MISSED',
                        format: (v) => v,
                        isTime: true
                    }
                ];

                sliders.forEach(slider => {
                    const element = document.getElementById(slider.id);
                    const label = document.getElementById(slider.labelId);

                    if (element) {
                        // Update label immediately while dragging
                        if (label) {
                            element.addEventListener('input', (e) => {
                                label.textContent = slider.format(e.target.value);
                            });

                            // Initial update to ensure sync
                            label.textContent = slider.format(element.value);
                        }

                        // Send command on release (change event)
                        element.addEventListener('change', async (e) => {
                            if (this.serialManager.isConnected()) {
                                let val = e.target.value;
                                if (slider.isTime) {
                                    val = Math.round(parseFloat(val) * this.frameRate);
                                    // Ensure at least 1 frame for safety
                                    if (val < 1) val = 1;
                                } else if (slider.convert) {
                                    val = slider.convert(parseFloat(val));
                                }
                                await this.updateRuntimeParam(slider.cmd, val);
                                this.saveRuntimeParams();

                                // Sync checkbox when density slider changes (checked = enabled = density > 0)
                                if (slider.id === 'motionDensitySlider') {
                                    const checkbox = document.getElementById('motionValidationCheckbox');
                                    if (checkbox) {
                                        checkbox.checked = (parseInt(e.target.value) > 0);
                                    }
                                }
                            }
                        });
                    }
                });

                // Motion validation checkbox (checked = enabled = density 20%, unchecked = disabled = density 0)
                const motionValidationCheckbox = document.getElementById('motionValidationCheckbox');
                if (motionValidationCheckbox) {
                    motionValidationCheckbox.addEventListener('change', async (e) => {
                        if (this.serialManager.isConnected()) {
                            const value = e.target.checked ? 51 : 0;  // 51=20% (enabled), 0=disabled
                            await this.updateRuntimeParam(':PeopleDetection:TUNE:MOTION:DENSITY', value);

                            // Update the density slider to match
                            const densitySlider = document.getElementById('motionDensitySlider');
                            const densityLabel = document.getElementById('motionDensityValue');
                            if (densitySlider) {
                                densitySlider.value = e.target.checked ? 20 : 0;
                                densitySlider.disabled = !e.target.checked;
                            }
                            if (densityLabel) {
                                densityLabel.textContent = e.target.checked ? '20' : '0';
                            }
                            this.saveRuntimeParams();
                        }
                    });
                }
            }

            /**
             * Apply parameters for Simple Mode - uses saved params if available, otherwise defaults
             */
            async applySimpleModeDefaults() {
                // Check for saved runtime params
                const saved = localStorage.getItem('runtimeParams');
                let params = null;
                if (saved) {
                    try {
                        params = JSON.parse(saved);
                        this.log('Restoring saved Simple Mode parameters...');
                    } catch (e) { params = null; }
                }

                if (!params) {
                    this.log('Applying Simple Mode defaults (first run)...');
                }

                try {
                    // Thresholds (slider values sent directly - already in correct units)
                    const thHot = params?.thHot ?? 90;  // 1.8°C default (degC×50)
                    const thCold = params?.thCold ?? 0; // Disabled default
                    const hysteresis = params?.thresholdH ?? 512; // 2.0x default (Q8.8)
                    const gammaEma = params?.gammaEma ?? 26; // 0.10x default (Q8.8)

                    await this.updateRuntimeParam(':PeopleDetection:TUNE:TH:HOT', thHot);
                    await this.updateRuntimeParam(':PeopleDetection:TUNE:TH:COLD', thCold);
                    await this.updateRuntimeParam(':PeopleDetection:TUNE:THRESHOLD:UPPER', hysteresis);
                    await this.updateRuntimeParam(':PeopleDetection:TUNE:LEARNING', gammaEma);

                    // Motion (disabled by default on first run)
                    // motionThresh is stored as slider value (0-500, maps to 0-10°C in steps of 0.1°C)
                    const motionThresh = params?.motionThresh ?? 50; // 1.0°C default (50 = 1.0°C)
                    const motionHyst = params?.motionHyst ?? 60; // 60s default
                    // motionDensity is stored as percentage (0-100), convert to raw (0-255)
                    const motionDensityPct = params?.motionDensity ?? 0; // 0% = disabled by default
                    const motionDensityRaw = Math.round((motionDensityPct * 255) / 100);

                    await this.updateRuntimeParam(':PeopleDetection:TUNE:MOTION:THRESH', motionThresh);
                    await this.updateRuntimeParam(':PeopleDetection:TUNE:MOTION:HYST', motionHyst * 8); // Convert seconds to frames
                    await this.updateRuntimeParam(':PeopleDetection:TUNE:MOTION:DENSITY', motionDensityRaw);

                    // Tracking
                    const trackAge = params?.trackAge ?? 1.0; // 1.0s default
                    const trackMissed = params?.trackMissed ?? 2.0; // 2.0s default

                    await this.updateRuntimeParam(':PeopleDetection:TUNE:TRACK:AGE', Math.round(trackAge * 8));
                    await this.updateRuntimeParam(':PeopleDetection:TUNE:TRACK:MISSED', Math.round(trackMissed * 8));

                    // Blob filtering
                    const minArea = params?.minArea ?? 15; // 15 pixels default

                    await this.updateRuntimeParam(':PeopleDetection:TUNE:MINAREA', minArea);

                    await new Promise(resolve => setTimeout(resolve, 200));
                    await this.syncRuntimeParamsFromDevice();
                    this.log(params ? 'Saved parameters restored.' : 'Defaults applied.');
                } catch (error) {
                    this.log('ERROR applying parameters: ' + error.message);
                }
            }

            /**
             * Update a runtime parameter
             */
            async updateRuntimeParam(command, value) {
                try {
                    const cmd = `${command} ${value}`;
                    this.log(`Updating runtime parameter: ${cmd}`);
                    const response = await this.serialManager.sendCommand(cmd, 2000);

                    // Check if response indicates success
                    if (response.includes('[INFO]')) {
                        this.log('Runtime parameter updated successfully');
                    } else if (response.includes('[ERROR]')) {
                        this.log('ERROR updating parameter: ' + response);
                    }
                } catch (error) {
                    this.log('ERROR updating runtime parameter: ' + error.message);
                }
            }

            /**
             * Reset runtime parameters to defaults (Apply selected preset)
             */
            async resetRuntimeParams() {
                if (!this.serialManager.isConnected()) {
                    this.log('⚠️ Cannot reset parameters: Not connected to device');
                    return;
                }

                this.log('Resetting parameters to defaults...');

                try {
                    // Check if in Simple Mode
                    if (this.algoMode === 2) {
                         await this.applySimpleModeDefaults();
                    } else {
                        // Standard Mode: Apply the currently selected preset
                        await this.applyPreset();
                    }

                    // Clear saved parameters since we reverted to defaults/preset
                    localStorage.removeItem('runtimeParams');

                    // Sync UI with new values
                    await this.syncRuntimeParamsFromDevice();

                } catch (error) {
                    this.log('ERROR resetting parameters: ' + error.message);
                }
            }

            /**
             * Update fixed scale settings in renderer
             */
            updateFixedScale() {
                const fixedScale = document.getElementById('fixedScale').checked;
                const fixedMin = document.getElementById('fixedMinTemp').value;
                const fixedMax = document.getElementById('fixedMaxTemp').value;

                if (this.heatmapRenderer) {
                    this.heatmapRenderer.setFixedScale(fixedScale, fixedMin, fixedMax);
                }
            }

            /**
             * Save application settings to localStorage
             */
            saveAppSettings() {
                const settings = {
                    frameRate: this.frameRate,
                    preset: document.getElementById('presetSelect').value,
                    coldDetection: document.getElementById('coldDetection').checked,
                    algoMode: document.getElementById('algoModeSelect').value,
                    smoothHeatmap: document.getElementById('smoothHeatmap').checked,
                    displayMotionMap: document.getElementById('displayMotionMap').checked,

                    // Fixed Scale
                    fixedScale: document.getElementById('fixedScale').checked,
                    fixedMinTemp: document.getElementById('fixedMinTemp').value,
                    fixedMaxTemp: document.getElementById('fixedMaxTemp').value,

                    flipHorizontal: document.getElementById('flipHorizontal').checked,
                    flipVertical: document.getElementById('flipVertical').checked,
                    rotate90: document.getElementById('rotate90').checked,
                    sensorMode: document.getElementById('sensorMode').value,
                    sensorFps: document.getElementById('sensorFps').value
                };
                localStorage.setItem('appSettings', JSON.stringify(settings));
            }

            /**
             * Load application settings from localStorage
             */
            loadAppSettings() {
                const saved = localStorage.getItem('appSettings');
                if (saved) {
                    try {
                        const settings = JSON.parse(saved);

                        if (settings.frameRate) {
                            this.updateFrameRate(settings.frameRate);
                            document.getElementById('frameRateSlider').value = settings.frameRate;
                        }
                        if (settings.preset) document.getElementById('presetSelect').value = settings.preset;
                        if (settings.coldDetection !== undefined) document.getElementById('coldDetection').checked = settings.coldDetection;

                        // Algo mode requires UI update
                        if (settings.algoMode) {
                            this.algoMode = parseInt(settings.algoMode);
                            document.getElementById('algoModeSelect').value = settings.algoMode;
                            this.ui.applyAlgorithmModeUI(settings.algoMode);
                        }

                        if (settings.smoothHeatmap !== undefined) {
                            document.getElementById('smoothHeatmap').checked = settings.smoothHeatmap;
                            this.heatmapRenderer.setSmoothing(settings.smoothHeatmap);
                        }

                        if (settings.displayMotionMap !== undefined) {
                            document.getElementById('displayMotionMap').checked = settings.displayMotionMap;
                            this.heatmapRenderer.setDisplayMotionMap(settings.displayMotionMap);
                        }

                        // Fixed Scale
                        if (settings.fixedScale !== undefined) {
                            document.getElementById('fixedScale').checked = settings.fixedScale;
                            document.getElementById('fixedScaleControls').style.display = settings.fixedScale ? 'block' : 'none';
                        }
                        if (settings.fixedMinTemp !== undefined) document.getElementById('fixedMinTemp').value = settings.fixedMinTemp;
                        if (settings.fixedMaxTemp !== undefined) document.getElementById('fixedMaxTemp').value = settings.fixedMaxTemp;
                        this.updateFixedScale();

                        if (settings.flipHorizontal !== undefined) document.getElementById('flipHorizontal').checked = settings.flipHorizontal;
                        if (settings.flipVertical !== undefined) document.getElementById('flipVertical').checked = settings.flipVertical;
                        if (settings.rotate90 !== undefined) document.getElementById('rotate90').checked = settings.rotate90;

                        if (settings.sensorMode) document.getElementById('sensorMode').value = settings.sensorMode;
                        if (settings.sensorFps) document.getElementById('sensorFps').value = settings.sensorFps;

                        this.updateTransforms();

                        this.log('Loaded app settings from localStorage');
                    } catch (error) {
                        console.error('Failed to load app settings:', error);
                    }
                }
            }

            /**
             * Save runtime parameters to localStorage
             */
            saveRuntimeParams() {
                // Determine which sliders to read based on active mode
                const isSimple = (this.algoMode === 2);

                const params = {
                    footprint: document.getElementById('footprintSlider').value,
                    minArea: document.getElementById('minAreaSlider').value,
                    thresholdL: document.getElementById('thresholdLSlider').value,
                    // Use Simple Mode slider if active, otherwise Standard Mode slider
                    thresholdH: isSimple ?
                        document.getElementById('simpleHysteresisSlider').value :
                        document.getElementById('thresholdHSlider').value,
                    tempMin: document.getElementById('tempMinSlider').value,
                    tempMax: document.getElementById('tempMaxSlider').value,
                    logGateL: document.getElementById('logGateLSlider').value,
                    logGateH: document.getElementById('logGateHSlider').value,
                    percentileL: document.getElementById('percentileLSlider').value,
                    percentileH: document.getElementById('percentileHSlider').value,
                    // Use Simple Mode slider if active
                    gammaEma: isSimple ?
                        document.getElementById('simpleGammaEmaSlider').value :
                        document.getElementById('gammaEmaSlider').value,
                    thHot: document.getElementById('thHotSlider').value,
                    thCold: document.getElementById('thColdSlider').value,
                    trackAge: document.getElementById('trackAgeSlider').value,
                    trackMissed: document.getElementById('trackMissedSlider').value,
                    motionThresh: document.getElementById('motionThreshSlider').value,
                    motionHyst: document.getElementById('motionHystSlider').value,
                    motionDensity: document.getElementById('motionDensitySlider').value
                };
                localStorage.setItem('runtimeParams', JSON.stringify(params));
            }

            /**
             * Load runtime parameters from localStorage
             */
            loadRuntimeParams() {
                const saved = localStorage.getItem('runtimeParams');
                if (saved) {
                    try {
                        const params = JSON.parse(saved);

                        // Update slider values
                        if (params.footprint !== undefined) {
                            document.getElementById('footprintSlider').value = params.footprint;
                            document.getElementById('footprintValue').textContent = params.footprint;
                        }
                        if (params.minArea !== undefined) {
                            document.getElementById('minAreaSlider').value = params.minArea;
                            document.getElementById('minAreaValue').textContent = params.minArea;
                        }
                        if (params.thresholdL !== undefined) {
                            document.getElementById('thresholdLSlider').value = params.thresholdL;
                            document.getElementById('thresholdLValue').textContent = (params.thresholdL / 256).toFixed(2);
                        }
                        if (params.thresholdH !== undefined) {
                            document.getElementById('thresholdHSlider').value = params.thresholdH;
                            document.getElementById('thresholdHValue').textContent = (params.thresholdH / 256).toFixed(2);
                            // Also sync Simple Mode Hysteresis
                            if (document.getElementById('simpleHysteresisSlider')) {
                                document.getElementById('simpleHysteresisSlider').value = params.thresholdH;
                                document.getElementById('simpleHysteresisValue').textContent = (params.thresholdH / 256).toFixed(2);
                            }
                        }
                        if (params.tempMin !== undefined) {
                            document.getElementById('tempMinSlider').value = params.tempMin;
                            document.getElementById('tempMinValue').textContent = params.tempMin == 0 ? '20.0' : (params.tempMin / 50).toFixed(1);
                        }
                        if (params.tempMax !== undefined) {
                            document.getElementById('tempMaxSlider').value = params.tempMax;
                            document.getElementById('tempMaxValue').textContent = params.tempMax == 0 ? '40.0' : (params.tempMax / 50).toFixed(1);
                        }
                        if (params.logGateL !== undefined) {
                            document.getElementById('logGateLSlider').value = params.logGateL;
                            document.getElementById('logGateLValue').textContent = params.logGateL;
                        }
                        if (params.logGateH !== undefined) {
                            document.getElementById('logGateHSlider').value = params.logGateH;
                            document.getElementById('logGateHValue').textContent = params.logGateH;
                        }
                        if (params.percentileL !== undefined) {
                            document.getElementById('percentileLSlider').value = params.percentileL;
                            document.getElementById('percentileLValue').textContent = (params.percentileL / 256).toFixed(2);
                        }
                        if (params.percentileH !== undefined) {
                            document.getElementById('percentileHSlider').value = params.percentileH;
                            document.getElementById('percentileHValue').textContent = (params.percentileH / 256).toFixed(2);
                        }
                        if (params.gammaEma !== undefined) {
                            document.getElementById('gammaEmaSlider').value = params.gammaEma;
                            document.getElementById('gammaEmaValue').textContent = (params.gammaEma / 256).toFixed(2);
                            // Also sync Simple Mode BG Learning
                            if (document.getElementById('simpleGammaEmaSlider')) {
                                document.getElementById('simpleGammaEmaSlider').value = params.gammaEma;
                                document.getElementById('simpleGammaEmaValue').textContent = (params.gammaEma / 256).toFixed(2);
                            }
                        }
                        if (params.thHot !== undefined) {
                            document.getElementById('thHotSlider').value = params.thHot;
                            document.getElementById('thHotValue').textContent = (params.thHot / 50).toFixed(1);
                        }
                        if (params.thCold !== undefined) {
                            document.getElementById('thColdSlider').value = params.thCold;
                            document.getElementById('thColdValue').textContent = (params.thCold / 50).toFixed(1);
                        }
                        if (params.trackAge !== undefined) {
                            document.getElementById('trackAgeSlider').value = params.trackAge;
                            document.getElementById('trackAgeValue').textContent = params.trackAge;
                        }
                        if (params.trackMissed !== undefined) {
                            document.getElementById('trackMissedSlider').value = params.trackMissed;
                            document.getElementById('trackMissedValue').textContent = params.trackMissed;
                        }
                        if (params.motionThresh !== undefined) {
                            document.getElementById('motionThreshSlider').value = params.motionThresh;
                            document.getElementById('motionThreshValue').textContent = (params.motionThresh / 50).toFixed(1);
                        }
                        if (params.motionHyst !== undefined) {
                            document.getElementById('motionHystSlider').value = params.motionHyst;
                            document.getElementById('motionHystValue').textContent = params.motionHyst;
                        }
                        if (params.motionDensity !== undefined) {
                            document.getElementById('motionDensitySlider').value = params.motionDensity;
                            document.getElementById('motionDensityValue').textContent = params.motionDensity;
                            // Sync motion validation checkbox (checked = enabled = density > 0)
                            const checkbox = document.getElementById('motionValidationCheckbox');
                            if (checkbox) {
                                checkbox.checked = (parseInt(params.motionDensity) > 0);
                                document.getElementById('motionDensitySlider').disabled = !checkbox.checked;
                            }
                        }

                        this.log('Loaded runtime parameters from localStorage');
                    } catch (error) {
                        console.error('Failed to load runtime params:', error);
                    }
                }
            }

            /**
             * Update frame rate
             */
            updateFrameRate(value) {
                this.frameRate = parseFloat(value);
                this.ui.el.frameRateValue.textContent = this.frameRate.toFixed(1) + ' Hz';

                // Restart capture loop if currently capturing
                if (this.capturing) {
                    clearInterval(this.captureInterval);
                    this.captureInterval = setInterval(() => {
                        this.captureFrame();
                    }, 1000 / this.frameRate);
                }
            }

            /**
             * Start recording session
             */
            startRecording() {
                this.recording = true;
                this.recordedFrames = [];
                document.getElementById('recordBtn').disabled = true;
                document.getElementById('stopRecordBtn').disabled = false;
                this.log('Recording started...');
            }

            /**
             * Stop recording session
             */
            stopRecording() {
                this.recording = false;
                document.getElementById('recordBtn').disabled = false;
                document.getElementById('stopRecordBtn').disabled = true;
                document.getElementById('saveRecordBtn').disabled = false;
                this.log(`Recording stopped. ${this.recordedFrames.length} frames captured.`);
            }

            /**
             * Save recording to JSON file
             */
            saveRecording() {
                const data = {
                    version: '1.0',
                    timestamp: new Date().toISOString(),
                    frameCount: this.recordedFrames.length,
                    frames: this.recordedFrames
                };

                const json = JSON.stringify(data, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = `thermal_recording_${Date.now()}.json`;
                a.click();

                URL.revokeObjectURL(url);
                this.log(`Recording saved: ${this.recordedFrames.length} frames`);
            }

            /**
             * Toggle connection (connect or disconnect)
             */
            async toggleConnection() {
                if (this.serialManager.isConnected()) {
                    await this.disconnect();
                } else {
                    await this.connect();
                }
            }

            /**
             * Toggle capture (start or stop)
             */
            async toggleCapture() {
                if (this.capturing) {
                    this.stopCapture();
                } else {
                    await this.startCapture();
                }
            }

            /**
             * Update connection state UI
             * @param {boolean} connected - Whether device is connected
             * @param {string} [partialState] - Optional partial state: 'update_pending' when connected via probe but not initialized
             */
            updateConnectionState(connected, partialState = null) {
                const btn = document.getElementById('connectionToggle');
                btn.textContent = connected ? 'Disconnect' : 'Connect';
                btn.className = connected ? 'danger' : 'primary';

                // Delegate control enabling/disabling to UIManager
                this.ui.setConnectionState(connected);

                // Handle partial connection states (e.g., probe connection for firmware update)
                if (partialState === 'update_pending') {
                    const captureBtn = document.getElementById('captureToggle');
                    if (captureBtn) {
                        captureBtn.disabled = true;
                    }
                    document.getElementById('sensorStatus').textContent = 'Update pending';
                    document.getElementById('sensorStatus').style.color = '#f59e0b'; // Orange
                }
            }

            /**
             * Update capture state UI
             */
            updateCaptureState(capturing) {
                const btn = document.getElementById('captureToggle');
                btn.textContent = capturing ? 'Stop Capture' : 'Start Capture';
                btn.className = capturing ? 'danger' : 'secondary';

                // Disable record button when not capturing
                document.getElementById('recordBtn').disabled = !capturing;

                // Disable preset controls during capture to prevent race conditions
                document.getElementById('presetSelect').disabled = capturing;
                document.getElementById('coldDetection').disabled = capturing;
            }

            /**
             * Log message to debug output
             */
            log(message) {
                const output = document.getElementById('debugOutput');
                const timestamp = new Date().toLocaleTimeString();
                output.value += `[${timestamp}] ${message}\n`;
                output.scrollTop = output.scrollHeight;
                console.log(message);
            }

            /**
             * Firmware Update Methods
             */

            /**
             * Auto-check for firmware updates (called after connection)
             */
            async autoCheckForUpdates() {
                // Skip if no longer connected (race condition with delayed setTimeout)
                if (!this.serialManager.isConnected()) {
                    console.log('Auto-update check skipped: not connected');
                    return;
                }

                try {
                    console.log('Auto-checking for firmware updates...');
                    const updateInfo = await this.firmwareUpdater.checkForUpdates();

                    if (updateInfo && updateInfo.updateAvailable) {
                        // Show update badge
                        const badge = document.getElementById('updateBadge');
                        if (badge) {
                            badge.style.display = 'flex';
                        }

                        this.currentUpdateInfo = updateInfo;
                        this.log(`✨ Firmware update available: ${updateInfo.latest}`);
                        console.log('Update available:', updateInfo);
                    } else {
                        console.log('Firmware is up to date');
                        // Hide badge if previously shown
                        const badge = document.getElementById('updateBadge');
                        if (badge) badge.style.display = 'none';
                    }
                } catch (error) {
                    console.warn('Auto-update check failed:', error);
                    // Non-critical, don't bother user
                }
            }

            /**
             * Show update modal
             */
            async showUpdateModal() {
                const modal = document.getElementById('updateModal');
                modal.classList.add('show');

                // Reset modal state
                this.resetUpdateModal();

                // Check if connected - if not, probe device first
                if (this.serialManager.isConnected()) {
                    // Already connected - normal flow
                    this.checkForUpdate();
                } else {
                    // Not connected - probe device to check responsiveness
                    await this.probeDeviceForUpdate();
                }
            }

            /**
             * Probe device for firmware update when not connected
             * Attempts lightweight connection to check device state without full INIT
             */
            async probeDeviceForUpdate() {
                const checkBtn = document.getElementById('checkUpdateBtn');
                const updateBtn = document.getElementById('startUpdateBtn');

                this.appendUpdateLog('Attempting to connect to device...', 'info');
                checkBtn.disabled = true;
                checkBtn.textContent = 'Connecting...';

                try {
                    // Step 1: Request and open port
                    await this.serialManager.requestPort();
                    await this.serialManager.connect(921600);

                    this.appendUpdateLog('Port opened, testing communication...', 'info');

                    // Step 2: Test basic communication
                    const commWorking = await this.serialManager.testCommunication(5000);

                    if (!commWorking) {
                        // No response at all - cannot update automatically
                        this.appendUpdateLog('', 'info');
                        this.appendUpdateLog('❌ Device not responding to commands.', 'error');
                        this.appendUpdateLog('', 'info');
                        this.appendUpdateLog('No automatic update possible.', 'info');
                        this.appendUpdateLog('', 'info');
                        this.appendUpdateLog('You can still update manually:', 'info');
                        this.appendUpdateLog('  1. Select a .hex file below', 'info');
                        this.appendUpdateLog('  2. Put device in DFU mode (hold BOOT while connecting USB)', 'info');
                        this.appendUpdateLog('  3. Click "Update Firmware"', 'info');

                        document.getElementById('currentFirmwareVersion').textContent = 'No response';
                        document.getElementById('latestFirmwareVersion').textContent = '--';

                        await this.serialManager.disconnect();
                        checkBtn.disabled = true;
                        checkBtn.textContent = 'No Device';
                        return;
                    }

                    this.appendUpdateLog('Device responding!', 'success');

                    // Track that we connected via probe (will disconnect on modal close)
                    this.connectedViaProbe = true;

                    // Update main UI to reflect partial connection
                    this.updateConnectionState(true, 'update_pending');

                    // Step 3: Try to get version
                    let currentVersion = null;
                    try {
                        const response = await this.serialManager.sendCommand(':PeopleDetection:VERSION?', 2000);
                        const versionMatch = response.match(/Version\s+([\d.]+)/);
                        if (versionMatch) {
                            currentVersion = versionMatch[1];
                            this.appendUpdateLog(`Current firmware version: ${currentVersion}`, 'info');
                            // Update main page ISP Library version
                            document.getElementById('libraryVersion').textContent = currentVersion;
                        }
                    } catch (e) {
                        this.appendUpdateLog('Could not read firmware version (will update to latest).', 'info');
                    }

                    // Step 4: Fetch latest release info
                    this.appendUpdateLog('Checking for latest firmware...', 'info');
                    let latestRelease;
                    try {
                        latestRelease = await this.firmwareUpdater._getLatestRelease();
                    } catch (error) {
                        this.appendUpdateLog(`❌ Could not fetch latest release: ${error.message}`, 'error');
                        this.appendUpdateLog('You can still upload a local .hex file manually.', 'info');
                        checkBtn.disabled = false;
                        checkBtn.textContent = 'Retry';
                        return;
                    }

                    // Step 5: Determine update availability
                    const latestVersion = latestRelease.tag_name;
                    let updateAvailable;

                    if (currentVersion) {
                        // Compare versions
                        updateAvailable = this.firmwareUpdater._compareVersions(latestVersion, currentVersion);
                        document.getElementById('currentFirmwareVersion').textContent = currentVersion;
                    } else {
                        // Version unknown - allow update to latest
                        updateAvailable = true;
                        document.getElementById('currentFirmwareVersion').textContent = 'Unknown';
                        this.appendUpdateLog('Version unknown - update to latest recommended.', 'info');
                    }

                    document.getElementById('latestFirmwareVersion').textContent = latestVersion.replace(/^v/, '');

                    // Get manifest for file size
                    const manifest = await this.firmwareUpdater._getManifest(latestRelease);
                    if (manifest) {
                        const fwArtifact = manifest.artifacts && manifest.artifacts.firmware;
                        const size = (fwArtifact && fwArtifact.size_bytes) || manifest.binary_size || 'Unknown';
                        document.getElementById('firmwareSize').textContent =
                            typeof size === 'number' ? this.formatBytes(size) : size;
                    }

                    // Store update info
                    this.currentUpdateInfo = {
                        updateAvailable: updateAvailable,
                        current: currentVersion || 'Unknown',
                        latest: latestVersion,
                        downloadUrl: updateAvailable ? this.firmwareUpdater._getFirmwareUrl(latestRelease) : null,
                        manifest: manifest,
                        releaseNotes: latestRelease.description
                    };

                    if (updateAvailable) {
                        this.appendUpdateLog(`✅ Update available: ${latestVersion}`, 'success');
                        updateBtn.disabled = false;
                        document.getElementById('updateBadge').style.display = 'flex';
                    } else {
                        this.appendUpdateLog('✅ Firmware is up to date!', 'success');
                        updateBtn.disabled = true;
                        document.getElementById('updateBadge').style.display = 'none';
                    }

                    // Keep connection open for update process

                } catch (error) {
                    this.appendUpdateLog(`❌ Connection failed: ${error.message}`, 'error');
                    this.appendUpdateLog('', 'info');
                    this.appendUpdateLog('Manual file upload is still available.', 'info');
                    console.error('Probe connection error:', error);
                } finally {
                    checkBtn.disabled = false;
                    checkBtn.textContent = 'Check for Updates';
                }
            }

            /**
             * Close update modal
             */
            async closeUpdateModal() {
                const modal = document.getElementById('updateModal');
                modal.classList.remove('show');

                // If we connected via probe and user is closing without updating,
                // disconnect to return to previous state
                if (this.connectedViaProbe && this.serialManager.isConnected()) {
                    try {
                        await this.serialManager.disconnect();
                        this.updateConnectionState(false);
                        document.getElementById('sensorStatus').textContent = 'Not configured';
                        document.getElementById('sensorStatus').style.color = '#888';
                        document.getElementById('libraryVersion').textContent = '--';
                    } catch (e) {
                        console.log('Disconnect on modal close:', e);
                    }
                    this.connectedViaProbe = false;
                }
            }

            /**
             * Reset modal to initial state
             */
            resetUpdateModal() {
                // Hide progress section
                document.getElementById('updateProgressSection').style.display = 'none';
                document.getElementById('manualDfuInstructions').style.display = 'none';

                // Clear log
                document.getElementById('updateLog').innerHTML = '';

                // Clear success message if present
                const successMsg = document.querySelector('.version-info.success-message');
                if (successMsg) {
                    successMsg.remove();
                }

                // Reset buttons to default state
                const updateButtons = document.querySelector('.update-buttons');
                updateButtons.innerHTML = `
                    <button id="checkUpdateBtn" class="primary">
                        Check for Updates
                    </button>
                    <button id="startUpdateBtn" class="secondary" disabled>
                        Update Firmware
                    </button>
                    <button id="closeModalBtn" class="primary">
                        Close
                    </button>
                `;

                // Re-attach event listeners since we replaced the HTML
                document.getElementById('checkUpdateBtn').addEventListener('click', () => this.checkForUpdate());
                document.getElementById('startUpdateBtn').addEventListener('click', () => this.startFirmwareUpdate());
                document.getElementById('closeModalBtn').addEventListener('click', () => this.closeUpdateModal());

                // Reset progress
                this.updateProgress(0, 'Initializing...');

                // Reset buttons state
                document.getElementById('checkUpdateBtn').disabled = false;
                document.getElementById('startUpdateBtn').disabled = !this.currentUpdateInfo;
                document.getElementById('closeModalBtn').disabled = false;

                // Clear file selection info
                const fileInfo = document.getElementById('selectedFileInfo');
                if (fileInfo) fileInfo.innerHTML = '';

                // Reset file input
                const fileInput = document.getElementById('firmwareFileInput');
                if (fileInput) fileInput.value = '';
            }

            /**
             * Check for firmware updates (manual trigger)
             */
            async checkForUpdate() {
                const checkBtn = document.getElementById('checkUpdateBtn');
                const updateBtn = document.getElementById('startUpdateBtn');

                try {
                    checkBtn.disabled = true;
                    checkBtn.textContent = 'Checking...';

                    this.appendUpdateLog('Checking for firmware updates...', 'info');

                    const updateInfo = await this.firmwareUpdater.checkForUpdates();

                    if (updateInfo) {
                        this.currentUpdateInfo = updateInfo;

                        // Update UI (always show version info, normalized)
                        document.getElementById('currentFirmwareVersion').textContent = updateInfo.current.replace(/^v/, '');
                        document.getElementById('latestFirmwareVersion').textContent = updateInfo.latest.replace(/^v/, '');

                        if (updateInfo.manifest) {
                            const fwArtifact = updateInfo.manifest.artifacts && updateInfo.manifest.artifacts.firmware;
                            const size = (fwArtifact && fwArtifact.size_bytes) || updateInfo.manifest.binary_size || 'Unknown';
                            document.getElementById('firmwareSize').textContent =
                                typeof size === 'number' ? this.formatBytes(size) : size;
                        }

                        if (updateInfo.updateAvailable) {
                            this.appendUpdateLog(`✅ Update available: ${updateInfo.latest}`, 'success');
                            updateBtn.disabled = false;
                            // Show badge
                            document.getElementById('updateBadge').style.display = 'flex';
                        } else {
                            this.appendUpdateLog('✅ Firmware is up to date!', 'success');
                            updateBtn.disabled = true;
                            document.getElementById('updateBadge').style.display = 'none';
                        }
                    }
                } catch (error) {
                    this.appendUpdateLog(`❌ Update check failed: ${error.message}`, 'error');
                    console.error('Update check error:', error);
                } finally {
                    checkBtn.disabled = false;
                    checkBtn.textContent = 'Check for Updates';
                }
            }

            /**
             * Start firmware update process
             */
            async startFirmwareUpdate() {
                if (!this.currentUpdateInfo) {
                    alert('No update information available. Check for updates first.');
                    return;
                }

                // For local file uploads when not connected, try to establish connection
                const isLocal = this.currentUpdateInfo.isLocalFile;
                if (isLocal && !this.serialManager.isConnected()) {
                    this.appendUpdateLog('Local file selected - connecting to device...', 'info');

                    try {
                        await this.serialManager.requestPort();
                        await this.serialManager.connect(921600);

                        // Test basic communication
                        const commWorking = await this.serialManager.testCommunication(5000);
                        if (commWorking) {
                            this.appendUpdateLog('Device connected!', 'success');
                            // Update main UI to show partial connection
                            this.updateConnectionState(true, 'update_pending');
                        } else {
                            // Device not responding - suggest manual DFU
                            this.appendUpdateLog('⚠️ Device not responding. Use Manual DFU mode.', 'error');
                            this.appendUpdateLog('', 'info');
                            this.appendUpdateLog('To enter Manual DFU mode:', 'info');
                            this.appendUpdateLog('  1. Disconnect USB from device', 'info');
                            this.appendUpdateLog('  2. Press and HOLD the BOOT button', 'info');
                            this.appendUpdateLog('  3. While holding BOOT, connect USB', 'info');
                            this.appendUpdateLog('  4. Release BOOT button', 'info');
                            this.appendUpdateLog('  5. Click "Update Firmware" again', 'info');

                            document.getElementById('manualDfuInstructions').style.display = 'block';

                            await this.serialManager.disconnect();
                            return;
                        }
                    } catch (error) {
                        this.appendUpdateLog(`❌ Could not connect: ${error.message}`, 'error');
                        this.appendUpdateLog('Try using Manual DFU mode instead.', 'info');
                        document.getElementById('manualDfuInstructions').style.display = 'block';
                        return;
                    }
                }

                // Confirm with user
                const confirmMessage = isLocal ?
                    `Flash firmware from local file: ${this.currentUpdateInfo.latest}?\n\n` +
                    `⚠️ WARNING:\n` +
                    `• Do NOT disconnect USB during update\n` +
                    `• Update takes about 90 seconds\n` +
                    `• Device will reboot after update\n` +
                    `• Make sure firmware is compatible with your hardware!\n\n` +
                    `Continue?`
                    :
                    `Update firmware from ${this.currentUpdateInfo.current} to ${this.currentUpdateInfo.latest}?\n\n` +
                    `⚠️ WARNING:\n` +
                    `• Do NOT disconnect USB during update\n` +
                    `• Update takes about 90 seconds\n` +
                    `• Device will reboot after update\n\n` +
                    `Continue?`;

                const confirmed = confirm(confirmMessage);

                if (!confirmed) {
                    return;
                }

                // Clear probe flag - we're committing to the update, don't disconnect on close
                this.connectedViaProbe = false;

                // Disable buttons during update
                document.getElementById('checkUpdateBtn').disabled = true;
                document.getElementById('startUpdateBtn').disabled = true;
                document.getElementById('closeModalBtn').disabled = true;

                // Show progress section
                document.getElementById('updateProgressSection').style.display = 'block';

                // Set up progress callbacks
                this.firmwareUpdater.onProgress = (percent, message) => {
                    this.updateProgress(percent, message);
                };

                this.firmwareUpdater.onStatus = (message, state) => {
                    this.appendUpdateLog(`[${state}] ${message}`, 'info');
                };

                this.firmwareUpdater.onError = (message, state) => {
                    this.appendUpdateLog(`❌ ${message}`, 'error');

                    // Show manual DFU instructions if DFU entry failed
                    if (state === 'CONNECTING_DFU' || state === 'ENTERING_DFU') {
                        document.getElementById('manualDfuInstructions').style.display = 'block';
                    }
                };

                this.firmwareUpdater.onComplete = (version) => {
                    this.log(`Firmware update complete: ${version}`, 'SUCCESS');

                    // Device has rebooted - reset main UI to disconnected state
                    this.updateConnectionState(false);
                    document.getElementById('sensorStatus').textContent = 'Not configured';
                    document.getElementById('sensorStatus').style.color = '#888';
                    document.getElementById('libraryVersion').textContent = '--';

                    // Change modal UI to "Update Successful" state
                    const statusDiv = document.getElementById('updateStatus');
                    const progressSection = document.getElementById('updateProgressSection');
                    const updateButtons = document.querySelector('.update-buttons');

                    // Hide progress bar
                    progressSection.style.display = 'none';

                    // Show success message and Reconnect button
                    const successMsg = document.createElement('div');
                    successMsg.className = 'version-info success-message';
                    successMsg.style.textAlign = 'center';
                    successMsg.style.marginTop = '20px';
                    successMsg.innerHTML = `
                        <h3 style="color: #4ade80; margin-bottom: 10px;">Update Successful!</h3>
                        <p>Device has been updated to version ${version} and is rebooting.</p>
                        <p style="margin-top: 10px; font-size: 0.9rem; opacity: 0.8;">Please reconnect to the device.</p>
                    `;

                    // Replace existing buttons with Reconnect/Close
                    const reconnectBtn = document.createElement('button');
                    reconnectBtn.className = 'primary';
                    reconnectBtn.textContent = '🔌 Reconnect Device';
                    reconnectBtn.onclick = async () => {
                        this.closeUpdateModal();
                        // wait a bit for device to be ready
                        setTimeout(() => this.toggleConnection(), 500);
                    };

                    const closeBtn = document.createElement('button');
                    closeBtn.className = 'secondary';
                    closeBtn.textContent = 'Close';
                    closeBtn.onclick = () => this.closeUpdateModal();

                    // Clear previous buttons and add new ones
                    updateButtons.innerHTML = '';
                    updateButtons.appendChild(reconnectBtn);
                    updateButtons.appendChild(closeBtn);

                    // Insert success message before log
                    const logDiv = document.getElementById('updateLog');
                    statusDiv.insertBefore(successMsg, logDiv);
                };

                // Check if manual DFU mode is selected
                const manualDfuModeCheckbox = document.getElementById('manualDfuModeCheckbox');
                const manualDfuMode = manualDfuModeCheckbox ? manualDfuModeCheckbox.checked : false;

                try {
                    this.appendUpdateLog('Starting firmware update...', 'info');
                    if (manualDfuMode) {
                        this.appendUpdateLog('ℹ️ Manual DFU mode enabled - device should already be in DFU mode', 'info');
                    }
                    await this.firmwareUpdater.performUpdate(this.currentUpdateInfo, manualDfuMode);
                } catch (error) {
                    console.error('Update failed:', error);
                    // Error already logged via onError callback

                    // Re-enable buttons
                    document.getElementById('checkUpdateBtn').disabled = false;
                    document.getElementById('startUpdateBtn').disabled = false;
                    document.getElementById('closeModalBtn').disabled = false;
                }
            }

            /**
             * Toggle manual DFU instructions visibility
             */
            toggleManualDfuInstructions() {
                const checkbox = document.getElementById('manualDfuModeCheckbox');
                const instructions = document.getElementById('manualDfuInstructionsPreview');
                if (checkbox && instructions) {
                    instructions.style.display = checkbox.checked ? 'block' : 'none';
                }
            }

            /**
             * Update progress bar and text
             */
            updateProgress(percent, message) {
                const progressBar = document.getElementById('updateProgressBar');
                const progressText = document.getElementById('updateProgressText');

                progressBar.style.width = Math.min(Math.max(percent, 0), 100) + '%';
                progressBar.textContent = Math.round(percent) + '%';
                progressText.textContent = message;
            }

            /**
             * Append message to update log
             */
            appendUpdateLog(message, type = 'info') {
                const log = document.getElementById('updateLog');
                const entry = document.createElement('div');
                entry.className = `update-log-entry ${type}`;
                entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                log.appendChild(entry);
                log.scrollTop = log.scrollHeight;
            }

            /**
             * Format bytes for display
             */
            formatBytes(bytes) {
                if (bytes < 1024) return bytes + ' B';
                if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
                return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
            }

            /**
             * Handle firmware file selection from local disk
             */
            async handleFirmwareFileSelect(event) {
                const file = event.target.files[0];
                if (!file) return;

                const fileInfo = document.getElementById('selectedFileInfo');
                const startBtn = document.getElementById('startUpdateBtn');

                try {
                    const isHex = file.name.toLowerCase().endsWith('.hex');

                    // Validate file extension
                    if (!isHex) {
                        fileInfo.innerHTML = '❌ <span style="color: #ef4444;">Invalid file type. Please select a .hex file</span>';
                        return;
                    }

                    let firmwareData;
                    let arrayBuffer; // For hashing

                    if (isHex) {
                        // Read as text for HEX
                        firmwareData = await file.text();
                        arrayBuffer = new TextEncoder().encode(firmwareData); // Convert to buffer for hashing
                    } else {
                        // Read as buffer for BIN
                        arrayBuffer = await file.arrayBuffer();
                        firmwareData = arrayBuffer;
                    }

                    // Validate size (typical firmware is ~288KB, max 512KB for STM32F446)
                    // HEX files are larger (ASCII), so increase limit approx 3x
                    const maxSize = isHex ? 2 * 1024 * 1024 : 512 * 1024;

                    if (arrayBuffer.byteLength > maxSize) {
                        fileInfo.innerHTML = `❌ <span style="color: #ef4444;">File too large (${this.formatBytes(arrayBuffer.byteLength)}). Max ${this.formatBytes(maxSize)}</span>`;
                        return;
                    }

                    if (arrayBuffer.byteLength < 1024 && !isHex) { // Hex files might be small if partial update?
                        fileInfo.innerHTML = `❌ <span style="color: #ef4444;">File too small (${this.formatBytes(arrayBuffer.byteLength)}). Likely corrupted</span>`;
                        return;
                    }

                    // Calculate SHA-256 hash for verification
                    const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
                    const hashArray = Array.from(new Uint8Array(hashBuffer));
                    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

                    // Store firmware data for upload
                    this.currentUpdateInfo = {
                        current: 'Unknown',
                        latest: 'Local File',
                        downloadUrl: null,
                        firmwareData: firmwareData,
                        fileName: file.name,
                        manifest: {
                            sha256: hashHex,
                            binary_size: arrayBuffer.byteLength
                        },
                        isLocalFile: true
                    };

                    // Update UI
                    fileInfo.innerHTML = `
                        ✅ <span style="color: #4ade80;">File loaded: ${file.name}</span><br>
                        <span style="opacity: 0.8;">Size: ${this.formatBytes(arrayBuffer.byteLength)}</span><br>
                        <span style="opacity: 0.8; font-family: monospace; font-size: 0.8rem;">SHA-256: ${hashHex.substring(0, 16)}...</span>
                    `;

                    // Update version display
                    document.getElementById('currentFirmwareVersion').textContent = 'Unknown';
                    document.getElementById('latestFirmwareVersion').textContent = file.name;
                    document.getElementById('firmwareSize').textContent = this.formatBytes(arrayBuffer.byteLength);

                    // Enable update button
                    startBtn.disabled = false;

                    this.appendUpdateLog(`Local firmware file loaded: ${file.name} (${this.formatBytes(arrayBuffer.byteLength)})`, 'success');
                    this.appendUpdateLog(`SHA-256: ${hashHex}`, 'info');

                } catch (error) {
                    fileInfo.innerHTML = `❌ <span style="color: #ef4444;">Failed to read file: ${error.message}</span>`;
                    console.error('File read error:', error);
                }
            }
        }

        // Initialize application when page loads
        let app;
        window.addEventListener('DOMContentLoaded', () => {
            app = new ThermalViewerApp();
            app.ui.applyUIMode();

            // Sync transforms with initial checkbox state
            app.updateTransforms();
        });
    </script>
</body>
</html>
