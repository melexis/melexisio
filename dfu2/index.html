<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>STM32 DFU Firmware Uploader</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body { font-family: Arial, sans-serif; background: #232A34; color: #E9F2FF; }
        .container { max-width: 600px; margin: 2rem auto; background: #1A2027; border-radius: 1rem; padding: 2rem; }
        #log { background: #000; color: #cfe2ff; font: 12px monospace; padding: 1rem; height: 220px; overflow: auto; border-radius: .5rem; margin-top: 1rem; }
        .progress { height: 10px; background: #0d1a2b; border-radius: 4px; overflow: hidden; margin-top: 1rem; }
        .progress-bar { background: #3b82f6; height: 100%; width: 0%; transition: width .2s; }
    </style>
</head>
<body>
<div class="container">
    <h3>STM32 DFU Firmware Uploader</h3>
    <div class="mb-3">
        <label class="form-label">Firmware file (.bin/.hex/.dfu)
            <input type="file" id="fw" accept=".bin,.hex,.dfu" class="form-control" />
        </label>
    </div>
    <div class="mb-3">
        <button id="connect" class="btn btn-primary">Connect DFU Device</button>
        <button id="flash" class="btn btn-success" disabled>Flash Firmware</button>
    </div>
    <div class="mb-3">
        <div class="form-check">
            <input class="form-check-input" type="checkbox" id="tryErase" />
            <label class="form-check-label" for="tryErase">
                Try DFU erase commands before write (may fail on ROM bootloader)
            </label>
        </div>
    </div>
    <div class="progress"><div id="bar" class="progress-bar"></div></div>
    <pre id="log"></pre>
</div>
<script>
const DFU = { DETACH:0, DNLOAD:1, UPLOAD:2, GETSTATUS:3, CLRSTATUS:4, GETSTATE:5, ABORT:6 };
let device, dfuInterface = null, altSetting = 0;
function log(msg) {
    const box = document.getElementById('log');
    box.textContent += msg + "\n";
    box.scrollTop = box.scrollHeight;
}
function updateProgress(p) {
    document.getElementById('bar').style.width = p.toFixed(2) + '%';
}
async function connect() {
    const filters = [{ vendorId: 0x0483 }];
    device = await navigator.usb.requestDevice({ filters });
    await device.open();
    if (device.configuration === null) await device.selectConfiguration(1);
    for (const iface of device.configuration.interfaces) {
        for (const alt of iface.alternates) {
            if (alt.interfaceClass === 0xFE && alt.interfaceSubclass === 0x01 && alt.interfaceProtocol === 0x02) {
                dfuInterface = iface.interfaceNumber;
                altSetting = alt.alternateSetting;
                break;
            }
        }
        if (dfuInterface !== null) break;
    }
    if (dfuInterface === null) { log('DFU interface not found.'); return; }
    await device.claimInterface(dfuInterface);
    await device.selectAlternateInterface(dfuInterface, altSetting);
    // Device info
    log('Connected to STM32 DFU device');
    log('USB speed   : Full Speed (12MBit/s)');
    log('Manuf. ID   : ' + (device.manufacturerName || '--'));
    log('Product ID  : ' + (device.productName || '--'));
    log('SN          : ' + (device.serialNumber || '--'));
    log('DFU protocol: 1.1');
    log('Device ID   : 0x' + device.productId.toString(16).padStart(4,'0'));
    document.getElementById('flash').disabled = false;
}
async function control(request, value=0, index=altSetting, length=0) {
    return device.controlTransferOut({ requestType:'class', recipient:'interface', request, value, index }, new ArrayBuffer(length));
}
async function dnload(blockNum, data) {
    return device.controlTransferOut({ requestType:'class', recipient:'interface', request: DFU.DNLOAD, value: blockNum, index: dfuInterface }, data);
}
async function getStatus() {
    const r = await device.controlTransferIn({ requestType:'class', recipient:'interface', request: DFU.GETSTATUS, value:0, index: dfuInterface }, 6);
    if (!r.data) throw new Error('No status data');
    return { status: r.data.getUint8(0), pollTimeout: r.data.getUint8(1) | (r.data.getUint8(2)<<8) | (r.data.getUint8(3)<<16), state: r.data.getUint8(4), iString: r.data.getUint8(5) };
}
function sleep(ms) { return new Promise(r=>setTimeout(r, ms)); }
async function waitState(target) {
    for (let i=0;i<50;i++) {
        const s = await getStatus();
        if (s.state === target) return s;
        if (s.state === 5) await sleep(s.pollTimeout);
        else if (s.state === 2 || s.state === 9) await sleep(10);
        else log('State: ' + s.state + ' Status: ' + s.status);
    }
    throw new Error('Timeout waiting for state ' + target);
}
function parseIntelHex(text) {
    const lines = text.split(/\r?\n/).filter(l=>l.trim().length>0);
    let extLinear = 0, extSegment = 0;
    const rawSegments = [];
    for (const line of lines) {
        if (!line.startsWith(':')) throw new Error('Bad HEX line (missing :)');
        const rec = line.slice(1).trim();
        const len = parseInt(rec.slice(0,2),16);
        const addr = parseInt(rec.slice(2,6),16);
        const type = parseInt(rec.slice(6,8),16);
        const dataHex = rec.slice(8, 8 + len*2);
        const chkHex = rec.slice(8 + len*2, 8 + len*2 + 2);
        if (dataHex.length !== len*2) throw new Error('Length mismatch in HEX record');
        let sum = len + (addr>>8) + (addr & 0xFF) + type;
        for (let i=0;i<dataHex.length;i+=2) sum += parseInt(dataHex.slice(i,i+2),16);
        sum += parseInt(chkHex,16);
        if ((sum & 0xFF) !== 0) throw new Error('Checksum error in HEX record');
        if (type === 0x00) {
            let fullAddr;
            if (extLinear) fullAddr = (extLinear << 16) | addr;
            else if (extSegment) fullAddr = (extSegment << 4) | addr;
            else fullAddr = addr;
            const data = new Uint8Array(len);
            for (let i=0;i<len;i++) data[i] = parseInt(dataHex.slice(i*2,i*2+2),16);
            rawSegments.push({ address: fullAddr >>> 0, data });
        } else if (type === 0x01) {
            break;
        } else if (type === 0x04) {
            extLinear = parseInt(dataHex,16) & 0xFFFF; extSegment = 0;
        } else if (type === 0x02) {
            extSegment = parseInt(dataHex,16) & 0xFFFF; extLinear = 0;
        }
    }
    if (!rawSegments.length) throw new Error('No data segments in HEX');
    rawSegments.sort((a,b)=>a.address-b.address);
    // Merge contiguous segments
    const merged = [];
    for (const seg of rawSegments) {
        const last = merged[merged.length-1];
        if (last && seg.address === (last.address + last.data.length)) {
            const combined = new Uint8Array(last.data.length + seg.data.length);
            combined.set(last.data,0);
            combined.set(seg.data,last.data.length);
            last.data = combined;
        } else {
            merged.push({ address: seg.address, data: seg.data });
        }
    }
    let gaps = 0, lastEnd = merged[0].address + merged[0].data.length;
    for (let i=1;i<merged.length;i++) {
        if (merged[i].address > lastEnd) gaps++;
        lastEnd = Math.max(lastEnd, merged[i].address + merged[i].data.length);
    }
    return { baseAddress: merged[0].address >>> 0, segments: merged, hadGaps: gaps>0, segmentsCount: merged.length };
}
function buildPaddedHexBuffer(hexInfo) {
    if (!hexInfo || !hexInfo.segments || !hexInfo.segments.length) throw new Error('No HEX segments');
    const firstAddr = hexInfo.segments[0].address;
    const lastSeg = hexInfo.segments[hexInfo.segments.length-1];
    const endAddr = lastSeg.address + lastSeg.data.length;
    const totalSize = endAddr - firstAddr;
    const buf = new Uint8Array(totalSize);
    buf.fill(0xFF);
    let filled = 0;
    for (const seg of hexInfo.segments) {
        buf.set(seg.data, seg.address - firstAddr);
        filled += seg.data.length;
    }
    return { baseAddress:firstAddr, bytes:buf, totalSize, filledBytes:filled, gapBytes: totalSize - filled };
}
async function flash() {
    let file = document.getElementById('fw').files[0];
    if (!file) { log('No firmware file selected.'); return; }
    let fw, info = null, eraseAddresses = [];
    if (/\.hex$/i.test(file.name)) {
        try {
            const text = new TextDecoder().decode(await file.arrayBuffer());
            info = parseIntelHex(text);
            log('HEX parsed: segments=' + info.segmentsCount + ' base=0x' + info.baseAddress.toString(16).toUpperCase());
            for (let i=0;i<info.segments.length;i++) {
                const s = info.segments[i];
                log(`HEX segment ${i+1}: addr=0x${s.address.toString(16).toUpperCase().padStart(8,'0')} size=${s.data.length}`);
                eraseAddresses.push(s.address);
            }
            if (info.hadGaps) log('HEX gaps detected; will pad gaps with 0xFF.');
            const padded = buildPaddedHexBuffer(info);
            log(`Padded image size=${padded.totalSize} filled=${padded.filledBytes} gapBytes=${padded.gapBytes}`);
            fw = padded.bytes;
        } catch (e) {
            log('HEX parse error: ' + e.message); return;
        }
    } else {
        const arrayBuf = await file.arrayBuffer();
        fw = new Uint8Array(arrayBuf);
        log('Using firmware: ' + file.name + ' (' + fw.length + ' bytes)');
        // For .bin, erase base address only
        eraseAddresses.push(0x08000000);
    }
    // UI option: try erase commands
    let blockNum = 0;
    const tryErase = document.getElementById('tryErase').checked;
    if (tryErase) {
        for (let i=0;i<eraseAddresses.length;i++) {
            const addr = eraseAddresses[i];
            // STM32 DFU erase command: 0x41 + 4-byte address (little-endian)
            const eraseCmd = new Uint8Array(5);
            eraseCmd[0] = 0x41;
            eraseCmd[1] = addr & 0xFF;
            eraseCmd[2] = (addr >> 8) & 0xFF;
            eraseCmd[3] = (addr >> 16) & 0xFF;
            eraseCmd[4] = (addr >> 24) & 0xFF;
            log(`Erasing segment ${i+1}/${eraseAddresses.length} at 0x${addr.toString(16).toUpperCase().padStart(8,'0')}`);
            try {
                await dnload(blockNum++, eraseCmd);
                await waitState(2);
            } catch (e) {
                log('Erase error: ' + e.message);
                log('Warning: Erase command failed. This is expected on STM32 ROM bootloader. Flash will continue.');
                break;
            }
        }
    } else {
        log('Erase step skipped (option unchecked).');
    }
    // Write firmware
    let offset = 0;
    const transferSize = 1024;
    while (offset < fw.length) {
        const chunkSize = Math.min(transferSize, fw.length - offset);
        const chunk = fw.slice(offset, offset + chunkSize);
        try {
            log('DNLOAD block ' + blockNum + ' size ' + chunkSize);
            await dnload(blockNum++, chunk);
        } catch (e) {
            log('DNLOAD error: ' + e.message);
            try { const s = await getStatus(); log('Status: ' + JSON.stringify(s)); } catch {}
            throw e;
        }
        const st = await getStatus();
        if (st.state === 5) await sleep(st.pollTimeout);
        await waitState(2);
        offset += chunkSize;
        updateProgress(offset/fw.length*100);
    }
    await dnload(blockNum, new Uint8Array());
    log('Manifesting...');
    await waitState(2);
    log('Flash complete.');
}
document.getElementById('connect').onclick = ()=>connect().catch(e=>log('Connect error: ' + e.message));
document.getElementById('flash').onclick = ()=>flash().catch(e=>log('Flash error: ' + e.message));
</script>
</body>
</html>
