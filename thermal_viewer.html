<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MLX9064x Thermal Viewer</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 10px;
        }

        h1 {
            font-size: 2rem;
            margin: 0;
        }

        .subtitle {
            opacity: 0.9;
            font-size: 0.9rem;
        }

        .library-version {
            font-size: 0.9rem;
            opacity: 0.85;
            text-align: right;
        }

        .library-version .version-label {
            font-size: 0.75rem;
            opacity: 0.7;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 300px 300px;
            gap: 20px;
            margin-bottom: 20px;
        }

        .panel {
            background: #2a2a2a;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .panel-title {
            font-size: 1.2rem;
            margin-bottom: 15px;
            color: #667eea;
            border-bottom: 2px solid #667eea;
            padding-bottom: 5px;
        }

        #visualizationPanel {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #thermalCanvas {
            background: #000;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.3);
            max-width: 100%;
            height: auto;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
            width: 100%;
        }

        .stat-box {
            background: #1a1a1a;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-label {
            font-size: 0.8rem;
            opacity: 0.7;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #667eea;
        }

        .stat-value.large {
            font-size: 2.5rem;
            color: #4ade80;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9rem;
            opacity: 0.8;
        }

        /* Slider styles */
        .slider-group label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }

        .slider-group label span {
            color: #4ade80;
            font-weight: 600;
            min-width: 60px;
            text-align: right;
        }

        .slider-group input[type="range"] {
            width: 100%;
            margin-top: 5px;
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 5px;
            border-radius: 5px;
            background: #1e293b;
            outline: none;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        input[type="range"]:hover {
            opacity: 1;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4ade80;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4ade80;
            cursor: pointer;
        }

        button {
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            border: none;
            border-radius: 6px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }

        button.primary {
            background: #667eea;
            color: white;
        }

        button.primary:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.4);
        }

        button.secondary {
            background: #4ade80;
            color: #1a1a1a;
        }

        button.secondary:hover {
            background: #3bc66e;
        }

        button.danger {
            background: #ef4444;
            color: white;
        }

        button.danger:hover {
            background: #dc2626;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        select, input[type="range"] {
            width: 100%;
            padding: 8px;
            border-radius: 6px;
            border: 1px solid #444;
            background: #1a1a1a;
            color: #e0e0e0;
            font-size: 0.9rem;
        }

        input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .range-value {
            display: inline-block;
            margin-left: 10px;
            font-weight: bold;
            color: #667eea;
        }

        .status {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.85rem;
            font-weight: 600;
        }

        .status.connected {
            background: #4ade80;
            color: #1a1a1a;
        }

        .status.disconnected {
            background: #ef4444;
            color: white;
        }

        .status.capturing {
            background: #f59e0b;
            color: #1a1a1a;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        #chartPanel {
            grid-column: 1 / -1;
        }

        #advancedPanel .control-group label {
            color: #a0a0a0;
        }

        #advancedPanel select {
            margin-bottom: 10px;
        }

        #chartCanvas {
            max-height: 250px;
        }

        .debug-panel {
            grid-column: 1 / -1;
            max-height: 300px;
            overflow-y: auto;
        }

        #debugOutput {
            width: 100%;
            min-height: 250px;
            background: #000;
            color: #0f0;
            padding: 10px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            white-space: pre-wrap;
            overflow-x: auto;
        }

        .recording-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        @media (max-width: 1200px) {
            .main-grid {
                grid-template-columns: 1fr;
            }

            #chartPanel {
                grid-column: 1;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h3>MLX9064x Thermal Viewer</h3>
            <div class="library-version">
                <div class="version-label">ISP Library</div>
                <div id="libraryVersion">--</div>
            </div>
        </header>

        <div class="main-grid">
            <!-- Visualization Panel -->
            <div class="panel" id="visualizationPanel">
                <!-- <h2 class="panel-title">Thermal Heatmap</h2> -->
                <canvas id="thermalCanvas" width="640" height="480"></canvas>
                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="stat-label">People Detected</div>
                        <div class="stat-value large" id="peopleCount">-</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Blobs</div>
                        <div class="stat-value large" id="blobCount">-</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Temperature Range</div>
                        <div class="stat-value" id="tempRange" style="font-size: 1rem;">-</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">ISP Time</div>
                        <div class="stat-value" id="processTime">-</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Frame Time (Total)</div>
                        <div class="stat-value" id="frameTime">-</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Actual FPS</div>
                        <div class="stat-value" id="actualFps">-</div>
                    </div>
                </div>
            </div>

            <!-- Control Panel -->
            <div class="panel" id="controlPanel">
                <h2 class="panel-title">Controls</h2>

                <!-- Connection -->
                <div class="control-group">
                    <button class="primary" id="connectionToggle" onclick="app.toggleConnection()">Connect</button>
                </div>

                <!-- Capture Controls -->
                <div class="control-group">
                    <button class="secondary" id="captureToggle" onclick="app.toggleCapture()" disabled>Start Capture</button>
                </div>

                <!-- Frame Rate -->
                <div class="control-group">
                    <label>Frame Rate: <span class="range-value" id="frameRateValue">4.0 Hz</span></label>
                    <input type="range" id="frameRateSlider" min="1.0" max="16.0" step="1.0" value="4"
                           oninput="app.updateFrameRate(this.value)">
                </div>

                <!-- Preset Configuration -->
                <div class="control-group">
                    <label>Preset Configuration</label>
                    <select id="presetSelect" onchange="app.applyPreset()">
                        <option value="OBLIQUE|SHORT|LOW">OBLIQUE + SHORT + LOW</option>
                        <option value="OBLIQUE|SHORT|HIGH">OBLIQUE + SHORT + HIGH</option>
                        <option value="OBLIQUE|TALL|LOW">OBLIQUE + TALL + LOW</option>
                        <option value="OBLIQUE|TALL|HIGH">OBLIQUE + TALL + HIGH</option>
                        <option value="VERTICAL|SHORT|LOW">VERTICAL + SHORT + LOW</option>
                        <option value="VERTICAL|SHORT|HIGH">VERTICAL + SHORT + HIGH</option>
                        <option value="VERTICAL|TALL|LOW">VERTICAL + TALL + LOW</option>
                        <option value="VERTICAL|TALL|HIGH">VERTICAL + TALL + HIGH</option>
                    </select>
                </div>

                <div class="control-group">
                    <div class="checkbox-group">
                        <input type="checkbox" id="coldDetection" onchange="app.applyPreset()">
                        <label for="coldDetection">Enable Cold Detection</label>
                    </div>
                </div>

                <div class="control-group">
                    <div class="checkbox-group">
                        <input type="checkbox" id="smoothHeatmap">
                        <label for="smoothHeatmap">Smooth Heatmap (Bilinear)</label>
                    </div>
                </div>

                <!-- Recording Controls -->
                <div class="control-group">
                    <label>Recording</label>
                    <div class="recording-controls">
                        <button onclick="app.startRecording()" id="recordBtn" disabled>Record</button>
                        <button onclick="app.stopRecording()" id="stopRecordBtn" disabled>Stop</button>
                        <button onclick="app.saveRecording()" id="saveRecordBtn" disabled>Save</button>
                    </div>
                </div>

                <!-- Frame Counter -->
                <div class="control-group">
                    <div class="stat-box">
                        <div class="stat-label">Frames Captured</div>
                        <div class="stat-value" id="frameCounter">0</div>
                    </div>
                </div>
            </div>

            <!-- Advanced Panel -->
            <div class="panel" id="advancedPanel">
                <h2 class="panel-title">Advanced</h2>

                <!-- Sensor Configuration -->
                <div class="control-group">
                    <label>Sensor Mode</label>
                    <select id="sensorMode">
                        <option value="CONTINUOUS">Continuous</option>
                        <option value="TRIGGER">Trigger/Step</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>Sensor Frame Rate</label>
                    <select id="sensorFps">
                        <option value="2">2 Hz</option>
                        <option value="3">4 Hz</option>
                        <option value="4" selected>8 Hz</option>
                        <option value="5">16 Hz</option>
                    </select>
                </div>

                <button class="primary" id="applySensorConfigBtn" onclick="app.applySensorConfig()" disabled>Apply Sensor Config</button>

                <div class="control-group" style="margin-top: 20px;">
                    <div class="stat-box">
                        <div class="stat-label">Sensor Status</div>
                        <div class="stat-value" id="sensorStatus" style="font-size: 0.9rem;">Not configured</div>
                    </div>
                </div>

                <!-- Runtime Parameters -->
                <div class="runtime-params-section" style="margin-top: 20px; border-top: 1px solid #444; padding-top: 15px;">
                    <h3 style="margin-bottom: 15px; color: #94a3b8;">Runtime Parameters</h3>

                    <!-- Detection Parameters -->
                    <div class="param-group">
                        <h4 style="color: #64748b; margin: 10px 0;">Detection</h4>

                        <div class="control-group slider-group">
                            <label>Footprint Size <span id="footprintValue">45</span> px</label>
                            <input type="range" id="footprintSlider" min="35" max="55" value="45" step="1"
                                   oninput="document.getElementById('footprintValue').textContent = this.value">
                        </div>

                        <div class="control-group slider-group">
                            <label>Min Blob Area <span id="minAreaValue">10</span> px</label>
                            <input type="range" id="minAreaSlider" min="5" max="100" value="10" step="1"
                                   oninput="document.getElementById('minAreaValue').textContent = this.value">
                        </div>

                        <div class="control-group slider-group">
                            <label>Lower Threshold <span id="thresholdLValue">1.0</span>x</label>
                            <input type="range" id="thresholdLSlider" min="128" max="1024" value="256" step="1"
                                   oninput="document.getElementById('thresholdLValue').textContent = (this.value/256).toFixed(2)">
                        </div>

                        <div class="control-group slider-group">
                            <label>Upper Threshold <span id="thresholdHValue">1.0</span>x</label>
                            <input type="range" id="thresholdHSlider" min="128" max="1024" value="256" step="1"
                                   oninput="document.getElementById('thresholdHValue').textContent = (this.value/256).toFixed(2)">
                        </div>
                    </div>

                    <!-- Temperature Range -->
                    <div class="param-group">
                        <h4 style="color: #64748b; margin: 10px 0;">Temperature Range</h4>

                        <div class="control-group slider-group">
                            <label>Min Temperature <span id="tempMinValue">20.0</span>°C</label>
                            <input type="range" id="tempMinSlider" min="0" max="1500" value="0" step="50"
                                   oninput="document.getElementById('tempMinValue').textContent = this.value == 0 ? '20.0' : (this.value/50).toFixed(1)">
                        </div>

                        <div class="control-group slider-group">
                            <label>Max Temperature <span id="tempMaxValue">40.0</span>°C</label>
                            <input type="range" id="tempMaxSlider" min="0" max="2500" value="0" step="50"
                                   oninput="document.getElementById('tempMaxValue').textContent = this.value == 0 ? '40.0' : (this.value/50).toFixed(1)">
                        </div>
                    </div>

                    <!-- LoG Processing (Advanced) -->
                    <div class="param-group">
                        <h4 style="color: #64748b; margin: 10px 0;">LoG Processing (Advanced)</h4>

                        <div class="control-group slider-group">
                            <label>Cold Gate <span id="logGateLValue">50</span> px</label>
                            <input type="range" id="logGateLSlider" min="5" max="500" value="50" step="5"
                                   oninput="document.getElementById('logGateLValue').textContent = this.value">
                        </div>

                        <div class="control-group slider-group">
                            <label>Hot Gate <span id="logGateHValue">5</span> px</label>
                            <input type="range" id="logGateHSlider" min="5" max="100" value="5" step="1"
                                   oninput="document.getElementById('logGateHValue').textContent = this.value">
                        </div>

                        <div class="control-group slider-group">
                            <label>Cold Percentile <span id="percentileLValue">0.50</span></label>
                            <input type="range" id="percentileLSlider" min="0" max="256" value="128" step="1"
                                   oninput="document.getElementById('percentileLValue').textContent = (this.value/256).toFixed(2)">
                        </div>

                        <div class="control-group slider-group">
                            <label>Hot Percentile <span id="percentileHValue">0.50</span></label>
                            <input type="range" id="percentileHSlider" min="0" max="256" value="128" step="1"
                                   oninput="document.getElementById('percentileHValue').textContent = (this.value/256).toFixed(2)">
                        </div>
                    </div>

                    <!-- Background Learning -->
                    <div class="param-group">
                        <h4 style="color: #64748b; margin: 10px 0;">Background Learning</h4>

                        <div class="control-group slider-group">
                            <label>gamma_ema: <span id="gammaEmaValue">0.10</span>× <span style="color: #64748b; font-size: 0.85em;"></span></label>
                            <input type="range" id="gammaEmaSlider" min="3" max="128" value="26" step="1"
                                   oninput="document.getElementById('gammaEmaValue').textContent = (this.value/256).toFixed(2)">
                        </div>
                    </div>

                    <button class="secondary" style="margin-top: 10px;" onclick="app.resetRuntimeParams()">Reset to Defaults</button>
                </div>

            </div>

            <!-- Chart Panel -->
            <div class="panel" id="chartPanel">
                <h2 class="panel-title">People Count History</h2>
                <canvas id="chartCanvas"></canvas>
            </div>

            <!-- Debug Panel -->
            <div class="panel debug-panel">
                <h2 class="panel-title">Debug Output</h2>
                <textarea id="debugOutput" readonly></textarea>
            </div>
        </div>
    </div>

    <script>
        'use strict';

        /**
         * SerialManager - Handles Web Serial API communication with device
         */
        class SerialManager {
            constructor() {
                this.port = null;
                this.reader = null;
                this.writer = null;
                this.connected = false;
            }

            /**
             * Check if Web Serial API is supported
             */
            isSupported() {
                return 'serial' in navigator;
            }

            /**
             * Check if currently connected to device
             */
            isConnected() {
                return this.connected;
            }

            /**
             * Request serial port from user
             * Auto-connects to MELEXISIO device if it's the only authorized port
             */
            async requestPort() {
                if (!this.isSupported()) {
                    throw new Error('Web Serial API not supported. Use Chrome or Edge browser.');
                }

                try {
                    // First, check if we have any previously authorized ports
                    const ports = await navigator.serial.getPorts();

                    // If exactly one port is authorized, check if it's MELEXISIO
                    if (ports.length === 1) {
                        const portInfo = ports[0].getInfo();
                        // Check for MELEXISIO device (look for productId in the device name)
                        // The device shows as "cu.usbmodemMELEXISIO1" on macOS
                        // We can't directly check the name, but if there's only one port, assume it's our device
                        console.log('Found single authorized port, auto-connecting...');
                        this.port = ports[0];
                        return this.port;
                    }

                    // If no authorized ports or multiple ports, show picker dialog
                    // Request ANY serial port (no filter)
                    // This shows all available ports in the picker dialog
                    this.port = await navigator.serial.requestPort();
                    return this.port;
                } catch (error) {
                    throw new Error(`Port selection failed: ${error.message}`);
                }
            }

            /**
             * Connect to serial port
             */
            async connect(baudRate = 921600) {
                if (!this.port) {
                    throw new Error('No port selected. Call requestPort() first.');
                }

                try {
                    await this.port.open({
                        baudRate: baudRate,
                        dataBits: 8,
                        stopBits: 1,
                        parity: 'none',
                        flowControl: 'none'
                    });

                    this.reader = this.port.readable.getReader();
                    this.writer = this.port.writable.getWriter();
                    this.connected = true;

                    console.log('Serial port connected:', baudRate, 'baud');

                    // Set DTR/RTS signals (some USB CDC devices need this to wake up)
                    try {
                        await this.port.setSignals({ dataTerminalReady: true, requestToSend: false });
                        console.log('DTR signal set to HIGH');
                    } catch (error) {
                        console.log('Note: Could not set DTR signal (this may be OK):', error.message);
                    }

                    // Delay for device to stabilize (USB CDC enumeration can be slow)
                    console.log('Waiting for device to stabilize...');
                    await new Promise(resolve => setTimeout(resolve, 500));

                    // Note: Minimal working test doesn't flush, let's skip it for now
                    // await this.flushInput(1000);
                    console.log('Skipping buffer flush to match working test pattern');
                } catch (error) {
                    throw new Error(`Connection failed: ${error.message}`);
                }
            }

            /**
             * Flush input buffer by reading and discarding data for a short time
             */
            async flushInput(timeMs = 1000) {
                const startTime = Date.now();
                const decoder = new TextDecoder();
                let bytesDiscarded = 0;

                console.log('Flushing input buffer for', timeMs, 'ms...');

                while (Date.now() - startTime < timeMs) {
                    try {
                        const readPromise = this.reader.read();
                        const timeoutPromise = new Promise((_, reject) =>
                            setTimeout(() => reject(new Error('timeout')), 100)
                        );

                        const result = await Promise.race([readPromise, timeoutPromise]);
                        if (!result.done && result.value) {
                            const text = decoder.decode(result.value);
                            bytesDiscarded += result.value.length;
                            console.log('Flushed:', text.substring(0, 80).replace(/\n/g, '\\n').replace(/\r/g, '\\r'));
                        }
                    } catch (error) {
                        // Timeout is expected when buffer is empty
                        if (error.message === 'timeout') {
                            console.log('Buffer empty (timeout after', Date.now() - startTime, 'ms)');
                            break;
                        } else {
                            console.error('Flush error:', error);
                        }
                    }
                }

                console.log('Input buffer flushed. Discarded', bytesDiscarded, 'bytes');
            }

            /**
             * Disconnect from serial port
             */
            async disconnect() {
                if (this.reader) {
                    await this.reader.cancel();
                    this.reader.releaseLock();
                    this.reader = null;
                }

                if (this.writer) {
                    this.writer.releaseLock();
                    this.writer = null;
                }

                if (this.port) {
                    await this.port.close();
                    this.port = null;
                }

                this.connected = false;
                console.log('Serial port disconnected');
            }

            /**
             * Send SCPI command and read response until prompt
             */
            async sendCommand(command, timeoutMs = 3000) {
                if (!this.connected) {
                    throw new Error('Not connected to device');
                }

                // Send command
                const cmdWithNewline = command.endsWith('\n') ? command : command + '\n';
                const encoder = new TextEncoder();
                const encoded = encoder.encode(cmdWithNewline);

                console.log('Sending command:', command, `(${encoded.length} bytes)`);
                await this.writer.write(encoded);
                console.log('Command sent, waiting for response...');

                // Read response until prompt
                const response = await this.readUntilPrompt(timeoutMs);
                return response;
            }

            /**
             * Test basic communication by sending newline and reading any response
             */
            async testCommunication(timeoutMs = 3000) {
                console.log('=== COMMUNICATION TEST ===');

                // Check port signals
                try {
                    const signals = await this.port.getSignals();
                    console.log('Port signals:', signals);
                } catch (error) {
                    console.warn('Could not read port signals:', error.message);
                }

                const encoder = new TextEncoder();
                const testData = encoder.encode('\r\n');

                console.log('Sending test command:', Array.from(testData).map(b => `0x${b.toString(16)}`).join(' '));

                try {
                    await this.writer.write(testData);
                    console.log('✓ Write completed successfully');
                } catch (error) {
                    console.error('✗ Write FAILED:', error);
                    return false;
                }

                // Try to flush writer (some implementations support this)
                try {
                    if (this.writer.ready) {
                        await this.writer.ready;
                        console.log('✓ Writer ready');
                    }
                } catch (error) {
                    console.log('Note: Writer ready check failed (may be OK):', error.message);
                }

                console.log('Waiting for ANY response (exact pattern from working test)...');
                const startTime = Date.now();
                const decoder = new TextDecoder();
                let receivedAny = false;

                // EXACT pattern from working minimal test
                for (let i = 0; i < 10; i++) {
                    try {
                        const { value, done } = await Promise.race([
                            this.reader.read(),
                            new Promise((_, reject) => setTimeout(() => reject('timeout'), 300))
                        ]);

                        if (value && value.length > 0) {
                            const text = decoder.decode(value);
                            console.log('✓ RECEIVED (attempt', i + ', bytes:', value.length + '):',
                                       text.replace(/\r/g, '\\r').replace(/\n/g, '\\n'));
                            console.log('✓ Raw bytes:', Array.from(value).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));
                            receivedAny = true;
                            break;
                        }

                        if (done) {
                            console.log('Stream ended (done=true)');
                            break;
                        }
                    } catch (e) {
                        // Timeout rejection - expected, continue
                        if (i % 3 === 0) {
                            console.log('  Waiting... attempt', i);
                        }
                    }
                }

                const elapsed = Date.now() - startTime;

                if (!receivedAny) {
                    console.error('✗ NO RESPONSE from device after 10 attempts (', elapsed, 'ms)!');
                    console.error('');
                    console.error('CRITICAL: Port is open but device is not responding.');
                    console.error('');
                    console.error('Most likely causes:');
                    console.error('  1. Another program has exclusive access (check below)');
                    console.error('  2. Device needs reset (press RESET button)');
                    console.error('  3. Chrome security restrictions');
                    console.error('');
                    console.error('Run this in Terminal to check for port locks:');
                    console.error('  lsof | grep cu.usbmodem');
                    console.error('');
                    console.error('If you see any processes, kill them and reconnect.');
                } else {
                    console.log('✓ Communication working!');
                }

                return receivedAny;
            }

            /**
             * Read lines from serial port until prompt is detected
             */
            async readUntilPrompt(timeoutMs = 3000) {
                // Match prompt: (OK)> or (ERROR)> or (E2BIG)> etc., with optional leading/trailing whitespace
                // Supports errno names (E2BIG, EINVAL, etc.) in addition to standard prompts
                const promptRegex = /\((OK|ERROR|BUSY|TIMEOUT|CRC|ERR:\d+|E[A-Z0-9]+)\)>/;
                const decoder = new TextDecoder();
                let buffer = '';
                let lines = [];
                const startTime = Date.now();
                let debugLineCount = 0;
                let chunkCount = 0;

                console.log('Reading until prompt... (timeout:', timeoutMs, 'ms)');

                while (true) {
                    // Check timeout
                    const elapsed = Date.now() - startTime;
                    if (elapsed > timeoutMs) {
                        console.error('TIMEOUT after', elapsed, 'ms. Received', lines.length, 'lines:');
                        lines.forEach((line, i) => console.log(`  Line ${i}: ${line.substring(0, 80)}`));
                        console.error('Remaining buffer:', buffer.substring(0, 100));
                        throw new Error('Command timeout: no prompt received');
                    }

                    // Read chunk (blocking read, no timeout race)
                    let chunk;
                    try {
                        const result = await this.reader.read();
                        if (result.done) {
                            throw new Error('Serial port closed unexpectedly');
                        }
                        chunk = result.value;
                    } catch (error) {
                        console.error('Read error:', error);
                        throw error;
                    }

                    if (!chunk || chunk.length === 0) {
                        // No data, wait a bit and try again
                        await new Promise(r => setTimeout(r, 50));
                        continue;
                    }

                    // Decode and buffer
                    const newData = decoder.decode(chunk, { stream: true });
                    buffer += newData;
                    chunkCount++;

                    // Debug: Show first few chunks
                    if (chunkCount <= 5) {
                        console.log('Chunk', chunkCount + ':',
                                   newData.substring(0, 80).replace(/\n/g, '\\n').replace(/\r/g, '\\r'),
                                   '(', chunk.length, 'bytes)');
                    }

                    // Extract complete lines (split on \n or \r\n)
                    const lineMatches = buffer.split(/\r?\n/);

                    // Keep last incomplete line in buffer
                    buffer = lineMatches.pop() || '';

                    for (const line of lineMatches) {
                        const trimmedLine = line.trim();
                        if (trimmedLine) {
                            lines.push(trimmedLine);
                            debugLineCount++;

                            // Debug: Show first few lines
                            if (debugLineCount <= 10) {
                                console.log(`Line ${debugLineCount}: "${trimmedLine}"`);
                            }

                            // Check for prompt (now checks anywhere in line)
                            if (promptRegex.test(trimmedLine)) {
                                console.log('✓ Prompt detected:', trimmedLine);
                                console.log('✓ Total lines received:', lines.length);
                                return lines.join('\n');
                            }
                        }
                    }

                    // Also check buffer for prompt (in case no newline after prompt)
                    if (promptRegex.test(buffer.trim())) {
                        console.log('✓ Prompt detected in buffer:', buffer.trim());
                        if (buffer.trim()) {
                            lines.push(buffer.trim());
                        }
                        console.log('✓ Total lines received:', lines.length);
                        return lines.join('\n');
                    }
                }
            }
        }

        /**
         * ThermalParser - Parses ONCE2 ASCII output into structured data
         */
        class ThermalParser {
            constructor() {
                this.frameWidth = 32;
                this.frameHeight = 24;
            }

            /**
             * Parse ONCE2 command output
             * Returns: {
             *   thermalFrame: [[int16]], // 24x32 array (digit 0-9)
             *   foregroundMask: [[bool]], // 24x32 array (true=detected)
             *   peopleCount: int,
             *   activityCount: int,
             *   blobCount: int,
             *   tempMin: float,
             *   tempMax: float,
             *   processingTime: float,
             *   scaleInfo: {minTemp, maxTemp} // For digit→temp mapping
             * }
             */
            parseONCE2(text) {
                // Check for error responses
                if (text.includes('[ERROR]') || text.includes('not initialized')) {
                    throw new Error('People detection not initialized or error response received');
                }

                const lines = text.split('\n');
                const result = {
                    thermalFrame: [],
                    foregroundMask: [],
                    peopleCount: 0,
                    activityCount: -1,
                    blobCount: 0,
                    tempMin: 0,
                    tempMax: 0,
                    processingTime: 0,
                    scaleInfo: { minTemp: 0, maxTemp: 0, minDigit: 0, maxDigit: 9 }
                };

                // Extract scale information
                const scaleMatch = text.match(/Scale: (\d)=([-\d.]+)°C.*?(\d)=([-\d.]+)°C/);
                if (scaleMatch) {
                    result.scaleInfo.minDigit = parseInt(scaleMatch[1]);
                    result.scaleInfo.minTemp = parseFloat(scaleMatch[2]);
                    result.scaleInfo.maxDigit = parseInt(scaleMatch[3]);
                    result.scaleInfo.maxTemp = parseFloat(scaleMatch[4]);
                }

                // Extract thermal frame rows (format: "NN: digit+ digit digit+ ...")
                // NOTE: Firmware outputs foreground clusters without spaces: "6+6+5+5+" not "6+ 6+ 5+ 5+"
                const rowRegex = /(\d{2}):\s+([\d+\s]+)/;
                for (const line of lines) {
                    const match = line.match(rowRegex);
                    if (match) {
                        const rowNum = parseInt(match[1]);
                        const rowData = match[2];

                        // Parse pixels: handle both "6+ 7+" (with spaces) and "6+7+" (without spaces)
                        // Strategy: Split by spaces, then further split any tokens containing '+' signs
                        const tokens = rowData.trim().split(/\s+/);
                        const thermalRow = [];
                        const maskRow = [];

                        for (const token of tokens) {
                            if (token.includes('+')) {
                                // Token contains foreground markers: split on '+' and process each digit
                                // "6+7+8+" -> ["6", "7", "8", ""]
                                // "6+7+8" -> ["6", "7", "8"]
                                const parts = token.split('+').filter(p => p !== '');
                                for (const part of parts) {
                                    const digit = parseInt(part);
                                    if (!isNaN(digit)) {
                                        thermalRow.push(digit);
                                        maskRow.push(true);  // Foreground

                                        // Debug first few foreground detections
                                        if (result.foregroundMask.length === 0) {
                                            console.log(`Found foreground at row ${rowNum}, token: "${token}" -> digit: ${digit}`);
                                        }
                                    }
                                }
                            } else {
                                // Background pixel (no '+')
                                const digit = parseInt(token);
                                if (!isNaN(digit)) {
                                    thermalRow.push(digit);
                                    maskRow.push(false);
                                }
                            }
                        }

                        result.thermalFrame.push(thermalRow);
                        result.foregroundMask.push(maskRow);
                    }
                }

                // Extract summary line
                // Format 1: "People: N (M) | Blobs: B | Temp: min-max°C | Time: Tms"
                // Format 2: "People: N | Blobs: B | Temp: min-max°C | Time: Tms"
                const summaryMatch = text.match(/People:\s+(\d+)(?:\s+\((\d+)\))?\s+\|\s+Blobs:\s+(\d+)\s+\|\s+Temp:\s+([-\d.]+)-([-\d.]+)°C\s+\|\s+Time:\s+([\d.]+)ms/);
                if (summaryMatch) {
                    result.peopleCount = parseInt(summaryMatch[1]);
                    result.activityCount = summaryMatch[2] ? parseInt(summaryMatch[2]) : -1;
                    result.blobCount = parseInt(summaryMatch[3]);
                    result.tempMin = parseFloat(summaryMatch[4]);
                    result.tempMax = parseFloat(summaryMatch[5]);
                    result.processingTime = parseFloat(summaryMatch[6]);
                }

                return result;
            }

            /**
             * Map digit (0-9) to actual temperature using scale info
             */
            digitToTemp(digit, scaleInfo) {
                const { minTemp, maxTemp, minDigit, maxDigit } = scaleInfo;
                const range = maxTemp - minTemp;
                const digitRange = maxDigit - minDigit;
                return minTemp + (digit - minDigit) * (range / digitRange);
            }
        }

        /**
         * HeatmapRenderer - Renders thermal data as color-coded canvas
         */
        class HeatmapRenderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.pixelSize = 20;  // Each thermal pixel = 20x20 screen pixels
                this.smoothingEnabled = true;  // Default to smooth rendering
            }

            /**
             * Get color for temperature value (0.0 to 1.0 normalized)
             */
            getColor(normalized) {
                // Blue → Cyan → Green → Yellow → Red gradient
                if (normalized < 0) normalized = 0;
                if (normalized > 1) normalized = 1;

                if (normalized < 0.25) {
                    // Blue to Cyan
                    const t = normalized / 0.25;
                    return `rgb(0, ${Math.floor(t * 255)}, 255)`;
                } else if (normalized < 0.5) {
                    // Cyan to Green
                    const t = (normalized - 0.25) / 0.25;
                    return `rgb(0, 255, ${Math.floor((1-t) * 255)})`;
                } else if (normalized < 0.75) {
                    // Green to Yellow
                    const t = (normalized - 0.5) / 0.25;
                    return `rgb(${Math.floor(t * 255)}, 255, 0)`;
                } else {
                    // Yellow to Red
                    const t = (normalized - 0.75) / 0.25;
                    return `rgb(255, ${Math.floor((1-t) * 255)}, 0)`;
                }
            }

            /**
             * Enable or disable smoothing
             */
            setSmoothing(enabled) {
                this.smoothingEnabled = enabled;
            }

            /**
             * Bilinear interpolation helper
             */
            bilinearInterpolate(x, y, thermalFrame, minDigit, digitRange) {
                // Get the four surrounding pixel values
                const x0 = Math.floor(x);
                const x1 = Math.min(x0 + 1, thermalFrame[0].length - 1);
                const y0 = Math.floor(y);
                const y1 = Math.min(y0 + 1, thermalFrame.length - 1);

                // Get normalized values for the four corners
                const getVal = (yi, xi) => {
                    if (!thermalFrame[yi] || thermalFrame[yi][xi] === undefined ||
                        isNaN(thermalFrame[yi][xi]) || thermalFrame[yi][xi] === null) {
                        return 0; // Default for invalid data
                    }
                    return (thermalFrame[yi][xi] - minDigit) / digitRange;
                };

                const q11 = getVal(y0, x0);
                const q21 = getVal(y0, x1);
                const q12 = getVal(y1, x0);
                const q22 = getVal(y1, x1);

                // Fractional parts
                const fx = x - x0;
                const fy = y - y0;

                // Bilinear interpolation
                const value = q11 * (1 - fx) * (1 - fy) +
                             q21 * fx * (1 - fy) +
                             q12 * (1 - fx) * fy +
                             q22 * fx * fy;

                return value;
            }

            /**
             * Render thermal heatmap
             */
            render(thermalFrame, scaleInfo) {
                // Validate input data
                if (!thermalFrame || thermalFrame.length === 0 || !thermalFrame[0]) {
                    console.warn('Invalid thermal frame data - skipping render');
                    // Clear canvas to black
                    this.ctx.fillStyle = '#000';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    return;
                }

                const { minDigit, maxDigit } = scaleInfo;
                const digitRange = maxDigit - minDigit || 1; // Avoid division by zero

                // Clear canvas
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                if (this.smoothingEnabled) {
                    // Smooth rendering with bilinear interpolation
                    const imageData = this.ctx.createImageData(this.canvas.width, this.canvas.height);
                    const data = imageData.data;

                    for (let py = 0; py < this.canvas.height; py++) {
                        for (let px = 0; px < this.canvas.width; px++) {
                            // Map pixel coordinates to thermal frame coordinates
                            const tx = (px / this.pixelSize);
                            const ty = (py / this.pixelSize);

                            // Skip if outside thermal frame bounds
                            if (tx >= thermalFrame[0].length || ty >= thermalFrame.length) {
                                continue;
                            }

                            // Get interpolated value
                            const normalized = this.bilinearInterpolate(tx, ty, thermalFrame, minDigit, digitRange);

                            // Get color for this value
                            const color = this.getColor(normalized);

                            // Parse RGB values from color string
                            const matches = color.match(/\d+/g);
                            if (matches && matches.length >= 3) {
                                const idx = (py * this.canvas.width + px) * 4;
                                data[idx] = parseInt(matches[0]);     // R
                                data[idx + 1] = parseInt(matches[1]); // G
                                data[idx + 2] = parseInt(matches[2]); // B
                                data[idx + 3] = 255;                  // A
                            }
                        }
                    }

                    this.ctx.putImageData(imageData, 0, 0);
                } else {
                    // Original pixelated rendering
                    for (let y = 0; y < thermalFrame.length; y++) {
                        for (let x = 0; x < thermalFrame[y].length; x++) {
                            // Handle missing data or invalid values
                            if (!thermalFrame[y] || thermalFrame[y][x] === undefined) {
                                // Gray for missing data
                                this.ctx.fillStyle = '#333';
                                this.ctx.fillRect(
                                    x * this.pixelSize,
                                    y * this.pixelSize,
                                    this.pixelSize,
                                    this.pixelSize
                                );
                                continue;
                            }

                            const digit = thermalFrame[y][x];

                            // Validate digit is a number
                            if (isNaN(digit) || digit === null) {
                                this.ctx.fillStyle = '#333';
                                this.ctx.fillRect(
                                    x * this.pixelSize,
                                    y * this.pixelSize,
                                    this.pixelSize,
                                    this.pixelSize
                                );
                                continue;
                            }

                            const normalized = (digit - minDigit) / digitRange;
                            const color = this.getColor(normalized);

                            this.ctx.fillStyle = color;
                            this.ctx.fillRect(
                                x * this.pixelSize,
                                y * this.pixelSize,
                                this.pixelSize,
                                this.pixelSize
                            );
                        }
                    }
                }
            }
        }

        /**
         * BlobOverlay - Draws blob overlays (foreground, boxes, centroids)
         */
        class BlobOverlay {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.pixelSize = 20;
            }

            /**
             * Get color for blob index (cycle through palette)
             */
            getBlobColor(index, alpha = 0.6) {
                const colors = [
                    [0, 255, 136],    // Neon green
                    [255, 0, 102],    // Neon pink
                    [0, 204, 255],    // Cyan
                    [255, 187, 0],    // Amber
                    [153, 102, 255],  // Purple
                    [255, 102, 0],    // Orange
                    [102, 255, 102],  // Light green
                    [255, 102, 178],  // Pink
                    [102, 178, 255],  // Light blue
                    [255, 255, 102]   // Yellow
                ];
                const [r, g, b] = colors[index % colors.length];
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            }

            /**
             * Render simple foreground overlay (uniform color for all detected pixels)
             */
            renderForegroundOverlay(foregroundMask) {
                // Validate input
                if (!foregroundMask || foregroundMask.length === 0) {
                    return;
                }

                // Simple semi-transparent overlay for all foreground pixels
                this.ctx.fillStyle = 'rgba(255, 255, 0, 0.25)';  // Light yellow

                for (let y = 0; y < foregroundMask.length; y++) {
                    if (!foregroundMask[y]) continue;
                    for (let x = 0; x < foregroundMask[y].length; x++) {
                        if (foregroundMask[y][x]) {
                            this.ctx.fillRect(
                                x * this.pixelSize,
                                y * this.pixelSize,
                                this.pixelSize,
                                this.pixelSize
                            );
                        }
                    }
                }
            }

            /**
             * Calculate bounding boxes for connected foreground regions
             */
            calculateBoundingBoxes(foregroundMask) {
                const height = foregroundMask.length;
                const width = foregroundMask[0].length;
                const visited = Array(height).fill().map(() => Array(width).fill(false));
                const boxes = [];

                // Flood fill to find connected components
                const floodFill = (startY, startX) => {
                    const stack = [[startY, startX]];
                    let minX = width, maxX = 0, minY = height, maxY = 0;
                    let pixelCount = 0;
                    let sumX = 0, sumY = 0;

                    while (stack.length > 0) {
                        const [y, x] = stack.pop();

                        if (y < 0 || y >= height || x < 0 || x >= width) continue;
                        if (visited[y][x] || !foregroundMask[y][x]) continue;

                        visited[y][x] = true;
                        minX = Math.min(minX, x);
                        maxX = Math.max(maxX, x);
                        minY = Math.min(minY, y);
                        maxY = Math.max(maxY, y);
                        pixelCount++;
                        sumX += x;
                        sumY += y;

                        // Check 4-connected neighbors
                        stack.push([y-1, x], [y+1, x], [y, x-1], [y, x+1]);
                    }

                    return {
                        minX, maxX, minY, maxY,
                        centroidX: sumX / pixelCount,
                        centroidY: sumY / pixelCount,
                        area: pixelCount
                    };
                };

                // Find all connected components
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        if (foregroundMask[y][x] && !visited[y][x]) {
                            const box = floodFill(y, x);
                            if (box.area >= 5) {  // Filter small noise blobs
                                boxes.push(box);
                            }
                        }
                    }
                }

                return boxes;
            }

            /**
             * Draw contour around a blob mask
             */
            drawBlobContour(foregroundMask, blobLabels, blobId, color) {
                const height = foregroundMask.length;
                const width = foregroundMask[0].length;

                // For each pixel in the blob, draw borders on edges that face background
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        if (blobLabels[y][x] === blobId) {
                            const px = x * this.pixelSize;
                            const py = y * this.pixelSize;

                            // Check each side and draw border if it faces background
                            // Top edge
                            if (y === 0 || blobLabels[y-1][x] !== blobId) {
                                this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                                this.ctx.lineWidth = 4;
                                this.ctx.beginPath();
                                this.ctx.moveTo(px, py);
                                this.ctx.lineTo(px + this.pixelSize, py);
                                this.ctx.stroke();

                                this.ctx.strokeStyle = color;
                                this.ctx.lineWidth = 3;
                                this.ctx.beginPath();
                                this.ctx.moveTo(px, py);
                                this.ctx.lineTo(px + this.pixelSize, py);
                                this.ctx.stroke();
                            }
                            // Bottom edge
                            if (y === height - 1 || blobLabels[y+1][x] !== blobId) {
                                this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                                this.ctx.lineWidth = 4;
                                this.ctx.beginPath();
                                this.ctx.moveTo(px, py + this.pixelSize);
                                this.ctx.lineTo(px + this.pixelSize, py + this.pixelSize);
                                this.ctx.stroke();

                                this.ctx.strokeStyle = color;
                                this.ctx.lineWidth = 3;
                                this.ctx.beginPath();
                                this.ctx.moveTo(px, py + this.pixelSize);
                                this.ctx.lineTo(px + this.pixelSize, py + this.pixelSize);
                                this.ctx.stroke();
                            }
                            // Left edge
                            if (x === 0 || blobLabels[y][x-1] !== blobId) {
                                this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                                this.ctx.lineWidth = 4;
                                this.ctx.beginPath();
                                this.ctx.moveTo(px, py);
                                this.ctx.lineTo(px, py + this.pixelSize);
                                this.ctx.stroke();

                                this.ctx.strokeStyle = color;
                                this.ctx.lineWidth = 3;
                                this.ctx.beginPath();
                                this.ctx.moveTo(px, py);
                                this.ctx.lineTo(px, py + this.pixelSize);
                                this.ctx.stroke();
                            }
                            // Right edge
                            if (x === width - 1 || blobLabels[y][x+1] !== blobId) {
                                this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                                this.ctx.lineWidth = 4;
                                this.ctx.beginPath();
                                this.ctx.moveTo(px + this.pixelSize, py);
                                this.ctx.lineTo(px + this.pixelSize, py + this.pixelSize);
                                this.ctx.stroke();

                                this.ctx.strokeStyle = color;
                                this.ctx.lineWidth = 3;
                                this.ctx.beginPath();
                                this.ctx.moveTo(px + this.pixelSize, py);
                                this.ctx.lineTo(px + this.pixelSize, py + this.pixelSize);
                                this.ctx.stroke();
                            }
                        }
                    }
                }
            }

            /**
             * Render blob contours and labels (color-coded per blob)
             */
            renderBlobs(foregroundMask, peopleCount) {
                // Validate input
                if (!foregroundMask || foregroundMask.length === 0) {
                    return;
                }

                const boxes = this.calculateBoundingBoxes(foregroundMask);
                if (boxes.length === 0) return;

                // Build blob labels array (same as in renderPerBlobForeground)
                const height = foregroundMask.length;
                const width = foregroundMask[0].length;
                const blobLabels = Array(height).fill().map(() => Array(width).fill(-1));
                const visited = Array(height).fill().map(() => Array(width).fill(false));
                let blobIndex = 0;

                // Flood fill to assign blob IDs
                const floodFill = (startY, startX, id) => {
                    const stack = [[startY, startX]];
                    while (stack.length > 0) {
                        const [y, x] = stack.pop();
                        if (y < 0 || y >= height || x < 0 || x >= width) continue;
                        if (visited[y][x] || !foregroundMask[y][x]) continue;
                        visited[y][x] = true;
                        blobLabels[y][x] = id;
                        stack.push([y-1, x], [y+1, x], [y, x-1], [y, x+1]);
                    }
                };

                // Find all blobs
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        if (foregroundMask[y][x] && !visited[y][x]) {
                            floodFill(y, x, blobIndex);
                            blobIndex++;
                        }
                    }
                }

                // Draw contours and annotations for each blob
                boxes.forEach((box, index) => {
                    // Get blob-specific color
                    const blobColor = this.getBlobColor(index, 1.0);

                    // Draw contour (outline of blob mask)
                    this.drawBlobContour(foregroundMask, blobLabels, index, blobColor);

                    // Draw centroid crosshair
                    const cx = box.centroidX * this.pixelSize + this.pixelSize / 2;
                    const cy = box.centroidY * this.pixelSize + this.pixelSize / 2;
                    const crossSize = 12;

                    // Crosshair shadow
                    this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                    this.ctx.lineWidth = 4;
                    this.ctx.beginPath();
                    this.ctx.moveTo(cx - crossSize, cy);
                    this.ctx.lineTo(cx + crossSize, cy);
                    this.ctx.moveTo(cx, cy - crossSize);
                    this.ctx.lineTo(cx, cy + crossSize);
                    this.ctx.stroke();

                    // Crosshair main (blob-specific color)
                    this.ctx.strokeStyle = blobColor;
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.moveTo(cx - crossSize, cy);
                    this.ctx.lineTo(cx + crossSize, cy);
                    this.ctx.moveTo(cx, cy - crossSize);
                    this.ctx.lineTo(cx, cy + crossSize);
                    this.ctx.stroke();

                    // Draw label with background (just show blob number)
                    const x = box.minX * this.pixelSize;
                    const y = box.minY * this.pixelSize;
                    const label = `${index + 1}`;
                    this.ctx.font = 'bold 14px sans-serif';
                    const textWidth = this.ctx.measureText(label).width;

                    // Label background
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    this.ctx.fillRect(x + 4, y + 4, textWidth + 8, 20);

                    // Label border (blob-specific color)
                    this.ctx.strokeStyle = blobColor;
                    this.ctx.lineWidth = 1.5;
                    this.ctx.strokeRect(x + 4, y + 4, textWidth + 8, 20);

                    // Label text (blob-specific color)
                    this.ctx.fillStyle = blobColor;
                    this.ctx.fillText(label, x + 8, y + 18);
                });
            }
        }

        /**
         * Main Application Class
         */
        class ThermalViewerApp {
            constructor() {
                this.serialManager = new SerialManager();
                this.thermalParser = new ThermalParser();
                this.canvas = document.getElementById('thermalCanvas');
                this.heatmapRenderer = new HeatmapRenderer(this.canvas);
                this.blobOverlay = new BlobOverlay(this.canvas);

                this.capturing = false;
                this.frameRate = 4.0;
                this.captureInterval = null;
                this.frameCount = 0;
                this.captureInProgress = false;  // Prevent overlapping requests

                // Timing metrics
                this.lastFrameStartTime = 0;
                this.lastFrameDuration = 0;
                this.avgFrameDuration = 0;
                this.frameTimeSamples = [];
                this.maxFrameTimeSamples = 10;

                // Chart setup
                this.chart = null;
                this.peopleHistory = [];
                this.frameHistory = [];
                this.maxHistoryLength = 60;

                // Recording
                this.recording = false;
                this.recordedFrames = [];

                this.initChart();
                this.log('Application initialized. Click "Connect Device" to begin.');
            }

            /**
             * Initialize Chart.js time-series chart
             */
            initChart() {
                const ctx = document.getElementById('chartCanvas').getContext('2d');
                this.chart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'People Count',
                            data: [],
                            borderColor: '#4ade80',
                            backgroundColor: 'rgba(74, 222, 128, 0.1)',
                            borderWidth: 2,
                            tension: 0.4,
                            fill: true
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: { stepSize: 1, color: '#e0e0e0' },
                                grid: { color: '#444' }
                            },
                            x: {
                                ticks: { color: '#e0e0e0' },
                                grid: { color: '#444' }
                            }
                        },
                        plugins: {
                            legend: {
                                labels: { color: '#e0e0e0' }
                            }
                        }
                    }
                });
            }

            /**
             * Update chart with new data point
             */
            updateChart(frameNum, peopleCount) {
                this.frameHistory.push(frameNum);
                this.peopleHistory.push(peopleCount);

                // Keep only last N frames
                if (this.frameHistory.length > this.maxHistoryLength) {
                    this.frameHistory.shift();
                    this.peopleHistory.shift();
                }

                this.chart.data.labels = this.frameHistory;
                this.chart.data.datasets[0].data = this.peopleHistory;
                this.chart.update('none');  // Skip animation for performance
            }

            /**
             * Connect to device
             */
            async connect() {
                try {
                    this.log('Requesting serial port...');
                    await this.serialManager.requestPort();

                    this.log('Connecting at 921600 baud...');
                    await this.serialManager.connect(921600);

                    this.log('Testing basic communication...');
                    const commWorking = await this.serialManager.testCommunication(2000);
                    if (!commWorking) {
                        this.log('ERROR: Device not responding!');
                        this.log('Try these fixes:');
                        this.log('  1. Press RESET button on device');
                        this.log('  2. Disconnect USB cable, wait 3 seconds, reconnect');
                        this.log('  3. Close this page, re-flash firmware, reopen page');
                        throw new Error('Device not responding to commands');
                    }

                    this.log('Communication OK! Testing device responsiveness...');

                    // Send a simple command first to ensure device is responsive
                    try {
                        const versionResponse = await this.serialManager.sendCommand(':SYSTem:VERsion?', 2000);
                        this.log('Device version check:\n' + versionResponse);
                    } catch (error) {
                        this.log('Note: Version check failed (this is OK if firmware doesn\'t support it)');
                        console.log('Version check error:', error.message);
                    }

                    // Query ISP library version (using new short command)
                    try {
                        const buildInfoResponse = await this.serialManager.sendCommand(':PeopleDetection:VERSION?', 2000);
                        this.log('ISP library build info:\n' + buildInfoResponse);

                        // Extract version from response (look for "Version X.Y.Z" pattern)
                        const lines = buildInfoResponse.split('\n');
                        for (const line of lines) {
                            // Match pattern: "[INFO] [isp] Version 0.1.1 | ..."
                            const versionMatch = line.match(/Version\s+(\d+\.\d+\.\d+)/);
                            if (versionMatch) {
                                const version = versionMatch[1];
                                document.getElementById('libraryVersion').textContent = 'v' + version;
                                break;
                            }
                        }
                    } catch (error) {
                        this.log('Note: Could not get library version');
                        document.getElementById('libraryVersion').textContent = 'Unknown';
                    }

                    this.log('Initializing people detection...');

                    // Try DEINIT first in case previous session left it initialized
                    try {
                        this.log('Attempting DEINIT (cleanup from previous session)...');
                        await this.serialManager.sendCommand(':PeopleDetection:DEINIT', 3000);
                        this.log('Previous session cleaned up.');
                    } catch (error) {
                        this.log('DEINIT not needed (OK if not initialized)');
                        console.log('DEINIT error:', error.message);
                    }

                    // Now send INIT command
                    this.log('Sending INIT command...');
                    const initResponse = await this.serialManager.sendCommand(':PeopleDetection:INIT', 10000);
                    this.log('INIT response:\n' + initResponse);

                    // Get sensor configuration status
                    try {
                        const sensorResponse = await this.serialManager.sendCommand(':SENSOR:STATUS?', 2000);
                        this.log('Sensor status:\n' + sensorResponse);

                        // Parse the response to extract mode and frame rate
                        const lines = sensorResponse.split('\n');
                        let mode = 'Unknown';
                        let rate = 'Unknown';

                        for (const line of lines) {
                            if (line.includes('[INFO] MODE:')) {
                                mode = line.split('MODE:')[1].trim();
                            } else if (line.includes('[INFO] RATE:')) {
                                rate = line.split('RATE:')[1].trim();
                            }
                        }

                        // Update sensor status display
                        const statusElement = document.getElementById('sensorStatus');
                        if (mode !== 'Unknown' && rate !== 'Unknown') {
                            statusElement.textContent = `${mode}, ${rate}`;
                            statusElement.style.color = '#00ff88';
                        } else {
                            statusElement.textContent = 'Not configured';
                            statusElement.style.color = '#ff8800';
                        }
                    } catch (error) {
                        this.log('Note: Could not get sensor status (OK if firmware not updated)');
                        document.getElementById('sensorStatus').textContent = 'Unknown';
                        document.getElementById('sensorStatus').style.color = '#a0a0a0';
                    }

                    // Update UI
                    this.updateConnectionState(true);
                    this.log('Ready to capture. Click "Start Capture".');
                } catch (error) {
                    this.log('ERROR: ' + error.message);
                    this.log('Check Console (F12) for detailed debug output');
                    console.error('Connection error:', error);
                }
            }

            /**
             * Disconnect from device
             */
            async disconnect() {
                try {
                    if (this.capturing) {
                        this.stopCapture();
                    }

                    this.log('Sending DEINIT...');
                    await this.serialManager.sendCommand(':PeopleDetection:DEINIT', 5000);

                    this.log('Disconnecting...');
                    await this.serialManager.disconnect();

                    this.updateConnectionState(false);

                    // Reset library version display
                    document.getElementById('libraryVersion').textContent = '--';

                    this.log('Disconnected.');
                } catch (error) {
                    this.log('ERROR: ' + error.message);
                    console.error(error);
                }
            }

            /**
             * Start continuous capture
             */
            async startCapture() {
                if (this.capturing) return;

                // First check system status to see if we're already initialized
                this.log('Checking People Detection status...');
                try {
                    const statusResponse = await this.serialManager.sendCommand(':PeopleDetection:STATUS?', 2000);
                    const isInitialized = statusResponse.includes('PD initialized: YES');

                    if (!isInitialized) {
                        this.log('People Detection not initialized. Initializing...');
                        const initResponse = await this.serialManager.sendCommand(':PeopleDetection:INIT', 10000);

                        // Check for memory errors first
                        if (initResponse.includes('(ENOMEM)>')) {
                            this.log('❌ ERROR: Out of memory! Failed to allocate buffers.');
                            this.log('');
                            this.log('📌 Solution: Reset the device to clear memory fragmentation:');
                            this.log('   1. Unplug the USB cable');
                            this.log('   2. Wait 3 seconds');
                            this.log('   3. Reconnect the USB cable');
                            this.log('   4. Reconnect in the web interface');
                            this.log('   5. Try "Start Capture" again');
                            this.log('');
                            this.log('If the problem persists after reset, try reducing max_blobs or other parameters.');
                            return;
                        }

                        if (initResponse.includes('[ERROR]') || initResponse.includes('(ERROR)>') ||
                            initResponse.includes('(E2BIG)>')) {
                            this.log('❌ ERROR: Initialization failed!');
                            this.log('Response: ' + initResponse);
                            return;
                        }

                        // MUST have (OK)> prompt to be successful
                        if (!initResponse.includes('(OK)>')) {
                            this.log('❌ ERROR: Initialization did not complete successfully');
                            this.log('Expected (OK)> prompt but got: ' + initResponse.slice(-20));
                            return;
                        }

                        // Check if already initialized (firmware will say so)
                        if (initResponse.includes('already initialized')) {
                            this.log('People Detection was already initialized');
                        } else {
                            this.log('✓ People Detection initialized successfully');

                            // Apply saved runtime parameters after initialization
                            const saved = localStorage.getItem('runtimeParams');
                            if (saved) {
                                this.log('Restoring saved runtime parameters...');
                                const params = JSON.parse(saved);

                                // Apply each saved parameter
                                if (params.footprint) await this.updateRuntimeParam(':PeopleDetection:TUNE:FOOTPRINT', params.footprint);
                                if (params.minArea) await this.updateRuntimeParam(':PeopleDetection:TUNE:MINAREA', params.minArea);
                                if (params.thresholdL) await this.updateRuntimeParam(':PeopleDetection:TUNE:THRESHOLD:LOWER', params.thresholdL);
                                if (params.thresholdH) await this.updateRuntimeParam(':PeopleDetection:TUNE:THRESHOLD:UPPER', params.thresholdH);
                                if (params.tempMin) await this.updateRuntimeParam(':PeopleDetection:TUNE:TEMP:MIN', params.tempMin);
                                if (params.tempMax) await this.updateRuntimeParam(':PeopleDetection:TUNE:TEMP:MAX', params.tempMax);
                                if (params.logGateL) await this.updateRuntimeParam(':PeopleDetection:TUNE:GATE:COLD', params.logGateL);
                                if (params.logGateH) await this.updateRuntimeParam(':PeopleDetection:TUNE:GATE:HOT', params.logGateH);
                                if (params.percentileL) await this.updateRuntimeParam(':PeopleDetection:TUNE:PERCENTILE:COLD', params.percentileL);
                                if (params.percentileH) await this.updateRuntimeParam(':PeopleDetection:TUNE:PERCENTILE:HOT', params.percentileH);
                                if (params.gammaEma) await this.updateRuntimeParam(':PeopleDetection:TUNE:LEARNING', params.gammaEma);

                                this.log('Runtime parameters restored');
                            }
                        }
                    } else {
                        this.log('People Detection already initialized');
                    }
                } catch (error) {
                    this.log('ERROR: Failed to initialize People Detection: ' + error.message);
                    this.log('Cannot start capture without initialization');
                    return;
                }

                this.capturing = true;
                this.frameCount = 0;
                this.updateCaptureState(true);
                this.log('Capture started at ' + this.frameRate + ' Hz');

                // Start capture loop
                this.captureInterval = setInterval(() => {
                    this.captureFrame();
                }, 1000 / this.frameRate);
            }

            /**
             * Stop continuous capture
             */
            stopCapture() {
                if (!this.capturing) return;

                this.capturing = false;
                if (this.captureInterval) {
                    clearInterval(this.captureInterval);
                    this.captureInterval = null;
                }
                this.updateCaptureState(false);
                this.log('Capture stopped. Total frames: ' + this.frameCount);
            }

            /**
             * Capture single frame
             */
            async captureFrame() {
                // Skip if previous frame still processing (prevent overlap at high frame rates)
                if (this.captureInProgress) {
                    console.warn('Frame capture still in progress, skipping...');
                    return;
                }

                this.captureInProgress = true;
                const frameStartTime = performance.now();

                try {
                    // Send CAPTURE command (plus style = 0) - using new short command name
                    const response = await this.serialManager.sendCommand(':PeopleDetection:CAPTURE 0', 2000);

                    // Parse response (will throw if error response)
                    const data = this.thermalParser.parseONCE2(response);

                    // Debug: Check parsed data
                    console.log('Parsed data:', {
                        thermalRows: data.thermalFrame.length,
                        foregroundRows: data.foregroundMask.length,
                        peopleCount: data.peopleCount,
                        blobCount: data.blobCount,
                        firstRow: data.thermalFrame[0]?.length,
                        firstForeground: data.foregroundMask[0]?.length,
                        sampleForeground: data.foregroundMask[15]?.slice(0, 10)
                    });

                    // Check smoothing checkbox and apply
                    const smoothingEnabled = document.getElementById('smoothHeatmap').checked;
                    this.heatmapRenderer.setSmoothing(smoothingEnabled);

                    // Render heatmap
                    this.heatmapRenderer.render(data.thermalFrame, data.scaleInfo);

                    // Render simple foreground overlay (uniform yellow)
                    this.blobOverlay.renderForegroundOverlay(data.foregroundMask);

                    // Render per-blob contours (each blob gets unique color)
                    this.blobOverlay.renderBlobs(data.foregroundMask, data.peopleCount);

                    // Update stats
                    this.updateStats(data);
                    this.frameCount++;
                    document.getElementById('frameCounter').textContent = this.frameCount;

                    // Update chart
                    this.updateChart(this.frameCount, data.peopleCount);

                    // Recording
                    if (this.recording) {
                        this.recordedFrames.push({
                            frameNum: this.frameCount,
                            timestamp: Date.now(),
                            data: data
                        });
                    }

                    // Calculate timing metrics
                    const frameEndTime = performance.now();
                    const frameDuration = frameEndTime - frameStartTime;
                    this.lastFrameDuration = frameDuration;

                    // Update rolling average
                    this.frameTimeSamples.push(frameDuration);
                    if (this.frameTimeSamples.length > this.maxFrameTimeSamples) {
                        this.frameTimeSamples.shift();
                    }
                    this.avgFrameDuration = this.frameTimeSamples.reduce((a, b) => a + b, 0) / this.frameTimeSamples.length;

                    // Update timing display
                    this.updateTimingStats();

                } catch (error) {
                    this.log('Frame capture error: ' + error.message);

                    // Check if it's an initialization error
                    if (error.message.includes('not initialized')) {
                        this.log('⚠️ People Detection not initialized!');
                        this.log('Stopping capture - please click "Start Capture" again');
                        this.stopCapture();
                        // Don't auto-reinitialize here as it causes loops with memory errors
                        return;
                    }

                    console.error(error);
                    // Don't stop capture on single frame error
                } finally {
                    // Always clear the in-progress flag
                    this.captureInProgress = false;
                }
            }

            /**
             * Update statistics display
             */
            updateStats(data) {
                document.getElementById('peopleCount').textContent = data.peopleCount;
                document.getElementById('blobCount').textContent = data.blobCount;
                document.getElementById('tempRange').textContent =
                    `${data.tempMin.toFixed(1)}-${data.tempMax.toFixed(1)}°C`;
                document.getElementById('processTime').textContent =
                    `${data.processingTime.toFixed(1)} ms`;
            }

            /**
             * Update timing statistics display
             */
            updateTimingStats() {
                // Frame time (total round-trip)
                document.getElementById('frameTime').textContent =
                    `${this.avgFrameDuration.toFixed(0)} ms`;

                // Actual FPS achieved
                const actualFps = this.avgFrameDuration > 0 ? 1000 / this.avgFrameDuration : 0;
                const requestedFps = this.frameRate;
                const fpsColor = actualFps < requestedFps * 0.8 ? 'orange' : 'inherit';  // Warn if <80% of target
                document.getElementById('actualFps').innerHTML =
                    `<span style="color: ${fpsColor}">${actualFps.toFixed(1)} Hz</span>`;

                // Log warning if frame time exceeds interval
                const targetInterval = 1000 / this.frameRate;
                if (this.lastFrameDuration > targetInterval * 1.1) {
                    console.warn(`Frame time (${this.lastFrameDuration.toFixed(0)}ms) exceeds interval (${targetInterval.toFixed(0)}ms) - frames may be skipped`);
                }
            }

            /**
             * Apply sensor configuration (mode and framerate)
             */
            async applySensorConfig() {
                try {
                    const mode = document.getElementById('sensorMode').value;
                    const fps = document.getElementById('sensorFps').value;
                    const fpsText = document.getElementById('sensorFps').options[document.getElementById('sensorFps').selectedIndex].text;

                    this.log('Applying sensor configuration...');
                    this.log(`  Mode: ${mode}`);
                    this.log(`  Frame Rate: ${fpsText} (fps=${fps})`);

                    // Send :SENSOR:CONFIG command
                    const configCmd = `:SENSOR:CONFIG ${mode} ${fps}`;
                    this.log(`Sending: ${configCmd}`);

                    const response = await this.serialManager.sendCommand(configCmd, 5000);
                    this.log('Sensor config response:\n' + response);

                    // Query sensor status to confirm configuration
                    try {
                        const statusResponse = await this.serialManager.sendCommand(':SENSOR:STATUS?', 2000);
                        this.log('Updated sensor status:\n' + statusResponse);

                        // Parse the response to extract mode and frame rate
                        const lines = statusResponse.split('\n');
                        let actualMode = 'Unknown';
                        let actualRate = 'Unknown';

                        for (const line of lines) {
                            if (line.includes('[INFO] MODE:')) {
                                actualMode = line.split('MODE:')[1].trim();
                            } else if (line.includes('[INFO] RATE:')) {
                                actualRate = line.split('RATE:')[1].trim();
                            }
                        }

                        // Update status display with actual values from sensor
                        const statusElement = document.getElementById('sensorStatus');
                        if (actualMode !== 'Unknown' && actualRate !== 'Unknown') {
                            statusElement.textContent = `${actualMode}, ${actualRate}`;
                            statusElement.style.color = '#4ade80';
                        } else {
                            statusElement.textContent = `${mode}, ${fpsText}`;
                            statusElement.style.color = '#4ade80';
                        }
                    } catch (error) {
                        // Fallback to showing what was requested
                        document.getElementById('sensorStatus').textContent = `${mode}, ${fpsText}`;
                        document.getElementById('sensorStatus').style.color = '#4ade80';
                    }

                    this.log('Sensor configuration applied successfully!');
                    this.log('Note: EEPROM settings persist across power cycles.');
                } catch (error) {
                    this.log('ERROR applying sensor config: ' + error.message);
                    document.getElementById('sensorStatus').textContent = 'Config failed';
                    document.getElementById('sensorStatus').style.color = '#ef4444';
                    console.error(error);
                }
            }

            /**
             * Apply preset configuration
             */
            async applyPreset() {
                // Preset controls are disabled during capture, so this only runs when stopped
                try {
                    const preset = document.getElementById('presetSelect').value;
                    const [angle, height, sensitivity] = preset.split('|');
                    const coldDetection = document.getElementById('coldDetection').checked;

                    this.log('Applying preset configuration...');
                    this.log(`  Angle: ${angle}, Height: ${height}, Sensitivity: ${sensitivity}, Cold: ${coldDetection}`);

                    // Helper function to check for errors in response
                    const checkResponse = (response, commandName) => {
                        // WORKAROUND: Firmware has a bug where preset commands return E2BIG
                        // even when successful (they don't consume the argument from the buffer).
                        // Check for success messages instead of just error codes.
                        const successPatterns = {
                            'ANGLE': /Mount angle set to (VERTICAL|OBLIQUE)/,
                            'HEIGHT': /Mount height set to (SHORT|TALL)/,
                            'SENSITIVITY': /Sensitivity set to (LOW|HIGH)/,
                            'COLD': /Cold detection (ENABLED|DISABLED)/
                        };

                        // If we have a success pattern for this command, check for it
                        if (successPatterns[commandName]) {
                            if (successPatterns[commandName].test(response)) {
                                // Success message found, command worked despite E2BIG
                                return;
                            }
                        }

                        // Check for actual errors
                        if (response.includes('(ERROR)>')) {
                            throw new Error(`${commandName} failed: ERROR`);
                        }
                        if (response.includes('(ENOMEM)>')) {
                            throw new Error(`${commandName} failed: ENOMEM (out of memory)`);
                        }
                        // Only fail on E2BIG if we didn't see a success message
                        if (response.includes('(E2BIG)>') && !successPatterns[commandName]) {
                            throw new Error(`${commandName} failed: E2BIG (argument too large)`);
                        }
                        // For commands without success patterns, require (OK)>
                        if (!successPatterns[commandName] && !response.includes('(OK)>')) {
                            throw new Error(`${commandName} failed: unexpected response`);
                        }
                    };

                    // Send preset parameter commands with error checking and delays
                    const angleResponse = await this.serialManager.sendCommand(`:PeopleDetection:PRESET:ANGLE ${angle}`, 2000);
                    checkResponse(angleResponse, 'ANGLE');
                    await new Promise(resolve => setTimeout(resolve, 100));

                    const heightResponse = await this.serialManager.sendCommand(`:PeopleDetection:PRESET:HEIGHT ${height}`, 2000);
                    checkResponse(heightResponse, 'HEIGHT');
                    await new Promise(resolve => setTimeout(resolve, 100));

                    const sensitivityResponse = await this.serialManager.sendCommand(`:PeopleDetection:PRESET:SENSITIVITY ${sensitivity}`, 2000);
                    checkResponse(sensitivityResponse, 'SENSITIVITY');
                    await new Promise(resolve => setTimeout(resolve, 100));

                    const coldResponse = await this.serialManager.sendCommand(`:PeopleDetection:PRESET:COLD ${coldDetection ? 'ON' : 'OFF'}`, 2000);
                    checkResponse(coldResponse, 'COLD');
                    await new Promise(resolve => setTimeout(resolve, 100));

                    // Apply preset - this will use runtime update if initialized
                    const applyResponse = await this.serialManager.sendCommand(':PeopleDetection:PRESET:APPLY', 2000);
                    this.log('APPLY response:\n' + applyResponse);

                    // Check if runtime update was applied (no DEINIT/INIT needed)
                    if (applyResponse.includes('Runtime configuration updated')) {
                        this.log('Preset applied via runtime update!');

                        // Update UI sliders to match preset values
                        await this.syncRuntimeParamsFromDevice();
                    } else {
                        // Not initialized or runtime update not available
                        // Check if we need to initialize
                        if (applyResponse.includes('Call :PeopleDetection:INIT')) {
                            this.log('Initializing with new preset...');
                            const initResponse = await this.serialManager.sendCommand(':PeopleDetection:INIT', 5000);
                            this.log('INIT response:\n' + initResponse);

                            // Sync UI after initialization
                            await this.syncRuntimeParamsFromDevice();
                        }
                    }

                    this.log('Preset applied successfully!');
                } catch (error) {
                    this.log('ERROR applying preset: ' + error.message);
                    console.error(error);
                }
            }

            /**
             * Sync runtime parameter sliders with current device configuration
             */
            async syncRuntimeParamsFromDevice() {
                try {
                    // Query current config from device
                    const response = await this.serialManager.sendCommand(':PeopleDetection:DEBUG:CONFIG?', 2000);

                    // Parse response to extract current values
                    const lines = response.split('\n');
                    for (const line of lines) {
                        // Footprint
                        if (line.includes('area_std_footprint:')) {
                            const match = line.match(/(\d+)\s+pixels/);
                            if (match) {
                                const value = parseInt(match[1]);
                                document.getElementById('footprintSlider').value = value;
                                document.getElementById('footprintValue').textContent = value;
                            }
                        }
                        // Min blob area
                        else if (line.includes('min_blob_area:')) {
                            const match = line.match(/(\d+)\s+pixels/);
                            if (match) {
                                const value = parseInt(match[1]);
                                document.getElementById('minAreaSlider').value = value;
                                document.getElementById('minAreaValue').textContent = value;
                            }
                        }
                        // Lower threshold (fact_std_raw_l in Q8.8)
                        else if (line.includes('fact_std_raw_l:')) {
                            const match = line.match(/(\d+)\s+\(([\d.]+)x\)/);
                            if (match) {
                                const value = parseInt(match[1]);
                                document.getElementById('thresholdLSlider').value = value;
                                document.getElementById('thresholdLValue').textContent = match[2];
                            }
                        }
                        // Upper threshold (fact_std_raw_h in Q8.8)
                        else if (line.includes('fact_std_raw_h:')) {
                            const match = line.match(/(\d+)\s+\(([\d.]+)x\)/);
                            if (match) {
                                const value = parseInt(match[1]);
                                document.getElementById('thresholdHSlider').value = value;
                                document.getElementById('thresholdHValue').textContent = match[2];
                            }
                        }
                        // Temperature min (Celsius × 50 format)
                        else if (line.includes('temp_range_min:')) {
                            const match = line.match(/(-?\d+)\s+\(([\d.]+)°C\)/);
                            if (match) {
                                const value = parseInt(match[1]);
                                document.getElementById('tempMinSlider').value = value;
                                document.getElementById('tempMinValue').textContent = match[2];
                            }
                        }
                        // Temperature max (Celsius × 50 format)
                        else if (line.includes('temp_range_max:')) {
                            const match = line.match(/(-?\d+)\s+\(([\d.]+)°C\)/);
                            if (match) {
                                const value = parseInt(match[1]);
                                document.getElementById('tempMaxSlider').value = value;
                                document.getElementById('tempMaxValue').textContent = match[2];
                            }
                        }
                        // Cold LoG gate (lim_area_frg_l)
                        else if (line.includes('lim_area_frg_l:')) {
                            const match = line.match(/(\d+)\s+pixels/);
                            if (match) {
                                const value = parseInt(match[1]);
                                document.getElementById('logGateLSlider').value = value;
                                document.getElementById('logGateLValue').textContent = value;
                            }
                        }
                        // Hot LoG gate (lim_area_frg_h)
                        else if (line.includes('lim_area_frg_h:')) {
                            const match = line.match(/(\d+)\s+pixels/);
                            if (match) {
                                const value = parseInt(match[1]);
                                document.getElementById('logGateHSlider').value = value;
                                document.getElementById('logGateHValue').textContent = value;
                            }
                        }
                        // Cold percentile (percentile_l in Q8.8)
                        else if (line.includes('percentile_l:')) {
                            const match = line.match(/(\d+)\s+\(([\d.]+),\s+cold\)/);
                            if (match) {
                                const value = parseInt(match[1]);
                                document.getElementById('percentileLSlider').value = value;
                                document.getElementById('percentileLValue').textContent = match[2];
                            }
                        }
                        // Hot percentile (percentile_h in Q8.8)
                        else if (line.includes('percentile_h:')) {
                            const match = line.match(/(\d+)\s+\(([\d.]+),\s+hot\)/);
                            if (match) {
                                const value = parseInt(match[1]);
                                document.getElementById('percentileHSlider').value = value;
                                document.getElementById('percentileHValue').textContent = match[2];
                            }
                        }
                    }

                    // Save updated params to localStorage
                    this.saveRuntimeParams();
                } catch (error) {
                    console.error('Failed to sync runtime params:', error);
                }
            }

            /**
             * Initialize runtime parameter sliders with event handlers
             */
            initRuntimeParams() {
                // Load saved parameters from localStorage
                this.loadRuntimeParams();

                // Add change event handlers to all sliders (using new short command names)
                const sliders = [
                    { id: 'footprintSlider', cmd: ':PeopleDetection:TUNE:FOOTPRINT', scale: 1 },
                    { id: 'minAreaSlider', cmd: ':PeopleDetection:TUNE:MINAREA', scale: 1 },
                    { id: 'thresholdLSlider', cmd: ':PeopleDetection:TUNE:THRESHOLD:LOWER', scale: 1 },
                    { id: 'thresholdHSlider', cmd: ':PeopleDetection:TUNE:THRESHOLD:UPPER', scale: 1 },
                    { id: 'tempMinSlider', cmd: ':PeopleDetection:TUNE:TEMP:MIN', scale: 1 },
                    { id: 'tempMaxSlider', cmd: ':PeopleDetection:TUNE:TEMP:MAX', scale: 1 },
                    { id: 'logGateLSlider', cmd: ':PeopleDetection:TUNE:GATE:COLD', scale: 1 },
                    { id: 'logGateHSlider', cmd: ':PeopleDetection:TUNE:GATE:HOT', scale: 1 },
                    { id: 'percentileLSlider', cmd: ':PeopleDetection:TUNE:PERCENTILE:COLD', scale: 1 },
                    { id: 'percentileHSlider', cmd: ':PeopleDetection:TUNE:PERCENTILE:HOT', scale: 1 },
                    { id: 'gammaEmaSlider', cmd: ':PeopleDetection:TUNE:LEARNING', scale: 1 }
                ];

                sliders.forEach(slider => {
                    const element = document.getElementById(slider.id);
                    if (element) {
                        // Update on slider release
                        element.addEventListener('change', async (e) => {
                            if (this.serialManager.isConnected()) {
                                await this.updateRuntimeParam(slider.cmd, e.target.value);
                                this.saveRuntimeParams();
                            }
                        });
                    }
                });
            }

            /**
             * Update a runtime parameter
             */
            async updateRuntimeParam(command, value) {
                try {
                    const cmd = `${command} ${value}`;
                    this.log(`Updating runtime parameter: ${cmd}`);
                    const response = await this.serialManager.sendCommand(cmd, 2000);

                    // Check if response indicates success
                    if (response.includes('[INFO]')) {
                        this.log('Runtime parameter updated successfully');
                    } else if (response.includes('[ERROR]')) {
                        this.log('ERROR updating parameter: ' + response);
                    }
                } catch (error) {
                    this.log('ERROR updating runtime parameter: ' + error.message);
                }
            }

            /**
             * Reset runtime parameters to defaults
             */
            async resetRuntimeParams() {
                const defaults = {
                    footprintSlider: 45,
                    minAreaSlider: 10,
                    thresholdLSlider: 256,
                    thresholdHSlider: 256,
                    tempMinSlider: 0,
                    tempMaxSlider: 0,
                    logGateLSlider: 50,
                    logGateHSlider: 5,
                    percentileLSlider: 128,
                    percentileHSlider: 128,
                    gammaEmaSlider: 26
                };

                // Update UI
                for (const [id, value] of Object.entries(defaults)) {
                    const element = document.getElementById(id);
                    if (element) {
                        element.value = value;
                        element.dispatchEvent(new Event('input')); // Update display values
                    }
                }

                // Send updates if connected (using new short command names)
                if (this.serialManager.isConnected()) {
                    try {
                        await this.updateRuntimeParam(':PeopleDetection:TUNE:FOOTPRINT', defaults.footprintSlider);
                        await this.updateRuntimeParam(':PeopleDetection:TUNE:MINAREA', defaults.minAreaSlider);
                        await this.updateRuntimeParam(':PeopleDetection:TUNE:THRESHOLD:LOWER', defaults.thresholdLSlider);
                        await this.updateRuntimeParam(':PeopleDetection:TUNE:THRESHOLD:UPPER', defaults.thresholdHSlider);
                        await this.updateRuntimeParam(':PeopleDetection:TUNE:TEMP:MIN', defaults.tempMinSlider);
                        await this.updateRuntimeParam(':PeopleDetection:TUNE:TEMP:MAX', defaults.tempMaxSlider);
                        await this.updateRuntimeParam(':PeopleDetection:TUNE:GATE:COLD', defaults.logGateLSlider);
                        await this.updateRuntimeParam(':PeopleDetection:TUNE:GATE:HOT', defaults.logGateHSlider);
                        await this.updateRuntimeParam(':PeopleDetection:TUNE:PERCENTILE:COLD', defaults.percentileLSlider);
                        await this.updateRuntimeParam(':PeopleDetection:TUNE:PERCENTILE:HOT', defaults.percentileHSlider);
                        await this.updateRuntimeParam(':PeopleDetection:TUNE:LEARNING', defaults.gammaEmaSlider);
                        this.log('All runtime parameters reset to defaults');
                    } catch (error) {
                        this.log('ERROR resetting parameters: ' + error.message);
                    }
                }

                // Clear localStorage
                localStorage.removeItem('runtimeParams');
            }

            /**
             * Save runtime parameters to localStorage
             */
            saveRuntimeParams() {
                const params = {
                    footprint: document.getElementById('footprintSlider').value,
                    minArea: document.getElementById('minAreaSlider').value,
                    thresholdL: document.getElementById('thresholdLSlider').value,
                    thresholdH: document.getElementById('thresholdHSlider').value,
                    tempMin: document.getElementById('tempMinSlider').value,
                    tempMax: document.getElementById('tempMaxSlider').value,
                    logGateL: document.getElementById('logGateLSlider').value,
                    logGateH: document.getElementById('logGateHSlider').value,
                    percentileL: document.getElementById('percentileLSlider').value,
                    percentileH: document.getElementById('percentileHSlider').value,
                    gammaEma: document.getElementById('gammaEmaSlider').value
                };
                localStorage.setItem('runtimeParams', JSON.stringify(params));
            }

            /**
             * Load runtime parameters from localStorage
             */
            loadRuntimeParams() {
                const saved = localStorage.getItem('runtimeParams');
                if (saved) {
                    try {
                        const params = JSON.parse(saved);

                        // Update slider values
                        if (params.footprint !== undefined) {
                            document.getElementById('footprintSlider').value = params.footprint;
                            document.getElementById('footprintValue').textContent = params.footprint;
                        }
                        if (params.minArea !== undefined) {
                            document.getElementById('minAreaSlider').value = params.minArea;
                            document.getElementById('minAreaValue').textContent = params.minArea;
                        }
                        if (params.thresholdL !== undefined) {
                            document.getElementById('thresholdLSlider').value = params.thresholdL;
                            document.getElementById('thresholdLValue').textContent = (params.thresholdL / 256).toFixed(2);
                        }
                        if (params.thresholdH !== undefined) {
                            document.getElementById('thresholdHSlider').value = params.thresholdH;
                            document.getElementById('thresholdHValue').textContent = (params.thresholdH / 256).toFixed(2);
                        }
                        if (params.tempMin !== undefined) {
                            document.getElementById('tempMinSlider').value = params.tempMin;
                            document.getElementById('tempMinValue').textContent = params.tempMin == 0 ? '20.0' : (params.tempMin / 50).toFixed(1);
                        }
                        if (params.tempMax !== undefined) {
                            document.getElementById('tempMaxSlider').value = params.tempMax;
                            document.getElementById('tempMaxValue').textContent = params.tempMax == 0 ? '40.0' : (params.tempMax / 50).toFixed(1);
                        }
                        if (params.logGateL !== undefined) {
                            document.getElementById('logGateLSlider').value = params.logGateL;
                            document.getElementById('logGateLValue').textContent = params.logGateL;
                        }
                        if (params.logGateH !== undefined) {
                            document.getElementById('logGateHSlider').value = params.logGateH;
                            document.getElementById('logGateHValue').textContent = params.logGateH;
                        }
                        if (params.percentileL !== undefined) {
                            document.getElementById('percentileLSlider').value = params.percentileL;
                            document.getElementById('percentileLValue').textContent = (params.percentileL / 256).toFixed(2);
                        }
                        if (params.percentileH !== undefined) {
                            document.getElementById('percentileHSlider').value = params.percentileH;
                            document.getElementById('percentileHValue').textContent = (params.percentileH / 256).toFixed(2);
                        }
                        if (params.gammaEma !== undefined) {
                            document.getElementById('gammaEmaSlider').value = params.gammaEma;
                            document.getElementById('gammaEmaValue').textContent = (params.gammaEma / 256).toFixed(2);
                        }

                        this.log('Loaded runtime parameters from localStorage');
                    } catch (error) {
                        console.error('Failed to load runtime params:', error);
                    }
                }
            }

            /**
             * Update frame rate
             */
            updateFrameRate(value) {
                this.frameRate = parseFloat(value);
                document.getElementById('frameRateValue').textContent = this.frameRate.toFixed(1) + ' Hz';

                // Restart capture loop if currently capturing
                if (this.capturing) {
                    clearInterval(this.captureInterval);
                    this.captureInterval = setInterval(() => {
                        this.captureFrame();
                    }, 1000 / this.frameRate);
                }
            }

            /**
             * Start recording session
             */
            startRecording() {
                this.recording = true;
                this.recordedFrames = [];
                document.getElementById('recordBtn').disabled = true;
                document.getElementById('stopRecordBtn').disabled = false;
                this.log('Recording started...');
            }

            /**
             * Stop recording session
             */
            stopRecording() {
                this.recording = false;
                document.getElementById('recordBtn').disabled = false;
                document.getElementById('stopRecordBtn').disabled = true;
                document.getElementById('saveRecordBtn').disabled = false;
                this.log(`Recording stopped. ${this.recordedFrames.length} frames captured.`);
            }

            /**
             * Save recording to JSON file
             */
            saveRecording() {
                const data = {
                    version: '1.0',
                    timestamp: new Date().toISOString(),
                    frameCount: this.recordedFrames.length,
                    frames: this.recordedFrames
                };

                const json = JSON.stringify(data, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = `thermal_recording_${Date.now()}.json`;
                a.click();

                URL.revokeObjectURL(url);
                this.log(`Recording saved: ${this.recordedFrames.length} frames`);
            }

            /**
             * Toggle connection (connect or disconnect)
             */
            async toggleConnection() {
                if (this.serialManager.isConnected()) {
                    await this.disconnect();
                } else {
                    await this.connect();
                }
            }

            /**
             * Toggle capture (start or stop)
             */
            async toggleCapture() {
                if (this.capturing) {
                    this.stopCapture();
                } else {
                    await this.startCapture();
                }
            }

            /**
             * Update connection state UI
             */
            updateConnectionState(connected) {
                const btn = document.getElementById('connectionToggle');
                btn.textContent = connected ? 'Disconnect' : 'Connect';
                btn.className = connected ? 'danger' : 'primary';

                document.getElementById('captureToggle').disabled = !connected;
                document.getElementById('applySensorConfigBtn').disabled = !connected;
                document.getElementById('presetSelect').disabled = !connected;
                document.getElementById('coldDetection').disabled = !connected;
            }

            /**
             * Update capture state UI
             */
            updateCaptureState(capturing) {
                const btn = document.getElementById('captureToggle');
                btn.textContent = capturing ? 'Stop Capture' : 'Start Capture';
                btn.className = capturing ? 'danger' : 'secondary';

                // Disable record button when not capturing
                document.getElementById('recordBtn').disabled = !capturing;

                // Disable preset controls during capture to prevent race conditions
                document.getElementById('presetSelect').disabled = capturing;
                document.getElementById('coldDetection').disabled = capturing;
            }

            /**
             * Log message to debug output
             */
            log(message) {
                const output = document.getElementById('debugOutput');
                const timestamp = new Date().toLocaleTimeString();
                output.value += `[${timestamp}] ${message}\n`;
                output.scrollTop = output.scrollHeight;
                console.log(message);
            }
        }

        // Initialize application when page loads
        let app;
        window.addEventListener('DOMContentLoaded', () => {
            app = new ThermalViewerApp();

            // Initialize runtime parameter controls
            app.initRuntimeParams();

            // Add real-time smoothing toggle
            document.getElementById('smoothHeatmap').addEventListener('change', (e) => {
                if (app && app.heatmapRenderer) {
                    app.heatmapRenderer.setSmoothing(e.target.checked);
                    console.log('Heatmap smoothing:', e.target.checked ? 'enabled' : 'disabled');
                }
            });
        });
    </script>
</body>
</html>
