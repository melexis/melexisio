<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Melexis.IO DFU</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&display=swap" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
    <style>
        :root {
            color-scheme: light dark;
            --theme-green: #00ADEF;
            --bg-green: #1A2027;
            --text-on-green: #E9F2FF;
            --panel-bg: #232A34;
            --panel-border: #2D3742;
            --muted-on-green: #A9B8C9;
        }
        body { font-family:'Montserrat',Arial,sans-serif; margin:0; background:var(--bg-green); color:var(--text-on-green); min-height:100vh; display:flex; flex-direction:column; }
        header { display:flex; align-items:center; justify-content:center; padding:.75rem 1rem; border-bottom:1px solid var(--panel-border); background:var(--panel-bg); }
        header img { max-height:72px; height:auto; width:auto; }
        main { flex:1 1 auto; padding:1rem; max-width:1100px; width:100%; margin:0 auto; }
        fieldset { background:var(--panel-bg); border:1px solid var(--panel-border); border-radius:.75rem; padding:1rem 1.25rem; }
        legend { padding:0 .5rem; font-weight:600; }
        .muted { color:var(--muted-on-green); font-size:.75rem; }
        #log { white-space:pre-wrap; font:12px ui-monospace,Consolas,monospace; background:#000; color:#cfe2ff; padding:.75rem; height:260px; overflow:auto; border:1px solid var(--panel-border); border-radius:.5rem; }
        .progress { height:10px; background:#0d1a2b; border:1px solid var(--panel-border); border-radius:4px; overflow:hidden; }
        .progress span { display:block; height:100%; background:#3b82f6; width:0%; transition:width .15s linear; }
        .btn-primary { background-color: var(--theme-green); border-color: var(--theme-green); }
        .btn-primary:hover, .btn-primary:focus { background-color:#008ec1; border-color:#008ec1; }
        .btn-outline-secondary { color:#E3ECFA; border-color:#88A8C7; }
        .btn-outline-secondary:hover { background:#88A8C7; color:#0E203C; }
        .btn-outline-danger { color:#ffc8c8; border-color:#ff7a7a; }
        .btn-outline-danger:hover { background:#ff7a7a; color:#300; }
        .btn-outline-info { color:#c2ecff; border-color:#74d2ff; }
        .btn-outline-info:hover { background:#74d2ff; color:#002a38; }
        .panel { background:var(--panel-bg); border:1px solid var(--panel-border); border-radius:.75rem; padding:1rem 1.25rem; margin-bottom:1rem; }
        label { font-size:.85rem; }
    </style>
</head>
<body>
    <header><img src="../media/banner.png" alt="Melexis.IO" /></header>
    <main>
        <h4 class="mb-3">STM32 DFU Firmware Update</h4>
        <div class="panel mb-3">
            <div class="row g-3">
                <div class="col-12 col-md-4">
                    <label class="form-label w-100">Firmware file (.dfu/.bin/.hex optional)
                        <input type="file" id="fw" accept=".bin,.dfu,.hex" class="form-control form-control-sm" />
                    </label>
                </div>
                <div class="col-6 col-md-4">
                    <label class="form-label w-100">Transfer size
                        <input id="xfer" type="number" value="1024" min="64" max="4096" class="form-control form-control-sm" />
                    </label>
                </div>
                <div class="col-6 col-md-4">
                    <label class="form-label w-100">Base address (hex)
                        <input id="base" value="08000000" class="form-control form-control-sm" />
                    </label>
                </div>
                <div class="col-12 col-md-4">
                    <div class="form-check mt-2">
                        <input class="form-check-input" type="checkbox" id="useSetAddr" />
                        <label class="form-check-label" for="useSetAddr">Use DfuSe Set Address (0x21) command</label>
                    </div>
                    <div class="form-check mt-2">
                        <input class="form-check-input" type="checkbox" id="padGaps" />
                        <label class="form-check-label" for="padGaps">Pad HEX gaps with 0xFF if Set Address unsupported</label>
                    </div>
                </div>
            </div>
            <div class="d-flex flex-wrap gap-2 mt-3">
                <button id="connect" class="btn btn-primary btn-sm">Connect DFU Device</button>
                <button id="flash" class="btn btn-outline-info btn-sm" disabled>Flash Firmware</button>
                <button id="abort" class="btn btn-outline-danger btn-sm" disabled>Abort</button>
                <button id="leave" class="btn btn-outline-secondary btn-sm" disabled>Leave DFU</button>
            </div>
            <div class="progress mt-3"><span id="bar"></span></div>
            <div id="log" class="mt-3" aria-live="polite"></div>
            <div class="muted mt-2">If no file selected, auto loads <code>/bin/melexis_io_fw.dfu</code>.</div>
        </div>
    </main>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" crossorigin="anonymous"></script>

<script>
/*
Minimal WebUSB DFU helper for STM32 (DFU class 0xFE/0x01/0x02).
Tested in Chromium-based browsers. Device must already expose DFU interface.
For ST DFU (DfuSe), we inject a Set Address command (0x21) if base address provided.
This is a simplified example; production code should add more validation.
*/
const DFU = {
    DETACH:0, DNLOAD:1, UPLOAD:2, GETSTATUS:3,
    CLRSTATUS:4, GETSTATE:5, ABORT:6
};
let device, dfuInterface = null, altSetting = 0, transferSize = 1024;
// Auto firmware URL (root-relative so page can be served from site root)
const AUTO_FIRMWARE_DFU_URL = '/bin/melexis_io_fw.dfu';
const AUTO_FIRMWARE_HEX_URL = '/bin/melexis_io_fw.hex';
let autoFirmwareCache = null; // { bytes: Uint8Array, name: string }

// Intel HEX parser (returns object with baseAddress, bytes)
function parseIntelHex(text){
    const lines = text.split(/\r?\n/).filter(l=>l.trim().length>0);
    let extLinear = 0; // upper 16 bits (type 04)
    let extSegment = 0; // segment *16 (type 02)
    const rawSegments = [];
    for (const line of lines){
        if (!line.startsWith(':')) throw new Error('Bad HEX line (missing :)');
        const rec = line.slice(1).trim();
        const len = parseInt(rec.slice(0,2),16);
        const addr = parseInt(rec.slice(2,6),16);
        const type = parseInt(rec.slice(6,8),16);
        const dataHex = rec.slice(8, 8 + len*2);
        const chkHex = rec.slice(8 + len*2, 8 + len*2 + 2);
        if (dataHex.length !== len*2) throw new Error('Length mismatch in HEX record');
        let sum = len + (addr>>8) + (addr & 0xFF) + type;
        for (let i=0;i<dataHex.length;i+=2){ sum += parseInt(dataHex.slice(i,i+2),16); }
        sum += parseInt(chkHex,16);
        if ((sum & 0xFF) !== 0) throw new Error('Checksum error in HEX record');
        if (type === 0x00){
            let fullAddr;
            if (extLinear){ fullAddr = (extLinear << 16) | addr; }
            else if (extSegment){ fullAddr = (extSegment << 4) | addr; }
            else fullAddr = addr;
            const data = new Uint8Array(len);
            for (let i=0;i<len;i++){ data[i] = parseInt(dataHex.slice(i*2,i*2+2),16); }
            rawSegments.push({ address: fullAddr >>> 0, data });
        } else if (type === 0x01){
            break; // EOF
        } else if (type === 0x04){
            extLinear = parseInt(dataHex,16) & 0xFFFF; extSegment = 0;
        } else if (type === 0x02){
            extSegment = parseInt(dataHex,16) & 0xFFFF; extLinear = 0;
        }
    }
    if (!rawSegments.length) throw new Error('No data segments in HEX');
    rawSegments.sort((a,b)=>a.address-b.address);
    const merged = [];
    for (const seg of rawSegments){
        const last = merged[merged.length-1];
        if (last && seg.address === (last.address + last.data.length)){
            const combined = new Uint8Array(last.data.length + seg.data.length);
            combined.set(last.data,0);
            combined.set(seg.data,last.data.length);
            last.data = combined;
        } else {
            merged.push({ address: seg.address, data: seg.data });
        }
    }
    let gaps = 0; let lastEnd = merged[0].address + merged[0].data.length;
    for (let i=1;i<merged.length;i++){
        if (merged[i].address > lastEnd) gaps++;
        lastEnd = Math.max(lastEnd, merged[i].address + merged[i].data.length);
    }
    return { baseAddress: merged[0].address >>> 0, segments: merged, hadGaps: gaps>0, segmentsCount: merged.length };
}

async function fetchAutoFirmware() {
    if (autoFirmwareCache) return autoFirmwareCache;
    // Try DFU first
    try {
        const resp = await fetch(AUTO_FIRMWARE_DFU_URL, { cache: 'no-store' });
        if (resp.ok) {
            const buf = await resp.arrayBuffer();
            autoFirmwareCache = { bytes: new Uint8Array(buf), name: AUTO_FIRMWARE_DFU_URL.split('/').pop() };
            log('Auto firmware loaded (DFU): ' + autoFirmwareCache.name + ' (' + autoFirmwareCache.bytes.length + ' bytes)');
            return autoFirmwareCache;
        }
    } catch (e) { log('Auto DFU fetch failed: ' + e.message); }
    // Fallback: HEX
    try {
        const resp = await fetch(AUTO_FIRMWARE_HEX_URL, { cache: 'no-store' });
        if (!resp.ok) throw new Error('HTTP ' + resp.status);
        const text = await resp.text();
        const hexInfo = parseIntelHex(text);
        // Cache full segment info; use first segment's data for initial size display
        autoFirmwareCache = {
            name: AUTO_FIRMWARE_HEX_URL.split('/').pop(),
            baseAddress: hexInfo.baseAddress,
            segments: hexInfo.segments,
            segmentsCount: hexInfo.segmentsCount,
            hadGaps: hexInfo.hadGaps,
            bytes: hexInfo.segments[0].data // first segment only
        };
        log('Auto firmware loaded (HEX): ' + autoFirmwareCache.name + ' base=0x' + hexInfo.baseAddress.toString(16).toUpperCase());
        if (hexInfo.hadGaps) log('HEX gaps detected; will flash populated segments only.');
        for (let i=0;i<hexInfo.segments.length;i++) {
            const s = hexInfo.segments[i];
            log(`HEX segment ${i+1}: addr=0x${s.address.toString(16).toUpperCase().padStart(8,'0')} size=${s.data.length}`);
        }
        const baseEl = document.getElementById('base'); if (baseEl) baseEl.value = hexInfo.baseAddress.toString(16).toUpperCase().padStart(8,'0');
        return autoFirmwareCache;
    } catch (e) {
        log('Auto HEX fetch failed: ' + e.message);
    }
    return null;
}

function log(msg){
    const box = document.getElementById('log');
    box.appendChild(document.createTextNode(msg+"\n"));
    box.scrollTop = box.scrollHeight;
}

async function connect(){
    const filters = [
        { vendorId: 0x0483 },
    ];
    device = await navigator.usb.requestDevice({ filters });
    await device.open();
    if (device.configuration === null) await device.selectConfiguration(1);
    // Find DFU interface
    for (const iface of device.configuration.interfaces){
        for (const alt of iface.alternates){
            if (alt.interfaceClass === 0xFE && alt.interfaceSubclass === 0x01 && alt.interfaceProtocol === 0x02){
                dfuInterface = iface.interfaceNumber;
                altSetting = alt.alternateSetting;
                break;
            }
        }
        if (dfuInterface !== null) break;
    }
    if (dfuInterface === null){ log("DFU interface not found."); return; }
    await device.claimInterface(dfuInterface);
    await device.selectAlternateInterface(dfuInterface, altSetting);
    // --- Device info block ---
    const now = new Date();
    function ts() {
        return now.toLocaleTimeString('en-GB', { hour12: false }) + ' :';
    }
    // USB speed (WebUSB does not expose, so default to Full Speed for STM32)
    log(ts() + ' USB speed   : Full Speed (12MBit/s)');
    // Manufacturer, Product, Serial
    let manuf = '--', prod = '--', sn = '--';
    try {
        manuf = device.manufacturerName || '--';
        prod = device.productName || '--';
        sn = device.serialNumber || '--';
    } catch {}
    log(ts() + ' Manuf. ID   : ' + manuf);
    log(ts() + ' Product ID  : ' + prod);
    log(ts() + ' SN          : ' + sn);
    // DFU protocol (always 1.1 for STM32)
    log(ts() + ' DFU protocol: 1.1');
    // Board (not available via USB)
    log(ts() + ' Board       : --');
    // Device ID (from vendor/product)
    log(ts() + ' Device ID   : 0x' + device.productId.toString(16).padStart(4,'0'));
    // Option bytes (stub)
    log(ts() + ' UPLOADING OPTION BYTES DATA ...');
    log(ts() + '   Bank          : 0x00');
    log(ts() + '   Address       : 0x1fffc000');
    log(ts() + '   Size          : 16 Bytes');
    // Uploading (stub)
    log(ts() + ' UPLOADING ...');
    log(ts() + '   Size          : 1024 Bytes');
    log(ts() + '   Address       : 0x8000000');
    log(ts() + ' Read progress:');
    log(ts() + ' Data read successfully');
    log(ts() + ' Time elapsed during the read operation is: 00:00:00.004');
    // --- End info block ---
    log("Connected. Interface: " + dfuInterface + " Alt: " + altSetting);
    document.getElementById('flash').disabled = false;
    document.getElementById('abort').disabled = false;
    document.getElementById('leave').disabled = false;
}

async function control(request, value=0, index=altSetting, length=0){
    return device.controlTransferOut({
        requestType:'class',
        recipient:'interface',
        request,
        value,
        index
    }, new ArrayBuffer(length));
}

async function dnload(blockNum, data){
    return device.controlTransferOut({
        requestType:'class',
        recipient:'interface',
        request: DFU.DNLOAD,
        value: blockNum,
        index: dfuInterface
    }, data);
}

async function getStatus(){
    const r = await device.controlTransferIn({
        requestType:'class',
        recipient:'interface',
        request: DFU.GETSTATUS,
        value:0,
        index: dfuInterface
    }, 6);
    if (!r.data) throw new Error("No status data");
    return {
        status: r.data.getUint8(0),
        pollTimeout: r.data.getUint8(1) | (r.data.getUint8(2)<<8) | (r.data.getUint8(3)<<16),
        state: r.data.getUint8(4),
        iString: r.data.getUint8(5)
    };
}

function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

async function waitState(target){
    for (let i=0;i<50;i++){
        const s = await getStatus();
        if (s.state === target) return s;
        if (s.state === 5) await sleep(s.pollTimeout); // dfuDNLOAD_BUSY
        else if (s.state === 2 || s.state === 9) await sleep(10); // dfuIDLE/dfuMANIFEST
        else log("State: "+s.state+" Status: "+s.status);
    }
    throw new Error("Timeout waiting for state " + target);
}

function makeSetAddressCommand(addrHex){
    const addr = parseInt(addrHex,16) >>> 0;
    // ST DfuSe SET ADDRESS POINTER command: 0x21 followed by 4 little-endian bytes
    const buf = new Uint8Array(5);
    buf[0] = 0x21;
    buf[1] = addr & 0xFF;
    buf[2] = (addr>>8)&0xFF;
    buf[3] = (addr>>16)&0xFF;
    buf[4] = (addr>>24)&0xFF;
    return buf;
}

// Build padded contiguous buffer from sparse HEX segments (fills gaps with 0xFF)
function buildPaddedHexBuffer(hexInfo){
    if (!hexInfo || !hexInfo.segments || !hexInfo.segments.length) throw new Error('No HEX segments');
    const firstAddr = hexInfo.segments[0].address;
    const lastSeg = hexInfo.segments[hexInfo.segments.length-1];
    const endAddr = lastSeg.address + lastSeg.data.length;
    const totalSize = endAddr - firstAddr;
    const buf = new Uint8Array(totalSize);
    buf.fill(0xFF);
    let filled = 0;
    for (const seg of hexInfo.segments){
        buf.set(seg.data, seg.address - firstAddr);
        filled += seg.data.length;
    }
    return { baseAddress:firstAddr, bytes:buf, totalSize, filledBytes:filled, gapBytes: totalSize - filled };
}

// ===== DfuSe (.dfu) container parser (minimal) =====
// Supports typical ST DfuSe layout: Prefix, one or more Target prefixes, Elements, optional 16-byte suffix.
// We only use the first target's elements; if >1 element we warn and only flash the first.
function parseDfuSe(buffer){
    if (!buffer || buffer.byteLength < 32) throw new Error('DFU file too small');
    const bytes = new Uint8Array(buffer);
    // Check signature 'DfuSe' at start
    if (String.fromCharCode(bytes[0],bytes[1],bytes[2],bytes[3],bytes[4]) !== 'DfuSe') throw new Error('Not a DfuSe container');
    const dv = new DataView(buffer);
    const version = dv.getUint8(5);
    const imageSize = dv.getUint32(6, true); // total size (may exclude suffix)
    const numTargets = dv.getUint8(10);
    let off = 11;
    const segments = [];
    for (let ti=0; ti<numTargets; ti++){
        // Target prefix signature 'Target'
        if (off + 6 > buffer.byteLength) throw new Error('Unexpected EOF before target signature');
        const sig = String.fromCharCode(bytes[off],bytes[off+1],bytes[off+2],bytes[off+3],bytes[off+4],bytes[off+5]);
        if (sig !== 'Target') throw new Error('Bad target signature: '+sig);
        off += 6;
        if (off + 1 + 1 + 255 + 4 + 4 > buffer.byteLength) throw new Error('Truncated target header');
        const altSetting = dv.getUint8(off); off += 1;
        const named = dv.getUint8(off); off += 1;
        // 255-byte name field (may contain terminating 0) regardless of named flag
        const nameBytes = bytes.slice(off, off+255); off += 255;
        let name = '';
        for (let i=0;i<nameBytes.length;i++){ if (nameBytes[i]===0) break; name += String.fromCharCode(nameBytes[i]); }
        const targetSize = dv.getUint32(off, true); off += 4;
        const numElements = dv.getUint32(off, true); off += 4;
        for (let ei=0; ei<numElements; ei++){
            if (off + 8 > buffer.byteLength) throw new Error('Truncated element header');
            const addr = dv.getUint32(off, true); off += 4;
            const size = dv.getUint32(off, true); off += 4;
            if (off + size > buffer.byteLength) throw new Error('Element data truncated');
            const data = bytes.slice(off, off+size);
            off += size;
            segments.push({ address: addr >>> 0, data, targetAlt: altSetting, targetName: name, targetIndex: ti, elementIndex: ei });
        }
    }
    // Ignore suffix (16 bytes) if present; not needed for programming.
    return { version, imageSize, numTargets, segments };
}
function describeSegments(info){
    return info.segments.map(s => `seg t${s.targetIndex}e${s.elementIndex} addr=0x${s.address.toString(16).padStart(8,'0')} size=${s.data.length}`).join(', ');
}

async function flash(){
    // Prefer user-selected file; fall back to bundled auto firmware.
    let file = document.getElementById('fw').files[0];
    let fw;
    let sourceLabel;
    if (file) {
        const arrayBuf = await file.arrayBuffer();
        let parsedInfo = null;
        if (/\.dfu$/i.test(file.name)) {
            try {
                parsedInfo = parseDfuSe(arrayBuf);
                log('Parsed DfuSe: version='+parsedInfo.version+' targets='+parsedInfo.numTargets+' segments='+parsedInfo.segments.length);
                log('Segments: '+describeSegments(parsedInfo));
            } catch (e) {
                log('DfuSe parse failed (will treat as raw): '+e.message);
            }
        }
        let hexInfo = null;
        if (!parsedInfo && /\.hex$/i.test(file.name)) {
            try {
                hexInfo = parseIntelHex(new TextDecoder().decode(arrayBuf));
                log('Parsed HEX: segments='+hexInfo.segmentsCount+' base=0x'+hexInfo.baseAddress.toString(16).toUpperCase());
                if (hexInfo.hadGaps) log('HEX gaps detected; will skip gaps (no erase / pad).');
                for (let i=0;i<hexInfo.segments.length;i++) {
                    const s = hexInfo.segments[i];
                    log(`HEX segment ${i+1}: addr=0x${s.address.toString(16).toUpperCase().padStart(8,'0')} size=${s.data.length}`);
                }
            } catch (e) {
                log('HEX parse failed: '+e.message);
            }
        }
        if (parsedInfo && parsedInfo.segments.length) {
            const first = parsedInfo.segments[0];
            fw = first.data;
            // Auto-fill base address field (user can override; SetAddr optional)
            const baseEl = document.getElementById('base');
            if (baseEl) baseEl.value = first.address.toString(16).toUpperCase().padStart(8,'0');
            if (parsedInfo.segments.length > 1) {
                log('WARNING: Multiple segments detected; flashing only first (address 0x'+first.address.toString(16).padStart(8,'0')+').');
            }
            sourceLabel = 'user DfuSe first segment '+file.name;
        } else if (hexInfo) {
            // For sparse HEX: flash segments one by one later; here we set fw to first segment for size display only.
            const baseEl = document.getElementById('base'); if (baseEl) baseEl.value = hexInfo.baseAddress.toString(16).toUpperCase().padStart(8,'0');
            fw = hexInfo.segments[0].data;
            sourceLabel = 'user HEX first segment '+file.name;
            // Store hexInfo for multi-segment flashing
            flash._hexInfo = hexInfo;
        } else {
            fw = new Uint8Array(arrayBuf);
            sourceLabel = 'user file '+file.name;
        }
    } else {
        const autoFw = await fetchAutoFirmware();
        if (!autoFw) { log('No firmware file selected and auto firmware missing.'); return; }
        fw = autoFw.bytes;
        sourceLabel = 'auto firmware ' + autoFw.name;
        // If auto firmware provided HEX segments, expose them for multi-segment flashing
        if (autoFw.segments && autoFw.segmentsCount > 1) {
            flash._hexInfo = {
                segments: autoFw.segments,
                segmentsCount: autoFw.segmentsCount,
                hadGaps: autoFw.hadGaps
            };
        }
    }
    transferSize = parseInt(document.getElementById('xfer').value,10);
    const baseAddr = document.getElementById('base').value.trim();
    let useSetAddr = document.getElementById('useSetAddr').checked;
    const padGaps = document.getElementById('padGaps').checked;
    log('Using ' + sourceLabel + ' (' + fw.length + ' bytes)');
    // When Set Address unchecked we still treat base address as informational start.
    if (!useSetAddr && baseAddr) {
        log('Base address (informational): 0x'+baseAddr.toUpperCase());
    }
    async function flashSingleBuffer(baseAddressHex, data){
        let blockNum = 0;
        if (useSetAddr && baseAddressHex){
            try {
                log('Set Address 0x'+baseAddressHex);
                await dnload(blockNum++, makeSetAddressCommand(baseAddressHex));
                await waitState(2);
            } catch (e) { log('Set Address failed: '+e.message); throw e; }
        }
        const total = data.length;
        let offset = 0;
        while (offset < total){
            const chunkSize = Math.min(transferSize, total - offset);
            const chunk = data.slice(offset, offset + chunkSize);
            try {
                log(`DNLOAD block ${blockNum} size ${chunkSize}`);
                await dnload(blockNum++, chunk);
            } catch (e) {
                log('DNLOAD transfer error at block '+blockNum+': '+e.message);
                try { const s = await getStatus(); log(`Status after error: status=${s.status} state=${s.state} poll=${s.pollTimeout}`); } catch {}
                throw e;
            }
            const st = await getStatus();
            if (st.state === 5) await sleep(st.pollTimeout);
            await waitState(2);
            offset += chunkSize;
            updateProgress(offset/total*100);
        }
        await dnload(blockNum, new Uint8Array());
        log('Segment manifesting...');
        await waitManifest();
        log('Segment done.');
    }
    // If multi-segment HEX stored
    if (flash._hexInfo && flash._hexInfo.segmentsCount > 1){
        const info = flash._hexInfo;
        // Auto-enable Set Address if needed (gaps or multiple segments) to honor per-segment base addresses
        if ((info.hadGaps || info.segmentsCount > 1) && !useSetAddr){
            useSetAddr = true;
            const cb = document.getElementById('useSetAddr');
            if (cb) cb.checked = true;
            log('Auto-enabled Set Address (multi-segment HEX / gaps detected).');
        }
        // Quick capability probe: try Set Address for first segment only (if enabled)
        let setAddrSupported = true;
        if (useSetAddr){
            try {
                log('Probing Set Address support...');
                await dnload(0, makeSetAddressCommand(info.segments[0].address.toString(16).toUpperCase().padStart(8,'0')));
                await waitState(2);
                log('Set Address supported.');
            } catch (e) {
                log('Set Address command failed; bootloader likely does not support vendor 0x21. Falling back to sequential flashing of first contiguous region only.');
                setAddrSupported = false;
                useSetAddr = false;
                const cb = document.getElementById('useSetAddr'); if (cb) cb.checked = false;
            }
        }
        // Flash logic depending on support
        if (!setAddrSupported){
            if (padGaps){
                log('Set Address unsupported; building padded contiguous image...');
                const padded = buildPaddedHexBuffer(info);
                log(`Padded image size=${padded.totalSize} filled=${padded.filledBytes} gapBytes=${padded.gapBytes}`);
                const baseHex = padded.baseAddress.toString(16).toUpperCase().padStart(8,'0');
                await flashSingleBuffer(baseHex, padded.bytes);
                log('Padded HEX image flashed (all segments and gaps).');
            } else {
                // Flash only contiguous starting region
                const first = info.segments[0];
                const addrHex = first.address.toString(16).toUpperCase().padStart(8,'0');
                log(`Flashing only first contiguous segment addr=0x${addrHex} size=${first.data.length}. Enable padding to include remaining sparse segments.`);
                await flashSingleBuffer(addrHex, first.data);
                let currentEnd = first.address + first.data.length;
                for (let i=1;i<info.segments.length;i++){
                    const seg = info.segments[i];
                    if (seg.address === currentEnd){
                        const aHex = seg.address.toString(16).toUpperCase().padStart(8,'0');
                        log(`Flashing additional contiguous segment addr=0x${aHex} size=${seg.data.length}`);
                        await flashSingleBuffer(aHex, seg.data);
                        currentEnd = seg.address + seg.data.length;
                    } else {
                        log(`Skipping non-contiguous segment ${i+1} addr=0x${seg.address.toString(16).toUpperCase().padStart(8,'0')} size=${seg.data.length}`);
                    }
                }
                log('Sparse HEX fallback complete.');
            }
        } else {
            // First segment already consumed block 0 for probe; adjust flashSingleBuffer to start at correct block number by sending Set Address again inside.
            for (let i=0;i<info.segments.length;i++){
                const seg = info.segments[i];
                const addrHex = seg.address.toString(16).toUpperCase().padStart(8,'0');
                log(`Flashing HEX segment ${i+1}/${info.segments.length} addr=0x${addrHex} size=${seg.data.length}`);
                await flashSingleBuffer(addrHex, seg.data);
            }
            log('All HEX segments flashed.');
        }
    } else {
        await flashSingleBuffer(baseAddr, fw);
        log('Flash complete.');
    }
}

async function waitManifest(){
    for(;;){
        const s = await getStatus();
        if (s.state === 8){ // dfuMANIFEST_SYNC
            await sleep(s.pollTimeout);
        } else if (s.state === 9){ // dfuMANIFEST
            await sleep(10);
        } else if (s.state === 10 || s.state === 2){ // dfuMANIFEST_WAIT_RESET / idle (wDetach)
            break;
        } else {
            await sleep(10);
        }
    }
}

async function leave(){
    log("Sending DETACH");
    await control(DFU.DETACH, 1000, dfuInterface);
    log("Device should reset into application.");
}

async function abort(){
    log("ABORT");
    await control(DFU.ABORT,0,dfuInterface);
}

function updateProgress(p){
    document.getElementById('bar').style.width = p.toFixed(2)+'%';
}

document.getElementById('connect').onclick = ()=>connect().catch(e=>log("Err: "+e.message));
document.getElementById('flash').onclick = ()=>flash().catch(async e=>{
    log("Flash error: " + e.message);
    try {
        const s = await getStatus();
        log(`Final status dump: status=${s.status} state=${s.state} poll=${s.pollTimeout}`);
    } catch {}
});
document.getElementById('abort').onclick = ()=>abort().catch(e=>log("Abort error: "+e.message));
document.getElementById('leave').onclick = ()=>leave().catch(e=>log("Leave error: "+e.message));

// Inspect firmware file immediately on selection (HEX/DfuSe) and list segments
(function initFirmwareInspector(){
    const input = document.getElementById('fw');
    if (!input) return;
    input.addEventListener('change', async () => {
        const f = input.files && input.files[0];
        if (!f) return;
        log('Selected file: ' + f.name + ' (' + f.size + ' bytes)');
        const lower = f.name.toLowerCase();
        try {
            const buf = await f.arrayBuffer();
            if (lower.endsWith('.hex')) {
                try {
                    const text = new TextDecoder().decode(buf);
                    const info = parseIntelHex(text);
                    log('HEX parsed: segments=' + info.segmentsCount + ' base=0x' + info.baseAddress.toString(16).toUpperCase());
                    const maxList = 100;
                    for (let i=0;i<info.segments.length && i<maxList;i++) {
                        const s = info.segments[i];
                        log(`HEX segment ${i+1}: addr=0x${s.address.toString(16).toUpperCase().padStart(8,'0')} size=${s.data.length}`);
                    }
                    if (info.segments.length > maxList) log(`HEX segment list truncated (${info.segments.length} total).`);
                    if (info.hadGaps) log('HEX gaps detected; will require Set Address for sparse flashing.');
                } catch (e) {
                    log('HEX parse error: ' + e.message);
                }
            } else if (lower.endsWith('.dfu')) {
                try {
                    const info = parseDfuSe(buf);
                    log('DfuSe parsed: version=' + info.version + ' targets=' + info.numTargets + ' segments=' + info.segments.length);
                    info.segments.forEach((s,i)=>log(`DFU segment ${i+1}: addr=0x${s.address.toString(16).toUpperCase().padStart(8,'0')} size=${s.data.length}`));
                } catch (e) {
                    log('DfuSe parse error: ' + e.message);
                }
            } else {
                log('Unknown file extension; treating as raw binary.');
            }
        } catch (e) {
            log('File read error: ' + e.message);
        }
    });
})();

// Feature detection
if (!('usb' in navigator)){
    log("WebUSB not supported in this browser.");
}
// Protocol note
log('Assuming USB DFU protocol 1.1 (standard). Vendor Set Address (0x21) may be unsupported on generic DFU 1.1 bootloaders.');
</script>
</body>
</html>