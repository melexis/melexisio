<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>MIP Terminal</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Bootstrap 5 CDN -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
  <style>
    :root { 
      color-scheme: light dark; 
      --theme-green: #198754; /* accent */
      --bg-green: #0A3622; /* deeper green background */
      --text-on-green: #f2f8f4;
      --panel-bg: rgba(255,255,255,0.06);
      --panel-bg-solid: #0f3a27;
      --panel-border: rgba(255,255,255,0.18);
      --muted-on-green: #c4d8ce;
    }
    /* Make the page a column flex layout */
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      margin: 0;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      background: var(--bg-green);
      color: var(--text-on-green);
    }
    /* Header bar */
    #header {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: .75rem 1rem;
      border-bottom: 1px solid var(--panel-border);
      background: rgba(0,0,0,0.18);
      backdrop-filter: blur(3px);
    }
    #header .title {
      font-size: 1.5rem;
      font-weight: 600;
      text-align: center;
    }

    /* App area */
    #app {
      display: flex;
      flex: 1 1 auto;
      min-height: 0;
    }

  #sidebar h2 { margin: .25rem 0; font-size: 1.05rem; }
  .muted { opacity: 1; font-size: .8em; color: var(--muted-on-green); }
    #historyList {
      display: flex; flex-direction: column; gap: .25rem; max-height: 40vh; overflow: auto; margin-top: .25rem;
    }
    .hist-item {
      text-align: left; padding: .35rem .5rem; border: 1px solid var(--panel-border); background: var(--panel-bg);
      border-radius: .375rem; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      color: var(--text-on-green);
    }
    .hist-item:hover { background: rgba(255,255,255,0.12); }

    #main {
      flex: 1 1 auto;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }
  fieldset { margin: 0 0 6px 0; background: var(--panel-bg); border:1px solid var(--panel-border); border-radius: .75rem; }
  legend { padding: 0 .5rem; font-weight:600; }
    .bootstrap-tabs { margin-top: 6px; }
    /* Remove custom tab styling (handled by Bootstrap) */
  .bootstrap-tabs .nav-link { cursor: pointer; }

    /* Fixed-height log with scrollbars */
    #log {
      width: 100%;
      height: 50vh;      /* reduced to 50% viewport height */
      max-height: calc(100vh - 260px); /* safeguard relative to other UI */
      box-sizing: border-box;
      white-space: pre-wrap;
      overflow: auto;    /* scrollbars when content expands */
      border: 1px solid var(--panel-border);
      padding: .5rem;
      background: #112d21; /* adjusted to harmonize with deeper bg */
      color: #d9dedc;       /* default: response (RX) gray */
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    }

    /* Color coding for log entries */
  .log-echo { color: #4db2ff; }    /* brighter blue for local echo (TX) */
  .log-rx   { color: #d9dedc; }    /* light gray for device response (RX) */
  .log-okprompt { color: #59ffb0; }/* bright mint for "(OK)>" prompts */
  .log-badprompt { color: #ff7a7a; }/* softer red for non-OK prompts */
  .log-error { color: #ff5252; }   /* vivid error red */
    
    #row { display: flex; gap: .5rem; margin-top: .5rem; flex-wrap: wrap; }
    input[type="text"] { flex: 1 1 320px; }
    .controls { display: flex; gap: .5rem; flex-wrap: wrap; align-items: center; }
    .spacer { flex: 1 1 auto; }
    button { cursor: pointer; }
    button { cursor: pointer; }
    /* Themed elements */
  .btn-primary { background-color: #125f3d; border-color: #0f5235; }
  .btn-primary:hover, .btn-primary:focus { background-color: #0f5235; border-color: #0c452c; }
  .btn-secondary { background-color: #355846; border-color: #2b4638; color:#e6fff2; }
  .btn-secondary:hover { background-color: #2b4638; }
  .btn-success { background:#1e9d62; border-color:#198754; }
  .btn-success:hover { background:#198754; }
  .btn-outline-primary { color: #e6fff2; border-color: #59ffb0; }
  .btn-outline-primary:hover { background:#59ffb0; color:#08301f; }
  .btn-outline-danger { color: #ffc8c8; border-color: #ff7a7a; }
  .btn-outline-danger:hover { background:#ff7a7a; color:#300; }
  .btn-outline-secondary { color:#e2efe7; border-color:#88b6a1; }
  .btn-outline-secondary:hover { background:#88b6a1; color:#10241b; }
  .btn-outline-warning { color:#ffe8a6; border-color:#ffda6a; }
  .btn-outline-warning:hover { background:#ffda6a; color:#3a2d00; }
  .btn-outline-info { color:#c2ecff; border-color:#74d2ff; }
  .btn-outline-info:hover { background:#74d2ff; color:#002a38; }
  .nav-tabs { border-color: var(--panel-border); }
  .nav-tabs .nav-link { color: var(--text-on-green); }
  .nav-tabs .nav-link.active { background: rgba(0,0,0,0.35); color: #fff; border-color: var(--panel-border) var(--panel-border) transparent; }
  .tab-content { background: var(--panel-bg); border:1px solid var(--panel-border); border-top: none; padding: .75rem .75rem; border-radius: 0 0 .75rem .75rem; }
  .form-control, .form-select { background:#123d2a; border:1px solid #1d5a3d; color:#e6fff2; }
  .form-control:focus, .form-select:focus { background:#14452f; color:#fff; border-color:#59ffb0; box-shadow:0 0 0 .15rem rgba(89,255,176,0.25); }
  input::placeholder { color:#b7d5c6; }
  hr { border-color: var(--panel-border); }
    select, input[type="number"] { width: 8rem; }
    @media (max-width: 800px) {
      #sidebar { width: 180px; }
      select, input[type="number"] { width: 7rem; }
    }

    .section-title { margin: 0 0 .5rem 0; font-weight: 600; }
  </style>
</head>
<body>
  <header id="header" role="banner">
    <div class="title">MIP Terminal</div>
  </header>

  <div id="app">
    <!-- Sidebar removed: content moved to Terminal tab -->

    <main id="main">
      <fieldset>
        <div class="controls d-flex flex-wrap align-items-end gap-2">
          <label class="form-label mb-0">Baud:
            <input id="baud" class="form-control form-control-sm" type="number" value="115200" min="50" step="50" />
          </label>
          <label class="form-label mb-0">Data bits:
            <select id="databits" class="form-select form-select-sm">
              <option>8</option>
              <option selected>7</option>
            </select>
          </label>
          <label class="form-label mb-0">Parity:
            <select id="parity" class="form-select form-select-sm">
              <option value="none">none</option>
              <option value="even">even</option>
              <option value="odd" selected>odd</option>
            </select>
          </label>
          <label class="form-label mb-0">Stop bits:
            <select id="stopbits" class="form-select form-select-sm">
              <option>1</option>
              <option selected>2</option>
            </select>
          </label>
            <label class="form-label mb-0">Flow:
              <select id="flow" class="form-select form-select-sm">
                <option value="none" selected>none</option>
                <option value="hardware">hardware (RTS/CTS)</option>
              </select>
            </label>
          <button id="connect" class="btn btn-primary btn-sm">Connect…</button>
          <button id="disconnect" class="btn btn-secondary btn-sm" disabled>Disconnect</button>
          <span id="status" class="muted small"></span>
        </div>
      </fieldset>

      <ul class="nav nav-tabs bootstrap-tabs" id="mainTabs" role="tablist">
        <li class="nav-item" role="presentation">
          <button class="nav-link active" id="terminal-tab" data-bs-toggle="tab" data-bs-target="#tab1" type="button" role="tab" aria-controls="tab1" aria-selected="true">Terminal</button>
        </li>
        <li class="nav-item" role="presentation">
          <button class="nav-link" id="settings-tab" data-bs-toggle="tab" data-bs-target="#tab2" type="button" role="tab" aria-controls="tab2" aria-selected="false">Settings</button>
        </li>
        <li class="nav-item" role="presentation">
          <button class="nav-link" id="scan-tab" data-bs-toggle="tab" data-bs-target="#tab3" type="button" role="tab" aria-controls="tab3" aria-selected="false">Scan</button>
        </li>
      </ul>
      <div class="tab-content pt-3" id="mainTabsContent">
      <div class="tab-pane fade show active" id="tab1" role="tabpanel" aria-labelledby="terminal-tab">
        <div style="display: flex; flex-wrap: wrap; gap: 2rem; align-items: flex-start;">
          <div style="flex:1 1 0;min-width:320px;">
            <div id="log" aria-live="polite"></div>
            <div id="row" class="d-flex flex-column gap-2">
              <div class="d-flex flex-nowrap align-items-stretch gap-1 w-100">
                <input id="tx" class="form-control form-control-sm" type="text" placeholder="Type text to send" />
                <button id="send" class="btn btn-success btn-sm">Send</button>
              </div>
              <div class="d-flex flex-wrap align-items-center gap-2 w-100">
                <select id="eol" class="form-select form-select-sm" title="End-of-line to append on send" style="max-width:90px;">
                  <option value="">No EOL</option>
                  <option value="\n" selected>LF</option>
                  <option value="\r">CR</option>
                  <option value="\r\n">CRLF</option>
                </select>
                <label class="form-check form-check-inline mb-0"><input id="echo" class="form-check-input" type="checkbox" checked /><span class="form-check-label"> Local echo</span></label>
                <label class="form-check form-check-inline mb-0"><input id="enterSend" class="form-check-input" type="checkbox" checked /><span class="form-check-label"> Enter sends</span></label>
                <label class="form-check form-check-inline mb-0"><input id="autoScroll" class="form-check-input" type="checkbox" checked /><span class="form-check-label"> Auto-scroll</span></label>
                <span class="spacer" style="flex:1 1 auto;"></span>
                <button id="clear" class="btn btn-outline-warning btn-sm">Clear</button>
                <button id="save" class="btn btn-outline-info btn-sm">Save log</button>
              </div>
            </div>
          </div>
          <div id="sidebar" style="min-width:200px;max-width:260px;flex:0 0 220px;padding:0 0 0 0.5rem;border:0;">
            <h2>Commands</h2>
            <button id="cmd-id" class="btn btn-outline-primary btn-sm w-100 mb-1" title='Send "*IDN?"' disabled>ID</button>
            <button id="cmd-info" class="btn btn-outline-primary btn-sm w-100 mb-1" title='Send ":SYST:INFO"' disabled>INFO</button>
            <button id="cmd-rst" class="btn btn-outline-danger btn-sm w-100 mb-2" title='Send "*RST"' disabled>Reset</button>
            <hr />
            <h2>History</h2>
            <div class="muted">History records only text input (tx). Click to resend. Up/Down to recall.</div>
            <div id="historyList" aria-live="polite"></div>
            <button id="clearHistory" class="btn btn-outline-secondary btn-sm w-100">Clear history</button>
            <div class="muted">Buttons enable when connected.</div>
          </div>
        </div>
      </div>
      <div class="tab-pane fade" id="tab2" role="tabpanel" aria-labelledby="settings-tab">
        <div class="p-3">Tab 2 content goes here.</div>
      </div>
      <div class="tab-pane fade" id="tab3" role="tabpanel" aria-labelledby="scan-tab">
        <div class="p-3">Tab 3 content goes here.</div>
      </div>
      </div>
      <p class="muted">
        Works in Chrome/Edge desktop. Requires HTTPS or localhost. Only one app can hold the port at a time.
      </p>
    </main>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
  <script>
    // Serial
    let port, reader, writer, reading = false;
  let textDecoder, textEncoder;
  let readableStreamClosed, writableStreamClosed;

    // History (cookie-backed) — only for input #tx
    const HISTORY_COOKIE = 'mip_cmd_history';
    const HISTORY_MAX = 100;
    const HISTORY_SHOW = 20;
    // Newest-first order: history[0] is most recent
    let history = [];
    let historyIndex = -1;       // -1 = not navigating
    let draftBeforeNav = '';

    const $ = (id) => document.getElementById(id);
    const logEl = $('log');

    // Cookie utils (no regex to avoid escaping issues)
    function readCookie(name) {
      const prefix = name + '=';
      const parts = document.cookie ? document.cookie.split(';') : [];
      for (const part of parts) {
        const s = part.trim();
        if (s.startsWith(prefix)) {
          return decodeURIComponent(s.slice(prefix.length));
        }
      }
      return '';
    }
    function writeCookie(name, value, maxAgeSec) {
      document.cookie = name + '=' + encodeURIComponent(value) + '; path=/; max-age=' + maxAgeSec.toString();
    }
    function deleteCookie(name) {
      document.cookie = name + '=; path=/; max-age=0';
    }

    // History helpers
    function loadHistory() {
      try {
        const v = readCookie(HISTORY_COOKIE);
        if (!v) return [];
        const arr = JSON.parse(v);
        return Array.isArray(arr) ? arr.filter(s => typeof s === 'string') : [];
      } catch { return []; }
    }
    function saveHistory() {
      // Trim oldest items (at the end) to cap size
      while (history.length > HISTORY_MAX) history.pop();
      try {
        writeCookie(HISTORY_COOKIE, JSON.stringify(history), 60 * 60 * 24 * 365);
      } catch {
        while (history.length > Math.min(25, HISTORY_MAX)) history.pop();
        try { writeCookie(HISTORY_COOKIE, JSON.stringify(history), 60 * 60 * 24 * 365); } catch {}
      }
    }
    function addToHistory(cmd) {
      const c = (cmd ?? '').trim();
      if (!c) return;
      if (history[0] === c) return; // avoid immediate dup (top)
      // Newest-first: add to the top
      history.unshift(c);
      saveHistory();
      renderHistory();
    }
    function clearHistory() {
      history = [];
      deleteCookie(HISTORY_COOKIE);
      renderHistory();
    }
    function renderHistory() {
      const list = $('historyList');
      list.innerHTML = '';
      const end = Math.min(history.length, HISTORY_SHOW);
      for (let i = 0; i < end; i++) {
        const cmd = history[i];
        const btn = document.createElement('button');
        btn.className = 'hist-item';
        btn.textContent = cmd;
        btn.title = 'Click to resend';
        btn.addEventListener('click', () => sendCommand(cmd)); // resend, but do NOT add to history again
        list.appendChild(btn);
      }
    }

    function setStatus(msg) { $('status').textContent = msg || ''; }

    // Logging helpers (span-based to support colors)
    function appendLog(text, cls) {
      if (!text) return;
      const span = document.createElement('span');
      if (cls) span.className = cls;
      span.textContent = text; // preserves newlines safely
      logEl.appendChild(span);
      if ($('autoScroll').checked) logEl.scrollTop = logEl.scrollHeight;
    }
    function logEcho(text) { appendLog(text, 'log-echo'); }
    function logError(text) { appendLog(text, 'log-error'); }

    // Stream RX processing: color prompts only at real start-of-line,
    // do not inject any markers. Works across chunk boundaries.
    let atLineStart = true;
    function processRx(text) {
      let i = 0;
      while (i < text.length) {
        // If at start of a line, check for prompt "(...)>"
        if (atLineStart) {
          const slice = text.slice(i);
          const m = slice.match(/^\(([^)]+)\)>/);
          if (m) {
            const cls = m[1] === 'OK' ? 'log-okprompt' : 'log-badprompt';
            appendLog(m[0], cls);
            i += m[0].length;
            atLineStart = false;
            continue;
          }
        }
        // Append up to and including next newline (if any)
        const nl = text.indexOf('\n', i);
        if (nl === -1) {
          appendLog(text.slice(i), 'log-rx');
          // atLineStart unchanged
          break;
        } else {
          appendLog(text.slice(i, nl + 1), 'log-rx'); // includes the newline
          i = nl + 1;
          atLineStart = true;
        }
      }
    }

    // Decode literal option values ("\n", "\r", "\r\n") into actual control chars
    function eolValue() {
      const v = $('eol').value;
      if (v === '\\n') return '\n';
      if (v === '\\r') return '\r';
      if (v === '\\r\\n') return '\r\n';
      return '';
    }
    function setCommandButtonsEnabled(enabled) {
      $('cmd-id').disabled = !enabled;
      $('cmd-info').disabled = !enabled;
      $('cmd-rst').disabled = !enabled;
    }

    async function connect() {
      if (!('serial' in navigator)) {
        alert('Web Serial API not supported in this browser. Use Chrome or Edge (desktop).');
        return;
      }
      try {
        // Always request a new port
        port = await navigator.serial.requestPort();
        const opts = {
          baudRate: parseInt($('baud').value, 10) || 115200,
          dataBits: parseInt($('databits').value, 10) || 7,
          stopBits: parseInt($('stopbits').value, 10) || 2,
          parity: $('parity').value || 'odd',
          flowControl: $('flow').value || 'none',
        };
        await port.open(opts);

  textDecoder = new TextDecoderStream();
  textEncoder = new TextEncoderStream();

  // Keep references to piping promises so we can await them on disconnect
  readableStreamClosed = port.readable.pipeTo(textDecoder.writable);
  writableStreamClosed = textEncoder.readable.pipeTo(port.writable);

        reader = textDecoder.readable.getReader();
        writer = textEncoder.writable.getWriter();

        $('connect').disabled = true;
        $('disconnect').disabled = false;
        setCommandButtonsEnabled(true);
        setStatus('Connected');

        // Auto query on connect (not recorded in history)
        await sendCommand('*idn?');

        reading = true;
        (async () => {
          try {
            while (reading) {
              const { value, done } = await reader.read();
              if (done) break;
              if (value) processRx(value);
            }
          } catch (err) {
            console.error('Read error:', err);
            setStatus('Read error: ' + err.message);
          } finally {
            try { reader.releaseLock(); } catch {}
          }
        })();

      } catch (err) {
        console.error('Connect failed:', err);
        alert('Failed to connect: ' + err.message);
        setStatus('Disconnected');
        setCommandButtonsEnabled(false);
      }
    }

    async function disconnect() {
      try {
        setStatus('Disconnecting…');
        reading = false;
        // Stop reading
        try {
          if (reader) {
            await reader.cancel();
            try { reader.releaseLock && reader.releaseLock(); } catch {}
          }
        } catch {}
        // Stop writing
        try {
          if (writer) {
            await writer.close();
            try { writer.releaseLock && writer.releaseLock(); } catch {}
          }
        } catch {}
        // Wait for the piping to finish
        try { if (readableStreamClosed) await readableStreamClosed.catch(() => {}); } catch {}
        try { if (writableStreamClosed) await writableStreamClosed.catch(() => {}); } catch {}
        // Finally close the port
        try { if (port) await port.close(); } catch {}
      } finally {
        // Do not set port to null, so it can be reused
        reader = null;
        writer = null;
        readableStreamClosed = null;
        writableStreamClosed = null;
        textDecoder = null;
        textEncoder = null;
        $('connect').disabled = false;
        $('disconnect').disabled = true;
        setCommandButtonsEnabled(false);
        setStatus('Disconnected');
      }
    }

    async function send() {
      if (!writer) { setStatus('Not connected'); return; }
      const raw = $('tx').value;
      const text = raw + eolValue();
      try {
        await writer.write(text);
        addToHistory(raw); // only add from input tx
        if ($('echo').checked) logEcho(text);
        $('tx').value = '';
        historyIndex = -1; draftBeforeNav = '';
        $('tx').focus();
      } catch (err) {
        console.error('Write error:', err);
        setStatus('Write error: ' + err.message);
      }
    }

    async function sendCommand(cmd) {
      if (!writer) { setStatus('Not connected'); return; }
      const text = cmd + eolValue();
      try {
        await writer.write(text);
        // Do NOT add to history here (buttons and auto commands excluded)
        if ($('echo').checked) logEcho(text);
      } catch (err) {
        console.error('Write error:', err);
        setStatus('Write error: ' + err.message);
      }
    }

    function clearLog() { logEl.textContent = ''; }

    function saveLog() {
      const blob = new Blob([logEl.textContent], { type: 'text/plain;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      const ts = new Date().toISOString().replace(/[:.]/g, '-');
      a.download = `serial-log-${ts}.txt`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    // Events
    $('connect').addEventListener('click', connect);
    $('disconnect').addEventListener('click', disconnect);
    $('send').addEventListener('click', send);
    $('clear').addEventListener('click', clearLog);
    $('save').addEventListener('click', saveLog);

    $('cmd-id').addEventListener('click', () => sendCommand('*IDN?'));
    $('cmd-info').addEventListener('click', () => sendCommand(':SYST:INFO'));
    $('cmd-rst').addEventListener('click', () => sendCommand('*RST'));

    // Arrow Up/Down history navigation in input (newest-first order)
    $('tx').addEventListener('keydown', (e) => {
      if ($('enterSend').checked && e.key === 'Enter') {
        e.preventDefault();
        $('send').click();
        return;
      }
      if (e.key === 'ArrowUp') {
        e.preventDefault();
        if (history.length === 0) return;
        if (historyIndex === -1) {
          draftBeforeNav = $('tx').value;
          historyIndex = 0; // most recent
        } else {
          historyIndex = Math.min(history.length - 1, historyIndex + 1); // go to older
        }
        $('tx').value = history[historyIndex] ?? '';
        $('tx').setSelectionRange($('tx').value.length, $('tx').value.length);
      } else if (e.key === 'ArrowDown') {
        e.preventDefault();
        if (history.length === 0) return;
        if (historyIndex === -1) {
          // nothing
        } else if (historyIndex > 0) {
          historyIndex--;
          $('tx').value = history[historyIndex] ?? '';
        } else {
          historyIndex = -1;
          $('tx').value = draftBeforeNav;
        }
        $('tx').setSelectionRange($('tx').value.length, $('tx').value.length);
      }
    });
    $('tx').addEventListener('input', () => {
      if (historyIndex !== -1) historyIndex = -1;
    });

    $('clearHistory').addEventListener('click', clearHistory);

    window.addEventListener('beforeunload', disconnect);

    // Init history on load
    history = loadHistory();
    renderHistory();
  </script>
</body>
</html>
