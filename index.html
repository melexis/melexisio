<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Melexis.IO</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Bootstrap 5 CDN -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
  <style>
    :root { 
      color-scheme: light dark; 
      --theme-green: #198754; /* accent */
      --bg-green: #0A3622; /* deeper green background */
      --text-on-green: #f2f8f4;
      --panel-bg: rgba(255,255,255,0.06);
      --panel-bg-solid: #0f3a27;
      --panel-border: rgba(255,255,255,0.18);
      --muted-on-green: #c4d8ce;
    }
    /* Make the page a column flex layout */
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      margin: 0;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      background: var(--bg-green);
      color: var(--text-on-green);
    }
    /* Header bar */
    #header {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: .75rem 1rem;
      border-bottom: 1px solid var(--panel-border);
      background: rgba(0,0,0,0.18);
      backdrop-filter: blur(3px);
    }
    #header .title {
      font-size: 1.5rem;
      font-weight: 600;
      text-align: center;
    }

    /* App area */
    #app {
      display: flex;
      flex: 1 1 auto;
      min-height: 0;
    }

  #sidebar h2 { margin: .25rem 0; font-size: 1.05rem; }
  .muted { opacity: 1; font-size: .8em; color: var(--muted-on-green); }
    #historyList {
      display: flex; flex-direction: column; gap: .25rem; max-height: 40vh; overflow: auto; margin-top: .25rem;
    }
    .hist-item {
      text-align: left; padding: .35rem .5rem; border: 1px solid var(--panel-border); background: var(--panel-bg);
      border-radius: .375rem; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      color: var(--text-on-green);
    }
    .hist-item:hover { background: rgba(255,255,255,0.12); }

    #main {
      flex: 1 1 auto;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }
  fieldset { margin: 0 0 6px 0; background: var(--panel-bg); border:1px solid var(--panel-border); border-radius: .75rem; }
  legend { padding: 0 .5rem; font-weight:600; }
    .bootstrap-tabs { margin-top: 6px; }
    /* Remove custom tab styling (handled by Bootstrap) */
  .bootstrap-tabs .nav-link { cursor: pointer; }

    /* Fixed-height log with scrollbars */
    #log {
      width: 100%;
      height: 50vh;      /* reduced to 50% viewport height */
      max-height: calc(100vh - 260px); /* safeguard relative to other UI */
      box-sizing: border-box;
      white-space: pre-wrap;
      overflow: auto;    /* scrollbars when content expands */
      border: 1px solid var(--panel-border);
      padding: .5rem;
      background: #112d21; /* adjusted to harmonize with deeper bg */
      color: #d9dedc;       /* default: response (RX) gray */
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    }

    /* Color coding for log entries */
  .log-echo { color: #4db2ff; }    /* brighter blue for local echo (TX) */
  .log-rx   { color: #d9dedc; }    /* light gray for device response (RX) */
  .log-okprompt { color: #59ffb0; }/* bright mint for "(OK)>" prompts */
  .log-badprompt { color: #ff7a7a; }/* softer red for non-OK prompts */
  .log-error { color: #ff5252; }   /* vivid error red */
    
    #row { display: flex; gap: .5rem; margin-top: .5rem; flex-wrap: wrap; }
    input[type="text"] { flex: 1 1 320px; }
  .controls { display: flex; gap: .5rem; flex-wrap: wrap; align-items: center; margin:4px; }
    .spacer { flex: 1 1 auto; }
    button { cursor: pointer; }
    button { cursor: pointer; }
  /* Compact TX bar */
  .tx-bar .btn, .tx-bar .form-control { padding-top: .2rem; padding-bottom: .2rem; line-height: 1.0; }
  .tx-bar { min-height: 0; }
    /* Themed elements */
  .btn-primary { background-color: #125f3d; border-color: #0f5235; }
  .btn-primary:hover, .btn-primary:focus { background-color: #0f5235; border-color: #0c452c; }
  .btn-secondary { background-color: #355846; border-color: #2b4638; color:#e6fff2; }
  .btn-secondary:hover { background-color: #2b4638; }
  .btn-success { background:#1e9d62; border-color:#198754; }
  .btn-success:hover { background:#198754; }
  .btn-outline-primary { color: #e6fff2; border-color: #59ffb0; }
  .btn-outline-primary:hover { background:#59ffb0; color:#08301f; }
  .btn-outline-danger { color: #ffc8c8; border-color: #ff7a7a; }
  .btn-outline-danger:hover { background:#ff7a7a; color:#300; }
  .btn-outline-secondary { color:#e2efe7; border-color:#88b6a1; }
  .btn-outline-secondary:hover { background:#88b6a1; color:#10241b; }
  .btn-outline-warning { color:#ffe8a6; border-color:#ffda6a; }
  .btn-outline-warning:hover { background:#ffda6a; color:#3a2d00; }
  .btn-outline-info { color:#c2ecff; border-color:#74d2ff; }
  .btn-outline-info:hover { background:#74d2ff; color:#002a38; }
  .nav-tabs { border-color: var(--panel-border); }
  .nav-tabs .nav-link { color: var(--text-on-green); }
  .nav-tabs .nav-link.active { background: rgba(0,0,0,0.35); color: #fff; border-color: var(--panel-border) var(--panel-border) transparent; }
  .tab-content { background: var(--panel-bg); border:1px solid var(--panel-border); border-top: none; padding: .75rem .75rem; border-radius: 0 0 .75rem .75rem; }
  .form-control, .form-select { background:#123d2a; border:1px solid #1d5a3d; color:#e6fff2; }
  .form-control:focus, .form-select:focus { background:#14452f; color:#fff; border-color:#59ffb0; box-shadow:0 0 0 .15rem rgba(89,255,176,0.25); }
  input::placeholder { color:#b7d5c6; }
  hr { border-color: var(--panel-border); }
    select, input[type="number"] { width: 8rem; }
    @media (max-width: 800px) {
      #sidebar { width: 180px; }
      select, input[type="number"] { width: 7rem; }
    }

    .section-title { margin: 0 0 .5rem 0; font-weight: 600; }
  </style>
</head>
<body>
  <header id="header" role="banner">
    <div class="title">Melexis.IO</div>
  </header>

  <div id="app">
    <!-- Sidebar removed: content moved to Terminal tab -->

    <main id="main">
      <fieldset>
        <div class="controls d-flex flex-wrap align-items-end gap-2">
          <button id="connect" class="btn btn-primary btn-sm">Connect…</button>
          <button id="disconnect" class="btn btn-secondary btn-sm" disabled>Disconnect</button>
          <span id="status" class="muted small"></span>
        </div>
      </fieldset>

      <ul class="nav nav-tabs bootstrap-tabs" id="mainTabs" role="tablist">
        <li class="nav-item" role="presentation">
          <button class="nav-link active" id="terminal-tab" data-bs-toggle="tab" data-bs-target="#tab1" type="button" role="tab" aria-controls="tab1" aria-selected="true">Terminal</button>
        </li>
        <li class="nav-item" role="presentation">
          <button class="nav-link" id="settings-tab" data-bs-toggle="tab" data-bs-target="#tab2" type="button" role="tab" aria-controls="tab2" aria-selected="false">Settings</button>
        </li>
        <li class="nav-item" role="presentation">
          <button class="nav-link" id="scan-tab" data-bs-toggle="tab" data-bs-target="#tab3" type="button" role="tab" aria-controls="tab3" aria-selected="false">Scan</button>
        </li>
        <li class="nav-item" role="presentation">
          <button class="nav-link" id="ir-tab" data-bs-toggle="tab" data-bs-target="#tab4" type="button" role="tab" aria-controls="tab4" aria-selected="false">IR Image</button>
        </li>
        <li class="nav-item" role="presentation">
          <button class="nav-link" id="pd-tab" data-bs-toggle="tab" data-bs-target="#tab5" type="button" role="tab" aria-controls="tab5" aria-selected="false">People Detection</button>
        </li>
      </ul>
      <div class="tab-content pt-3" id="mainTabsContent">
      <div class="tab-pane fade show active" id="tab1" role="tabpanel" aria-labelledby="terminal-tab">
        <div style="display: flex; flex-wrap: wrap; gap: 2rem; align-items: flex-start;">
          <div style="flex:1 1 0;min-width:320px;">
            <div id="log" aria-live="polite"></div>
            <div id="row" class="d-flex flex-column gap-2">
              <div class="d-flex flex-nowrap align-items-center gap-1 w-100 tx-bar">
                <button id="clear" class="btn btn-outline-warning btn-sm">Clear</button>
                <button id="save" class="btn btn-outline-info btn-sm">Save...</button>
                <input id="tx" class="form-control form-control-sm" type="text" placeholder="Type text to send" style="flex:1 1 auto;" />
                <button id="send" class="btn btn-success btn-sm">Send</button>
              </div>
            </div>
          </div>
          <div id="sidebar" style="min-width:200px;max-width:260px;flex:0 0 220px;padding:0 0 0 0.5rem;border:0;">
            <h2>Commands</h2>
            <button id="cmd-id" class="btn btn-outline-primary btn-sm w-100 mb-1" title='Send "*IDN?"' disabled>ID</button>
            <button id="cmd-info" class="btn btn-outline-primary btn-sm w-100 mb-1" title='Send ":SYST:INFO"' disabled>INFO</button>
            <button id="cmd-rst" class="btn btn-outline-danger btn-sm w-100 mb-2" title='Send "*RST"' disabled>Reset</button>
            <hr />
            <h2>History</h2>
            <div class="muted">History records only text input (tx). Click to resend. Up/Down to recall.</div>
            <div id="historyList" aria-live="polite"></div>
            <button id="clearHistory" class="btn btn-outline-secondary btn-sm w-100">Clear history</button>
            <div class="muted">Buttons enable when connected.</div>
          </div>
        </div>
      </div>
      <div class="tab-pane fade" id="tab2" role="tabpanel" aria-labelledby="settings-tab">
        <div class="p-3">
          <h5 class="mb-2">Settings</h5>
          <div class="row g-3">
            <div class="col-12 col-lg-6">
              <fieldset class="p-2" style="border-radius:.5rem;">
                <legend class="float-none w-auto px-2 small mb-0">Connection</legend>
                <div class="d-flex flex-wrap align-items-end gap-3 mb-2 mt-1">
                  <label class="form-label mb-0">Baud:
                    <input id="baud" class="form-control form-control-sm" type="number" value="115200" min="50" step="50" />
                  </label>
                  <label class="form-label mb-0">Data bits:
                    <select id="databits" class="form-select form-select-sm">
                      <option>8</option>
                      <option selected>7</option>
                    </select>
                  </label>
                  <label class="form-label mb-0">Parity:
                    <select id="parity" class="form-select form-select-sm">
                      <option value="none">none</option>
                      <option value="even">even</option>
                      <option value="odd" selected>odd</option>
                    </select>
                  </label>
                  <label class="form-label mb-0">Stop bits:
                    <select id="stopbits" class="form-select form-select-sm">
                      <option>1</option>
                      <option selected>2</option>
                    </select>
                  </label>
                  <label class="form-label mb-0">Flow:
                    <select id="flow" class="form-select form-select-sm">
                      <option value="none" selected>none</option>
                      <option value="hardware">hardware (RTS/CTS)</option>
                    </select>
                  </label>
                </div>
              </fieldset>
              <p class="small mt-2 mb-0">Baud rate, data bits, parity, stop bits, and flow control selections are saved and restored (localStorage).</p>
            </div>
            <div class="col-12 col-lg-6">
              <fieldset class="p-2 mb-3" style="border-radius:.5rem;">
                <legend class="float-none w-auto px-2 small mb-0">Input options</legend>
                <div class="d-flex flex-wrap align-items-center gap-3 mt-1">
                  <label class="form-label mb-0">EOL:
                    <select id="eol" class="form-select form-select-sm" title="End-of-line to append on send" style="max-width:100px;">
                      <option value="">No EOL</option>
                      <option value="\n" selected>LF</option>
                      <option value="\r">CR</option>
                      <option value="\r\n">CRLF</option>
                    </select>
                  </label>
                  <label class="form-check form-check-inline mb-0"><input id="echo" class="form-check-input" type="checkbox" checked /><span class="form-check-label"> Local echo</span></label>
                  <label class="form-check form-check-inline mb-0"><input id="enterSend" class="form-check-input" type="checkbox" checked /><span class="form-check-label"> Enter sends</span></label>
                  <label class="form-check form-check-inline mb-0"><input id="autoScroll" class="form-check-input" type="checkbox" checked /><span class="form-check-label"> Auto-scroll</span></label>
                </div>
              </fieldset>
              <fieldset class="p-2" style="border-radius:.5rem;">
                <legend class="float-none w-auto px-2 small mb-0">Actions</legend>
                <div class="d-flex flex-wrap align-items-center gap-2 mt-1">
                  <button id="resetSerialSettings" class="btn btn-outline-warning btn-sm">Reset to defaults</button>
                  <button id="exportSettings" class="btn btn-outline-info btn-sm" title="Download settings bundle (commands + parameters + IR)">Export settings</button>
                  <button id="importSettings" class="btn btn-outline-secondary btn-sm" title="Import settings bundle JSON">Import settings</button>
                  <button id="eepromSave" class="btn btn-outline-primary btn-sm" title="Save current settings to device EEPROM" disabled>Save to EEPROM</button>
                  <button id="eepromLoad" class="btn btn-outline-primary btn-sm" title="Load settings from device EEPROM" disabled>Load from EEPROM</button>
                  <input id="importSettingsFile" type="file" accept="application/json" style="display:none;" />
                </div>
              </fieldset>
            </div>
          </div>
        </div>
      </div>
      <div class="tab-pane fade" id="tab3" role="tabpanel" aria-labelledby="scan-tab">
        <div class="p-3">Tab 3 content goes here.</div>
      </div>
      <div class="tab-pane fade" id="tab4" role="tabpanel" aria-labelledby="ir-tab">
        <div class="p-3" id="irContainer">
          <div class="d-flex flex-wrap align-items-start gap-3">
            <div>
              <canvas id="irCanvas" width="640" height="480" style="border:1px solid var(--panel-border);background:#000;border-radius:4px;image-rendering:pixelated;max-width:100%;height:auto;"></canvas>
              <div id="irTooltip" style="position:absolute;pointer-events:none;z-index:20;padding:4px 6px;background:rgba(0,0,0,0.75);color:#fff;font:12px system-ui;border:1px solid #59ffb0;border-radius:4px;display:none;white-space:nowrap;transform:translate(8px,8px);"></div>
            </div>
            <div class="d-flex flex-column align-items-center" style="min-width:60px;">
              <canvas id="irLegend" width="40" height="480" style="border:1px solid var(--panel-border);border-radius:4px;"></canvas>
              <div class="w-100 small mt-2" style="text-align:center;line-height:1.1;">
                <div id="irMax">40.0</div>
                <div style="height:4px;"></div>
                <div id="irMin">0.10</div>
              </div>
            </div>
          </div>
          <div class="mt-3 small d-flex flex-wrap align-items-center gap-3">
            <span>Grid: <span id="irGridSize">32×24</span></span>
            <label class="form-label mb-0 d-flex align-items-center gap-1">Scale:
              <select id="irScaleSelect" class="form-select form-select-sm" style="max-width:70px;">
                <option value="1" selected>x1</option>
                <option value="2">x2</option>
                <option value="4">x4</option>
              </select>
            </label>
            <button id="irRead" class="btn btn-outline-primary btn-sm">Read</button>
            <button id="irContinuous" class="btn btn-outline-secondary btn-sm position-relative" data-active="0">Continuous</button>
            <span id="irRunning" style="width:10px;height:10px;border-radius:50%;background:#0d2219;box-shadow:0 0 4px #0d2219;transition:background-color .2s, box-shadow .2s;" title="Running status"></span>
            <button id="irSaveImage" class="btn btn-outline-info btn-sm">Save image</button>
            <button id="irExportData" class="btn btn-outline-secondary btn-sm">Export data</button>
            <label class="form-label mb-0 d-flex align-items-center gap-1" title="Show grid lines over heatmap (for scale x1/x2)">
              <input id="irShowGrid" type="checkbox" class="form-check-input" /> Grid
            </label>
            <label class="form-label mb-0 d-flex align-items-center gap-1" title="Show numeric cell values (scale x1 only to avoid clutter)">
              <input id="irShowValues" type="checkbox" class="form-check-input" /> Values
            </label>
          </div>
        </div>
      </div>
      <div class="tab-pane fade" id="tab5" role="tabpanel" aria-labelledby="pd-tab">
        <div class="p-3" id="pdContainer">
          <div class="d-flex flex-wrap align-items-start gap-3">
            <div>
              <canvas id="pdCanvas" width="640" height="480" style="border:1px solid var(--panel-border);background:#000;border-radius:4px;image-rendering:pixelated;max-width:100%;height:auto;"></canvas>
              <div id="pdTooltip" style="position:absolute;pointer-events:none;z-index:20;padding:4px 6px;background:rgba(0,0,0,0.75);color:#fff;font:12px system-ui;border:1px solid #59ffb0;border-radius:4px;display:none;white-space:nowrap;transform:translate(8px,8px);"></div>
            </div>
            <div class="d-flex flex-column align-items-center" style="min-width:60px;">
              <canvas id="pdLegend" width="40" height="480" style="border:1px solid var(--panel-border);border-radius:4px;"></canvas>
              <div class="w-100 small mt-2" style="text-align:center;line-height:1.1;">
                <div id="pdMax">40.0</div>
                <div style="height:4px;"></div>
                <div id="pdMin">0.10</div>
              </div>
            </div>
          </div>
          <div class="mt-3 small d-flex flex-wrap align-items-center gap-3">
            <span>Grid: <span id="pdGridSize">32×24</span></span>
            <label class="form-label mb-0 d-flex align-items-center gap-1">Scale:
              <select id="pdScaleSelect" class="form-select form-select-sm" style="max-width:70px;">
                <option value="1" selected>x1</option>
                <option value="2">x2</option>
                <option value="4">x4</option>
              </select>
            </label>
            <button id="pdRead" class="btn btn-outline-primary btn-sm">Read</button>
            <button id="pdContinuous" class="btn btn-outline-secondary btn-sm position-relative" data-active="0">Continuous</button>
            <span id="pdRunning" style="width:10px;height:10px;border-radius:50%;background:#0d2219;box-shadow:0 0 4px #0d2219;transition:background-color .2s, box-shadow .2s;" title="Running status"></span>
            <button id="pdSaveImage" class="btn btn-outline-info btn-sm">Save image</button>
            <button id="pdExportData" class="btn btn-outline-secondary btn-sm">Export data</button>
            <label class="form-label mb-0 d-flex align-items-center gap-1" title="Show grid lines (scale x1/x2)">
              <input id="pdShowGrid" type="checkbox" class="form-check-input" /> Grid
            </label>
            <label class="form-label mb-0 d-flex align-items-center gap-1" title="Show numeric cell values (scale x1 only)">
              <input id="pdShowValues" type="checkbox" class="form-check-input" /> Values
            </label>
          </div>
        </div>
      </div>
      </div>
      <p class="muted">
        Works in Chrome/Edge desktop. Requires HTTPS or localhost. Only one app can hold the port at a time.
      </p>
    </main>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
  <script>
  // Serial
  let port, reader, writer, reading = false;
  // Enhanced status info
  let connPortLabel = '';
  let awaitingIdnFirstLine = false;
  let connDescription = '';
  let textDecoder, textEncoder;
  let readableStreamClosed, writableStreamClosed;

    // History (cookie-backed) — only for input #tx
    const HISTORY_COOKIE = 'mip_cmd_history';
    const HISTORY_MAX = 100;
    const HISTORY_SHOW = 20;
    // Newest-first order: history[0] is most recent
    let history = [];
    let historyIndex = -1;       // -1 = not navigating
    let draftBeforeNav = '';

    const $ = (id) => document.getElementById(id);
    const logEl = $('log');

    /* ===== Serial settings persistence ===== */
    const SERIAL_SETTINGS_KEY = 'mip_serial_settings_v1';
    const SERIAL_DEFAULTS = { baud: 115200, databits: 7, parity: 'odd', stopbits: 2, flow: 'none' };

    function loadSerialSettings() {
      try {
        const raw = localStorage.getItem(SERIAL_SETTINGS_KEY);
        if (!raw) return { ...SERIAL_DEFAULTS };
        const obj = JSON.parse(raw);
        return { ...SERIAL_DEFAULTS, ...(obj && typeof obj === 'object' ? obj : {}) };
      } catch { return { ...SERIAL_DEFAULTS }; }
    }
    function saveSerialSettings(obj) {
      try { localStorage.setItem(SERIAL_SETTINGS_KEY, JSON.stringify(obj)); } catch {}
    }
    function currentSerialSettings() {
      return {
        baud: parseInt($('baud').value,10)||SERIAL_DEFAULTS.baud,
        databits: parseInt($('databits').value,10)||SERIAL_DEFAULTS.databits,
        parity: $('parity').value || SERIAL_DEFAULTS.parity,
        stopbits: parseInt($('stopbits').value,10)||SERIAL_DEFAULTS.stopbits,
        flow: $('flow').value || SERIAL_DEFAULTS.flow,
      };
    }
    function applySerialSettings(obj) {
      if (!obj) return;
      $('baud').value = obj.baud;
      $('databits').value = String(obj.databits);
      $('parity').value = obj.parity;
      $('stopbits').value = String(obj.stopbits);
      $('flow').value = obj.flow;
    }
    function persistAndDisplay() { saveSerialSettings(currentSerialSettings()); }
    /* ===== Input option persistence ===== */
    const INPUT_OPTIONS_KEY = 'mip_input_options_v1';
    const INPUT_DEFAULTS = { eol: '\n', echo: true, enterSend: true, autoScroll: true };
    function loadInputOptions() {
      try {
        const raw = localStorage.getItem(INPUT_OPTIONS_KEY);
        if (!raw) return { ...INPUT_DEFAULTS };
        const obj = JSON.parse(raw);
        return { ...INPUT_DEFAULTS, ...(obj && typeof obj === 'object' ? obj : {}) };
      } catch { return { ...INPUT_DEFAULTS }; }
    }
    function applyInputOptions(obj) {
      if (!obj) return;
      if ($('eol')) $('eol').value = obj.eol ?? INPUT_DEFAULTS.eol;
      if ($('echo')) $('echo').checked = !!obj.echo;
      if ($('enterSend')) $('enterSend').checked = !!obj.enterSend;
      if ($('autoScroll')) $('autoScroll').checked = !!obj.autoScroll;
    }
    function saveInputOptions() {
      try {
        const snap = {
          eol: $('eol') ? $('eol').value : INPUT_DEFAULTS.eol,
          echo: $('echo') ? $('echo').checked : INPUT_DEFAULTS.echo,
          enterSend: $('enterSend') ? $('enterSend').checked : INPUT_DEFAULTS.enterSend,
          autoScroll: $('autoScroll') ? $('autoScroll').checked : INPUT_DEFAULTS.autoScroll
        };
        localStorage.setItem(INPUT_OPTIONS_KEY, JSON.stringify(snap));
      } catch {}
    }
    // Attach listeners for input options
    ['eol','echo','enterSend','autoScroll'].forEach(id => {
      const el = $(id); if (!el) return;
      el.addEventListener('change', saveInputOptions);
      if (el.tagName === 'SELECT') el.addEventListener('input', saveInputOptions);
    });
    // Load stored input options now
    const _loadedInputOptions = loadInputOptions();
    applyInputOptions(_loadedInputOptions);
    // Attach change listeners (delegated after DOM ready; elements already exist inline)
    ['baud','databits','parity','stopbits','flow'].forEach(id => {
      const el = $(id);
      if (el) el.addEventListener('change', persistAndDisplay);
      if (el && el.tagName === 'INPUT') el.addEventListener('input', persistAndDisplay);
    });
    // Load on startup
    const _loadedSerial = loadSerialSettings();
    applySerialSettings(_loadedSerial);
    // Provide reset button logic (in Settings tab)
    document.addEventListener('DOMContentLoaded', () => {
      const resetBtn = $('resetSerialSettings');
      if (resetBtn) resetBtn.addEventListener('click', () => {
        applySerialSettings(SERIAL_DEFAULTS);
        persistAndDisplay();
      });
      const expBtn = $('exportSettings');
      if (expBtn) expBtn.addEventListener('click', exportSettingsJson);
      const impBtn = $('importSettings');
      const impFile = $('importSettingsFile');
      if (impBtn && impFile) {
        impBtn.addEventListener('click', () => impFile.click());
        impFile.addEventListener('change', () => {
          const f = impFile.files && impFile.files[0];
          if (f) importSettingsJsonFile(f);
          impFile.value = '';
        });
      }
      const eepromSaveBtn = $('eepromSave');
      if (eepromSaveBtn) eepromSaveBtn.addEventListener('click', () => alert('TODO: EEPROM save (implement device command)'));
      const eepromLoadBtn = $('eepromLoad');
      if (eepromLoadBtn) eepromLoadBtn.addEventListener('click', () => alert('TODO: EEPROM load (implement device command)'));
      // summary removed
    });

    // Cookie utils (no regex to avoid escaping issues)
    function readCookie(name) {
      const prefix = name + '=';
      const parts = document.cookie ? document.cookie.split(';') : [];
      for (const part of parts) {
        const s = part.trim();
        if (s.startsWith(prefix)) {
          return decodeURIComponent(s.slice(prefix.length));
        }
      }
      return '';
    }
    function writeCookie(name, value, maxAgeSec) {
      document.cookie = name + '=' + encodeURIComponent(value) + '; path=/; max-age=' + maxAgeSec.toString();
    }
    function deleteCookie(name) {
      document.cookie = name + '=; path=/; max-age=0';
    }

    // History helpers
    function loadHistory() {
      try {
        const v = readCookie(HISTORY_COOKIE);
        if (!v) return [];
        const arr = JSON.parse(v);
        return Array.isArray(arr) ? arr.filter(s => typeof s === 'string') : [];
      } catch { return []; }
    }
    function saveHistory() {
      // Trim oldest items (at the end) to cap size
      while (history.length > HISTORY_MAX) history.pop();
      try {
        writeCookie(HISTORY_COOKIE, JSON.stringify(history), 60 * 60 * 24 * 365);
      } catch {
        while (history.length > Math.min(25, HISTORY_MAX)) history.pop();
        try { writeCookie(HISTORY_COOKIE, JSON.stringify(history), 60 * 60 * 24 * 365); } catch {}
      }
    }
    function addToHistory(cmd) {
      const c = (cmd ?? '').trim();
      if (!c) return;
      if (history[0] === c) return; // avoid immediate dup (top)
      // Newest-first: add to the top
      history.unshift(c);
      saveHistory();
      renderHistory();
    }
    function clearHistory() {
      history = [];
      deleteCookie(HISTORY_COOKIE);
      renderHistory();
    }
    function renderHistory() {
      const list = $('historyList');
      list.innerHTML = '';
      const end = Math.min(history.length, HISTORY_SHOW);
      for (let i = 0; i < end; i++) {
        const cmd = history[i];
        const btn = document.createElement('button');
        btn.className = 'hist-item';
        btn.textContent = cmd;
        btn.title = 'Click to resend';
        btn.addEventListener('click', () => sendCommand(cmd)); // resend, but do NOT add to history again
        list.appendChild(btn);
      }
    }

    /* ===== Settings Export / Import (commands + connection + IR + input options) ===== */
    function exportSettingsJson() {
      const payload = {
        type: 'melexis.io-settings',
        version: 4,
        exportedAt: new Date().toISOString(),
        history: [...history],
        historyCount: history.length,
        serialSettings: currentSerialSettings(),
        ir: { scale: irScale },
        input: {
          eol: $('eol') ? $('eol').value : '',
          echo: $('echo') ? $('echo').checked : false,
          enterSend: $('enterSend') ? $('enterSend').checked : false,
          autoScroll: $('autoScroll') ? $('autoScroll').checked : false
        }
      };
      const blob = new Blob([JSON.stringify(payload, null, 2)], {type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      const ts = new Date().toISOString().replace(/[:.]/g,'-');
      a.download = `settings-${ts}.json`;
      document.body.appendChild(a); a.click(); a.remove();
      URL.revokeObjectURL(url);
    }
    function importSettingsJsonFile(file) {
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const text = e.target.result;
          const obj = JSON.parse(text);
          if (!obj || !(obj.type === 'melexis.io-settings' || obj.type === 'melexis.io-history') || !Array.isArray(obj.history)) {
            alert('Invalid settings file.');
            return;
          }
          const arr = obj.history.filter(s => typeof s === 'string' && s.trim().length > 0);
          history = arr.slice(0, HISTORY_MAX);
          saveHistory();
          renderHistory();
          if (obj.serialSettings && typeof obj.serialSettings === 'object') {
            try {
              const merged = { ...SERIAL_DEFAULTS, ...obj.serialSettings };
              applySerialSettings(merged);
              persistAndDisplay();
            } catch {}
          }
          if (obj.ir && (obj.ir.scale === 1 || obj.ir.scale === 2 || obj.ir.scale === 4)) {
            irScale = obj.ir.scale;
            const sel = document.getElementById('irScaleSelect');
            if (sel) sel.value = String(irScale);
            if (irInitialized) renderIr();
          }
          if (obj.input && typeof obj.input === 'object') {
            applyInputOptions(obj.input);
            saveInputOptions();
          }
          alert('Imported settings. Commands: ' + history.length + (obj.serialSettings ? ', connection parameters applied' : '') + (obj.ir ? ', IR scale applied' : ''));
        } catch (err) {
          console.error('Import failed', err);
          alert('Failed to import: ' + err.message);
        }
      };
      reader.readAsText(file);
    }
    // Legacy wrappers (if any old references remain)
    function exportHistoryJson(){ exportSettingsJson(); }
    function importHistoryJsonFile(f){ importSettingsJsonFile(f); }

    function setStatus(msg) { $('status').textContent = msg || ''; }
    function updateConnectedStatus() {
      const statusBase = 'Connected';
      const labelPart = connPortLabel ? ' (' + connPortLabel + ')' : '';
      const descPart = connDescription ? ' – ' + connDescription : '';
      setStatus(statusBase + labelPart + descPart);
      const st = $('status');
      if (st) {
        st.title = [
          'USB device: ' + (connPortLabel || 'unknown'),
          connDescription || null,
          'Note: OS COM port name/path not exposed by Web Serial'
        ].filter(Boolean).join('\n');
      }
    }

    // Format port info (where available) as USB VID:PID hex
    function formatPortLabel(p) {
      try {
        if (!p || typeof p.getInfo !== 'function') return '';
        const info = p.getInfo();
        if (!info) return '';
        const { usbVendorId, usbProductId, serialNumber } = info;
        let parts = [];
        if (typeof usbVendorId === 'number' && typeof usbProductId === 'number') {
          parts.push('0x' + usbVendorId.toString(16).padStart(4,'0').toUpperCase() + ':' + '0x' + usbProductId.toString(16).padStart(4,'0').toUpperCase());
        }
        if (serialNumber) parts.push(serialNumber);
        return parts.length ? parts.join(' ') : '';
      } catch { return ''; }
    }

    // Logging helpers (span-based to support colors)
    function appendLog(text, cls) {
      if (!text) return;
      const span = document.createElement('span');
      if (cls) span.className = cls;
      span.textContent = text; // preserves newlines safely
      logEl.appendChild(span);
      if ($('autoScroll').checked) logEl.scrollTop = logEl.scrollHeight;
    }
    function logEcho(text) { appendLog(text, 'log-echo'); }
    function logError(text) { appendLog(text, 'log-error'); }

    // Stream RX processing: color prompts only at real start-of-line,
    // do not inject any markers. Works across chunk boundaries.
    let atLineStart = true;
    function processRx(text) {
      let i = 0;
      while (i < text.length) {
        // If at start of a line, check for prompt "(...)>"
        if (atLineStart) {
          const slice = text.slice(i);
          const m = slice.match(/^\(([^)]+)\)>/);
          if (m) {
            const cls = m[1] === 'OK' ? 'log-okprompt' : 'log-badprompt';
            appendLog(m[0], cls);
            i += m[0].length;
            atLineStart = false;
            continue;
          }
        }
        // Append up to and including next newline (if any)
        const nl = text.indexOf('\n', i);
        if (nl === -1) {
          appendLog(text.slice(i), 'log-rx');
          // atLineStart unchanged
          break;
        } else {
          const seg = text.slice(i, nl + 1);
          appendLog(seg, 'log-rx');
          if (awaitingIdnFirstLine) {
            const body = seg.replace(/\r?\n$/, '').trim();
            if (body && body.toLowerCase() !== '*idn?' && !/^\(.*\)>$/.test(body)) {
              connDescription = body;
              awaitingIdnFirstLine = false;
              updateConnectedStatus();
            }
          }
          i = nl + 1;
          atLineStart = true;
        }
      }
    }

    // Decode literal option values ("\n", "\r", "\r\n") into actual control chars
    function eolValue() {
      const v = $('eol').value;
      if (v === '\\n') return '\n';
      if (v === '\\r') return '\r';
      if (v === '\\r\\n') return '\r\n';
      return '';
    }
    function setCommandButtonsEnabled(enabled) {
      $('cmd-id').disabled = !enabled;
      $('cmd-info').disabled = !enabled;
      $('cmd-rst').disabled = !enabled;
      const es = $('eepromSave'); if (es) es.disabled = !enabled;
      const elb = $('eepromLoad'); if (elb) elb.disabled = !enabled;
    }

  async function connect() {
      if (!('serial' in navigator)) {
        alert('Web Serial API not supported in this browser. Use Chrome or Edge (desktop).');
        return;
      }
      try {
        // Always request a new port
        port = await navigator.serial.requestPort();
        const opts = {
          baudRate: parseInt($('baud').value, 10) || 115200,
          dataBits: parseInt($('databits').value, 10) || 7,
          stopBits: parseInt($('stopbits').value, 10) || 2,
          parity: $('parity').value || 'odd',
          flowControl: $('flow').value || 'none',
        };
        await port.open(opts);

  textDecoder = new TextDecoderStream();
  textEncoder = new TextEncoderStream();

  // Keep references to piping promises so we can await them on disconnect
  readableStreamClosed = port.readable.pipeTo(textDecoder.writable);
  writableStreamClosed = textEncoder.readable.pipeTo(port.writable);

        reader = textDecoder.readable.getReader();
        writer = textEncoder.writable.getWriter();

    $('connect').disabled = true;
    $('disconnect').disabled = false;
    setCommandButtonsEnabled(true);
    connPortLabel = formatPortLabel(port);
    connDescription = '';
    awaitingIdnFirstLine = true; // will capture first *IDN? response line
    updateConnectedStatus();

        // Auto query on connect (not recorded in history)
        await sendCommand('*idn?');

        reading = true;
        (async () => {
          try {
            while (reading) {
              const { value, done } = await reader.read();
              if (done) break;
              if (value) processRx(value);
            }
          } catch (err) {
            console.error('Read error:', err);
            setStatus('Read error: ' + err.message);
          } finally {
            try { reader.releaseLock(); } catch {}
          }
        })();

      } catch (err) {
        console.error('Connect failed:', err);
        alert('Failed to connect: ' + err.message);
        setStatus('Disconnected');
        setCommandButtonsEnabled(false);
      }
    }

    async function disconnect() {
      try {
        setStatus('Disconnecting…');
        reading = false;
        // Stop reading
        try {
          if (reader) {
            await reader.cancel();
            try { reader.releaseLock && reader.releaseLock(); } catch {}
          }
        } catch {}
        // Stop writing
        try {
          if (writer) {
            await writer.close();
            try { writer.releaseLock && writer.releaseLock(); } catch {}
          }
        } catch {}
        // Wait for the piping to finish
        try { if (readableStreamClosed) await readableStreamClosed.catch(() => {}); } catch {}
        try { if (writableStreamClosed) await writableStreamClosed.catch(() => {}); } catch {}
        // Finally close the port
        try { if (port) await port.close(); } catch {}
      } finally {
        // Do not set port to null, so it can be reused
        reader = null;
        writer = null;
        readableStreamClosed = null;
        writableStreamClosed = null;
        textDecoder = null;
        textEncoder = null;
        $('connect').disabled = false;
        $('disconnect').disabled = true;
        setCommandButtonsEnabled(false);
        connPortLabel = '';
        connDescription = '';
        awaitingIdnFirstLine = false;
        setStatus('Disconnected');
      }
    }

    async function send() {
      if (!writer) { setStatus('Not connected'); return; }
      const raw = $('tx').value;
      const text = raw + eolValue();
      try {
        await writer.write(text);
        addToHistory(raw); // only add from input tx
        if ($('echo').checked) logEcho(text);
        $('tx').value = '';
        historyIndex = -1; draftBeforeNav = '';
        $('tx').focus();
      } catch (err) {
        console.error('Write error:', err);
        setStatus('Write error: ' + err.message);
      }
    }

    async function sendCommand(cmd) {
      if (!writer) { setStatus('Not connected'); return; }
      const text = cmd + eolValue();
      try {
        await writer.write(text);
        // Do NOT add to history here (buttons and auto commands excluded)
        if ($('echo').checked) logEcho(text);
      } catch (err) {
        console.error('Write error:', err);
        setStatus('Write error: ' + err.message);
      }
    }

    function clearLog() { logEl.textContent = ''; }

    function saveLog() {
      const blob = new Blob([logEl.textContent], { type: 'text/plain;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      const ts = new Date().toISOString().replace(/[:.]/g, '-');
      a.download = `serial-log-${ts}.txt`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    // Events
    $('connect').addEventListener('click', connect);
    $('disconnect').addEventListener('click', disconnect);
    $('send').addEventListener('click', send);
    $('clear').addEventListener('click', clearLog);
    $('save').addEventListener('click', saveLog);

    $('cmd-id').addEventListener('click', () => sendCommand('*IDN?'));
    $('cmd-info').addEventListener('click', () => sendCommand(':SYST:INFO'));
    $('cmd-rst').addEventListener('click', () => sendCommand('*RST'));

    // Arrow Up/Down history navigation in input (newest-first order)
    $('tx').addEventListener('keydown', (e) => {
      if ($('enterSend').checked && e.key === 'Enter') {
        e.preventDefault();
        $('send').click();
        return;
      }
      if (e.key === 'ArrowUp') {
        e.preventDefault();
        if (history.length === 0) return;
        if (historyIndex === -1) {
          draftBeforeNav = $('tx').value;
          historyIndex = 0; // most recent
        } else {
          historyIndex = Math.min(history.length - 1, historyIndex + 1); // go to older
        }
        $('tx').value = history[historyIndex] ?? '';
        $('tx').setSelectionRange($('tx').value.length, $('tx').value.length);
      } else if (e.key === 'ArrowDown') {
        e.preventDefault();
        if (history.length === 0) return;
        if (historyIndex === -1) {
          // nothing
        } else if (historyIndex > 0) {
          historyIndex--;
          $('tx').value = history[historyIndex] ?? '';
        } else {
          historyIndex = -1;
          $('tx').value = draftBeforeNav;
        }
        $('tx').setSelectionRange($('tx').value.length, $('tx').value.length);
      }
    });
    $('tx').addEventListener('input', () => {
      if (historyIndex !== -1) historyIndex = -1;
    });

    $('clearHistory').addEventListener('click', clearHistory);

    window.addEventListener('beforeunload', disconnect);

    // Init history on load
    history = loadHistory();
    renderHistory();
  // After history, ensure serial settings display is in sync if Settings tab viewed first
  // summary removed

    /* ================= IR IMAGE (Heatmap) TAB ================= */
    const IR_ROWS = 24;
    const IR_COLS = 32;
    const IR_MIN = 0.10;
    const IR_MAX = 40.0;
    let irData = null; // Float32Array length IR_ROWS*IR_COLS
    let irInitialized = false;
  // Scaling / interpolation
  let irScale = 1; // allowed: 1 (nearest / block), 2, 4 (bicubic)
  const IR_BASE_CELL_SIZE = 20; // pixels per cell at scale 1
    // Overlay options (declared early to avoid TDZ in early render paths)
    let irShowGrid = false;
    let irShowValues = false;
    // Pause state for continuous mode when user hovers heatmap/legend
    let irPausedByHover = false;
    function refreshIrRunningIndicator() {
      const ind = $('irRunning');
      const btn = $('irContinuous');
      if (!ind || !btn) return;
      const running = btn.getAttribute('data-active') === '1';
      if (!running) {
        ind.style.background = '#0d2219';
        ind.style.boxShadow = '0 0 4px #0d2219';
        ind.title = 'Continuous inactive';
        return;
      }
      if (irPausedByHover) {
        ind.style.background = '#7a4c00';
        ind.style.boxShadow = '0 0 6px #ffb347';
        ind.title = 'Continuous running (paused by hover)';
      } else {
        ind.style.background = '#59ffb0';
        ind.style.boxShadow = '0 0 6px #59ffb0';
        ind.title = 'Continuous running';
      }
    }

    function initIrData() {
      irData = new Float32Array(IR_ROWS * IR_COLS);
      randomizeIrData();
    }

    function randomizeIrData() {
      if (!irData) return;
      const span = IR_MAX - IR_MIN;
      for (let i = 0; i < irData.length; i++) {
        // Bias slightly toward middle for a more interesting distribution
        const r = (Math.random() + Math.random()) / 2; // triangular dist
        irData[i] = IR_MIN + span * r;
      }
    }

    // Piecewise thermal gradient stops
    const GRADIENT_STOPS = [
      [0.00, 0,   0,  64],
      [0.20, 0,   0, 255],
      [0.40, 0, 255, 255],
      [0.60, 255,255,   0],
      [0.80, 255,128,   0],
      [1.00, 255,255, 255]
    ];

    function lerp(a,b,t){return a + (b-a)*t;}
    function valueToColor(v) {
      let n = (v - IR_MIN) / (IR_MAX - IR_MIN);
      if (n < 0) n = 0; else if (n > 1) n = 1;
      // Find surrounding stops
      for (let i=0;i<GRADIENT_STOPS.length-1;i++) {
        const a = GRADIENT_STOPS[i];
        const b = GRADIENT_STOPS[i+1];
        if (n >= a[0] && n <= b[0]) {
          const t = (n - a[0])/(b[0]-a[0] || 1);
          const r = Math.round(lerp(a[1], b[1], t));
          const g = Math.round(lerp(a[2], b[2], t));
          const bC = Math.round(lerp(a[3], b[3], t));
          return [r,g,bC];
        }
      }
      const last = GRADIENT_STOPS[GRADIENT_STOPS.length-1];
      return [last[1], last[2], last[3]];
    }

    function drawIrHeatmap() {
      const canvas = $('irCanvas');
      if (!canvas || !irData) return;
      const ctx = canvas.getContext('2d');
      const w = canvas.width;
      const h = canvas.height;
      if (irScale === 1) {
        const cellW = w / IR_COLS;
        const cellH = h / IR_ROWS;
        const img = ctx.createImageData(w, h);
        const data = img.data;
        for (let row=0; row<IR_ROWS; row++) {
          for (let col=0; col<IR_COLS; col++) {
            const v = irData[row*IR_COLS + col];
            const [r,g,b] = valueToColor(v);
            const x0 = Math.floor(col * cellW);
            const y0 = Math.floor(row * cellH);
            const x1 = Math.floor((col+1) * cellW);
            const y1 = Math.floor((row+1) * cellH);
            for (let py=y0; py<y1; py++) {
              let idxBase = (py * w + x0) * 4;
              for (let px=x0; px<x1; px++) {
                data[idxBase++] = r;
                data[idxBase++] = g;
                data[idxBase++] = b;
                data[idxBase++] = 255;
              }
            }
          }
        }
        ctx.putImageData(img,0,0);
        canvas.style.imageRendering = 'pixelated';
        return;
      }
      // Bicubic interpolation for irScale > 1
      canvas.style.imageRendering = 'auto';
      const img = ctx.createImageData(w, h);
      const data = img.data;
      const gridW = IR_COLS;
      const gridH = IR_ROWS;
      function getVal(ix, iy) {
        if (ix < 0) ix = 0; else if (ix >= gridW) ix = gridW - 1;
        if (iy < 0) iy = 0; else if (iy >= gridH) iy = gridH - 1;
        return irData[iy * gridW + ix];
      }
      function cubic(p0,p1,p2,p3,t) {
        return 0.5 * (2*p1 + (-p0 + p2)*t + (2*p0 -5*p1 +4*p2 - p3)*t*t + (-p0 +3*p1 -3*p2 + p3)*t*t*t);
      }
      for (let y=0; y<h; y++) {
        const gy = (y / (h - 1)) * (gridH - 1);
        const iy = Math.floor(gy);
        const ty = gy - iy;
        for (let x=0; x<w; x++) {
          const gx = (x / (w - 1)) * (gridW - 1);
          const ix = Math.floor(gx);
          const tx = gx - ix;
          const colVals = new Array(4);
          for (let m=-1; m<=2; m++) {
            const rowVals = [
              getVal(ix-1, iy+m),
              getVal(ix,   iy+m),
              getVal(ix+1, iy+m),
              getVal(ix+2, iy+m)
            ];
            colVals[m+1] = cubic(rowVals[0], rowVals[1], rowVals[2], rowVals[3], tx);
          }
          const val = cubic(colVals[0], colVals[1], colVals[2], colVals[3], ty);
          const [r,g,b] = valueToColor(val);
          let idx = (y * w + x) * 4;
          data[idx] = r; data[idx+1] = g; data[idx+2] = b; data[idx+3] = 255;
        }
      }
      ctx.putImageData(img,0,0);
    }

    /* ===== IR Tooltip (raw + interpolated) ===== */
    const irTooltip = (() => {
      const el = document.getElementById('irTooltip');
      if (!el) return null;
      // Reuse interpolation helpers consistent with drawIrHeatmap
      function getVal(ix, iy) {
        if (ix < 0) ix = 0; else if (ix >= IR_COLS) ix = IR_COLS - 1;
        if (iy < 0) iy = 0; else if (iy >= IR_ROWS) iy = IR_ROWS - 1;
        return irData[iy * IR_COLS + ix];
      }
      function cubic(p0,p1,p2,p3,t){
        return 0.5 * (2*p1 + (-p0 + p2)*t + (2*p0 -5*p1 +4*p2 - p3)*t*t + (-p0 +3*p1 -3*p2 + p3)*t*t*t);
      }
      function sampleInterpolated(px, py, canvasW, canvasH) {
        if (!irData) return null;
        // Map pixel to grid space (same mapping used in bicubic loop)
        const gx = (px / (canvasW - 1)) * (IR_COLS - 1);
        const gy = (py / (canvasH - 1)) * (IR_ROWS - 1);
        const ix = Math.floor(gx);
        const iy = Math.floor(gy);
        const tx = gx - ix;
        const ty = gy - iy;
        // Raw nearest cell (for raw value display)
        const rawCol = Math.round(gx);
        const rawRow = Math.round(gy);
        let interpVal;
        if (irScale === 1) {
          interpVal = getVal(rawCol, rawRow);
        } else {
          const colVals = new Array(4);
          for (let m=-1; m<=2; m++) {
            const rowVals = [
              getVal(ix-1, iy+m),
              getVal(ix,   iy+m),
              getVal(ix+1, iy+m),
              getVal(ix+2, iy+m)
            ];
            colVals[m+1] = cubic(rowVals[0], rowVals[1], rowVals[2], rowVals[3], tx);
          }
            interpVal = cubic(colVals[0], colVals[1], colVals[2], colVals[3], ty);
        }
        return { rawRow, rawCol, rawVal: getVal(rawCol, rawRow), interpVal };
      }
      function fmt(v) { return v.toFixed(2); }
      function onMove(ev) {
        if (!irData) return;
        const canvas = $('irCanvas');
        if (!canvas) return;
        const rect = canvas.getBoundingClientRect();
        const x = ev.clientX - rect.left;
        const y = ev.clientY - rect.top;
        if (x < 0 || y < 0 || x >= rect.width || y >= rect.height) { el.style.display = 'none'; return; }
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const sample = sampleInterpolated(x * scaleX, y * scaleY, canvas.width, canvas.height);
        if (!sample) { el.style.display = 'none'; return; }
        el.style.display = 'block';
        el.textContent = `r${sample.rawRow} c${sample.rawCol}\nRaw: ${fmt(sample.rawVal)}\nInterp: ${fmt(sample.interpVal)}`;
        // Position near cursor but keep inside viewport
        const padding = 12;
        let left = ev.clientX + 12;
        let top = ev.clientY + 12;
        const vw = window.innerWidth;
        const vh = window.innerHeight;
        const estW = 120; // rough width
        const estH = 54; // rough height
        if (left + estW + padding > vw) left = ev.clientX - estW - 12;
        if (top + estH + padding > vh) top = ev.clientY - estH - 12;
        el.style.left = left + 'px';
        el.style.top = top + 'px';
      }
      function onLeave() { el.style.display = 'none'; }
      const canvas = $('irCanvas');
      if (canvas) {
        canvas.addEventListener('mousemove', onMove);
        canvas.addEventListener('mouseleave', onLeave);
      }
      return { update: ()=>{}, hide:onLeave };
    })();

    function drawIrLegend() {
      const canvas = $('irLegend');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      const w = canvas.width, h = canvas.height;
      const img = ctx.createImageData(w, h);
      const data = img.data;
      for (let y=0; y<h; y++) {
        const n = 1 - (y / (h-1)); // top = 1 (max), bottom = 0 (min)
        const v = IR_MIN + (IR_MAX - IR_MIN) * n;
        const [r,g,b] = valueToColor(v);
        for (let x=0; x<w; x++) {
          const i = (y * w + x) * 4;
          data[i] = r; data[i+1] = g; data[i+2] = b; data[i+3] = 255;
        }
      }
      ctx.putImageData(img,0,0);
      drawIrOverlays(ctx);
      // Optional ticks (every 20%)


    function drawIrOverlays(ctx){
      const canvas = ctx.canvas;
      if (!canvas) return;
      const cellSize = IR_BASE_CELL_SIZE; // physical pixel size per cell
      // Only show values when scale == 1 to avoid clutter and performance issues
      const showValues = irShowValues && irScale === 1;
      const showGrid = irShowGrid && irScale <= 2; // hide grid at extreme smooth scale
      if (!showValues && !showGrid) return;
      ctx.save();
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = '10px system-ui';
      for (let r=0; r<IR_ROWS; r++){
        for (let c=0; c<IR_COLS; c++){
          const x = c * cellSize;
            const y = r * cellSize;
          if (showGrid){
            ctx.strokeStyle = 'rgba(255,255,255,0.15)';
            ctx.strokeRect(x+0.5,y+0.5,cellSize-1,cellSize-1);
          }
          if (showValues){
            const v = irData[r*IR_COLS + c];
            // Choose contrasting color based on brightness of underlying cell: sample center pixel
            // Simple heuristic: map value to normalized 0..1 and threshold
            let norm = (v - IR_MIN)/(IR_MAX-IR_MIN); if (norm<0) norm=0; else if (norm>1) norm=1;
            const textColor = norm > 0.55 ? 'rgba(0,0,0,0.8)' : 'rgba(255,255,255,0.9)';
            ctx.fillStyle = textColor;
            ctx.fillText(v.toFixed(1), x + cellSize/2, y + cellSize/2);
          }
        }
      }
      ctx.restore();
    }
      ctx.fillStyle = '#fff';
      ctx.font = '10px system-ui';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      for (let p=0; p<=1; p+=0.2) {
        const y = (1-p)* (h-1);
        ctx.fillRect(w-8, y, 8, 1);
      }
      $('irMax').textContent = IR_MAX.toFixed(1);
      $('irMin').textContent = IR_MIN.toFixed(2);
    }

    function renderIr() {
      updateIrCanvasSize();
      drawIrHeatmap();
      drawIrLegend();
    }

    function updateIrCanvasSize() {
      const canvas = $('irCanvas');
      const legend = $('irLegend');
      if (!canvas || !legend) return;
      // Keep base size constant; scale affects interpolation detail only
      const newW = IR_COLS * IR_BASE_CELL_SIZE;
      const newH = IR_ROWS * IR_BASE_CELL_SIZE;
      if (canvas.width !== newW || canvas.height !== newH) {
        canvas.width = newW; canvas.height = newH;
      }
      if (legend.height !== newH) legend.height = newH;
    }

    function ensureIrInitialized() {
      if (irInitialized) return;
      initIrData();
      renderIr();
  const readBtn = $('irRead');
  if (readBtn) readBtn.addEventListener('click', () => { randomizeIrData(); renderIr(); });
  const contBtn = $('irContinuous');
  if (contBtn) contBtn.addEventListener('click', toggleIrContinuous);
      const saveImgBtn = $('irSaveImage');
      if (saveImgBtn) saveImgBtn.addEventListener('click', saveIrImage);
      const exportBtn = $('irExportData');
      if (exportBtn) exportBtn.addEventListener('click', exportIrDataCsv);
      const scaleSel = $('irScaleSelect');
      if (scaleSel) scaleSel.addEventListener('change', () => {
        const v = parseInt(scaleSel.value, 10) || 1;
        irScale = (v === 2 || v === 4) ? v : 1;
        renderIr();
      });
      const showGridCb = $('irShowGrid');
      if (showGridCb) showGridCb.addEventListener('change', () => { irShowGrid = showGridCb.checked; renderIr(); });
      const showValuesCb = $('irShowValues');
      if (showValuesCb) showValuesCb.addEventListener('change', () => { irShowValues = showValuesCb.checked; renderIr(); });
      // Hover pause listeners for continuous mode (canvas + legend)
      ['irCanvas','irLegend'].forEach(id => {
        const el = $(id);
        if (!el) return;
        el.addEventListener('mouseenter', () => { if (!irInitialized) return; irPausedByHover = true; refreshIrRunningIndicator(); });
        el.addEventListener('mouseleave', () => { if (!irInitialized) return; irPausedByHover = false; refreshIrRunningIndicator(); });
      });
      irInitialized = true;
    }

    // Continuous read (simulated by randomizeIrData for now)
    let irContinuousTimer = null;
    function toggleIrContinuous() {
      const btn = $('irContinuous');
      const ind = $('irRunning');
      if (!btn) return;
      const active = btn.getAttribute('data-active') === '1';
      if (active) {
        // stop
        btn.setAttribute('data-active','0');
        btn.classList.remove('btn-success');
        btn.classList.add('btn-outline-secondary');
        if (irContinuousTimer) { clearInterval(irContinuousTimer); irContinuousTimer = null; }
        irPausedByHover = false;
        refreshIrRunningIndicator();
      } else {
        // start
        btn.setAttribute('data-active','1');
        btn.classList.remove('btn-outline-secondary');
        btn.classList.add('btn-success');
        // immediate read
        randomizeIrData(); renderIr();
        irContinuousTimer = setInterval(() => {
          if (irPausedByHover) return; // skip updates during hover pause
          randomizeIrData();
          renderIr();
        }, 500);
        refreshIrRunningIndicator();
      }
    }
    // Stop continuous when leaving page or tab hidden
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        if (irContinuousTimer) { clearInterval(irContinuousTimer); irContinuousTimer = null; }
        const btn = $('irContinuous');
        const ind = $('irRunning');
        if (btn && btn.getAttribute('data-active') === '1') {
          btn.setAttribute('data-active','0');
          btn.classList.remove('btn-success');
          btn.classList.add('btn-outline-secondary');
          irPausedByHover = false;
          refreshIrRunningIndicator();
        }
      }
    });
    window.addEventListener('beforeunload', () => { if (irContinuousTimer) clearInterval(irContinuousTimer); });

    // Render when IR tab is shown first time
    document.addEventListener('shown.bs.tab', (ev) => {
      if (ev.target && ev.target.id === 'ir-tab') {
        ensureIrInitialized();
      }
    });

    // If user bookmarked directly with hash #tab4, initialize
    if (location.hash === '#tab4') {
      ensureIrInitialized();
    }

    /* ===== Export Helpers ===== */
    function exportIrDataCsv() {
      if (!irData) return;
      let lines = [];
      lines.push('rows,'+IR_ROWS+',cols,'+IR_COLS+',min,'+IR_MIN+',max,'+IR_MAX);
      for (let r=0;r<IR_ROWS;r++) {
        let rowVals = [];
        for (let c=0;c<IR_COLS;c++) {
          rowVals.push(irData[r*IR_COLS + c].toFixed(2));
        }
        lines.push(rowVals.join(','));
      }
      const blob = new Blob([lines.join('\n')], {type:'text/csv'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'ir-data-'+Date.now()+'.csv';
      document.body.appendChild(a); a.click(); a.remove();
      URL.revokeObjectURL(url);
    }

    function saveIrImage() {
      const heat = $('irCanvas');
      const legend = $('irLegend');
      if (!heat || !legend) return;
      // Create composite canvas: place heatmap left, legend right with small gap + labels
      const gap = 8;
      const labelSpace = 30; // space on right for min/max text if desired
      // Use current (possibly scaled) canvas dimensions
      const outW = heat.width + gap + legend.width + labelSpace;
      const outH = Math.max(heat.height, legend.height);
      const cv = document.createElement('canvas');
      cv.width = outW; cv.height = outH;
      const ctx = cv.getContext('2d');
      // Fill background dark
      ctx.fillStyle = '#000';
      ctx.fillRect(0,0,outW,outH);
      ctx.drawImage(heat, 0, 0);
      // Scale legend vertically if different height
      ctx.drawImage(legend, heat.width + gap, 0, legend.width, heat.height);
      // Draw border around legend
      ctx.strokeStyle = '#ccc';
      ctx.strokeRect(heat.width + gap + 0.5, 0.5, legend.width-1, heat.height-1);
      // Labels (Max at top, Min at bottom)
      ctx.fillStyle = '#fff';
      ctx.font = '16px system-ui';
      ctx.textAlign = 'left';
      ctx.fillText(IR_MAX.toFixed(1), heat.width + gap + legend.width + 4, 18);
      ctx.fillText(IR_MIN.toFixed(2), heat.width + gap + legend.width + 4, heat.height - 6);
      // Title
      ctx.font = '18px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('IR Image ('+IR_COLS+'x'+IR_ROWS+')', heat.width/2, 24);
      // Download
      cv.toBlob(blob => {
        if (!blob) return;
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'ir-image-'+Date.now()+'.png';
        document.body.appendChild(a); a.click(); a.remove();
        URL.revokeObjectURL(url);
      }, 'image/png');
    }
    /* ================= PEOPLE DETECTION TAB (duplicate IR logic) ================= */
    const PD_ROWS = 24, PD_COLS = 32, PD_MIN = 0.10, PD_MAX = 40.0;
    let pdData = null, pdInitialized = false, pdScale = 1; // 1,2,4
    const PD_BASE_CELL_SIZE = 20;
    let pdShowGrid = false, pdShowValues = false, pdPausedByHover = false, pdContinuousTimer = null;

    function initPdData(){ pdData = new Float32Array(PD_ROWS*PD_COLS); randomizePdData(); }
    function randomizePdData(){ if(!pdData) return; const span = PD_MAX-PD_MIN; for(let i=0;i<pdData.length;i++){ pdData[i] = PD_MIN + Math.random()*span; } }
    function pdValueToColor(v){ let n=(v-PD_MIN)/(PD_MAX-PD_MIN); if(n<0)n=0; else if(n>1)n=1; for(let i=0;i<GRADIENT_STOPS.length-1;i++){ const a=GRADIENT_STOPS[i], b=GRADIENT_STOPS[i+1]; if(n>=a[0] && n<=b[0]){ const t=(n-a[0])/(b[0]-a[0]); return [lerp(a[1],b[1],t), lerp(a[2],b[2],t), lerp(a[3],b[3],t)]; } } const last=GRADIENT_STOPS[GRADIENT_STOPS.length-1]; return [last[1],last[2],last[3]]; }
    function drawPdHeatmap(){ const canvas=$('pdCanvas'); if(!canvas||!pdData)return; const ctx=canvas.getContext('2d'); const w=canvas.width,h=canvas.height; if(pdScale===1){ canvas.style.imageRendering='pixelated'; const cell=PD_BASE_CELL_SIZE; for(let r=0;r<PD_ROWS;r++){ for(let c=0;c<PD_COLS;c++){ const v=pdData[r*PD_COLS+c]; const [R,G,B]=pdValueToColor(v); ctx.fillStyle=`rgb(${R},${G},${B})`; ctx.fillRect(c*cell,r*cell,cell,cell); } } } else { canvas.style.imageRendering='auto'; const img=ctx.createImageData(w,h); const data=img.data; const gridW=PD_COLS,gridH=PD_ROWS; const cellW=w/gridW, cellH=h/gridH; function getVal(ix,iy){ if(ix<0)ix=0; else if(ix>=gridW)ix=gridW-1; if(iy<0)iy=0; else if(iy>=gridH)iy=gridH-1; return pdData[iy*gridW+ix]; } function cubic(p0,p1,p2,p3,t){ const a=-0.5*p0+1.5*p1-1.5*p2+0.5*p3; const b=p0-2.5*p1+2*p2-0.5*p3; const c=-0.5*p0+0.5*p2; const d=p1; return ((a*t + b)*t + c)*t + d; } for(let y=0;y<h;y++){ const gy=y/cellH; const gyi=Math.floor(gy); const ty=gy-gyi; for(let x=0;x<w;x++){ const gx=x/cellW; const gxi=Math.floor(gx); const tx=gx-gxi; const colVals=[]; for(let m=-1;m<=2;m++){ const rowVals=[]; for(let n=-1;n<=2;n++){ rowVals.push(getVal(gxi+n, gyi+m)); } colVals.push(rowVals); } const colInterp=[]; for(let r=0;r<4;r++){ colInterp.push(cubic(colVals[r][0],colVals[r][1],colVals[r][2],colVals[r][3],tx)); } const v=cubic(colInterp[0],colInterp[1],colInterp[2],colInterp[3],ty); const [R,G,B]=pdValueToColor(v); const idx=(y*w+x)*4; data[idx]=R; data[idx+1]=G; data[idx+2]=B; data[idx+3]=255; } } ctx.putImageData(img,0,0); }
      drawPdOverlays(ctx); }
    function drawPdOverlays(ctx){ const canvas=ctx.canvas; if(!canvas) return; const cellSize=PD_BASE_CELL_SIZE; const showValues=pdShowValues && pdScale===1; const showGrid=pdShowGrid && pdScale<=2; if(!showValues && !showGrid) return; ctx.save(); ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.font='10px system-ui'; for(let r=0;r<PD_ROWS;r++){ for(let c=0;c<PD_COLS;c++){ const x=c*cellSize,y=r*cellSize; if(showGrid){ ctx.strokeStyle='rgba(255,255,255,0.15)'; ctx.strokeRect(x+0.5,y+0.5,cellSize-1,cellSize-1); } if(showValues){ const v=pdData[r*PD_COLS+c]; let norm=(v-PD_MIN)/(PD_MAX-PD_MIN); if(norm<0)norm=0; else if(norm>1)norm=1; ctx.fillStyle= norm>0.55 ? 'rgba(0,0,0,0.8)' : 'rgba(255,255,255,0.9)'; ctx.fillText(v.toFixed(1), x+cellSize/2, y+cellSize/2); } } } ctx.restore(); }
    const pdTooltip = (()=>{ const el=$('pdTooltip'); if(!el) return null; function getVal(ix,iy){ if(ix<0)ix=0; else if(ix>=PD_COLS)ix=PD_COLS-1; if(iy<0)iy=0; else if(iy>=PD_ROWS)iy=PD_ROWS-1; return pdData[iy*PD_COLS+ix]; } function cubic(p0,p1,p2,p3,t){ const a=-0.5*p0+1.5*p1-1.5*p2+0.5*p3; const b=p0-2.5*p1+2*p2-0.5*p3; const c=-0.5*p0+0.5*p2; const d=p1; return ((a*t + b)*t + c)*t + d; } function sampleInterpolated(px,py,cw,ch){ const cellW=cw/PD_COLS, cellH=ch/PD_ROWS; const gx=px/cellW, gy=py/cellH; const gxi=Math.floor(gx), gyi=Math.floor(gy); const tx=gx-gxi, ty=gy-gyi; const colVals=[]; for(let m=-1;m<=2;m++){ const rowVals=[]; for(let n=-1;n<=2;n++){ rowVals.push(getVal(gxi+n, gyi+m)); } colVals.push(rowVals); } const colInterp=[]; for(let r=0;r<4;r++){ colInterp.push(cubic(colVals[r][0],colVals[r][1],colVals[r][2],colVals[r][3],tx)); } return cubic(colInterp[0],colInterp[1],colInterp[2],colInterp[3],ty); } function fmt(v){ return v.toFixed(2); } function onMove(ev){ if(!pdData) return; const canvas=$('pdCanvas'); if(!canvas) return; const rect=canvas.getBoundingClientRect(); const x=ev.clientX-rect.left, y=ev.clientY-rect.top; if(x<0||y<0||x>=rect.width||y>=rect.height){ el.style.display='none'; return; } const cellW=rect.width/PD_COLS, cellH=rect.height/PD_ROWS; const col=Math.floor(x/cellW), row=Math.floor(y/cellH); const raw=pdData[row*PD_COLS+col]; const interp=pdScale===1?raw:sampleInterpolated(x,y,rect.width,rect.height); el.innerHTML = `r${row} c${col}: <strong>${fmt(raw)}</strong> (interp ${fmt(interp)})`; el.style.display='block'; el.style.left = rect.left + window.scrollX + x + 8 + 'px'; el.style.top = rect.top + window.scrollY + y + 8 + 'px'; } function onLeave(){ el.style.display='none'; } const canvas=$('pdCanvas'); if(canvas){ canvas.addEventListener('mousemove',onMove); canvas.addEventListener('mouseleave',onLeave); } return { hide:onLeave }; })();
    function drawPdLegend(){ const canvas=$('pdLegend'); if(!canvas) return; const ctx=canvas.getContext('2d'); const w=canvas.width,h=canvas.height; const img=ctx.createImageData(w,h); const data=img.data; for(let y=0;y<h;y++){ const t=y/(h-1); const stopT=1-t; const n=stopT; for(let i=0;i<GRADIENT_STOPS.length-1;i++){ const a=GRADIENT_STOPS[i], b=GRADIENT_STOPS[i+1]; if(n>=a[0] && n<=b[0]){ const tt=(n-a[0])/(b[0]-a[0]); const R=lerp(a[1],b[1],tt), G=lerp(a[2],b[2],tt), B=lerp(a[3],b[3],tt); const idx=y*w*4; for(let x=0;x<w;x++){ const off=idx+x*4; data[off]=R; data[off+1]=G; data[off+2]=B; data[off+3]=255; } break; } } } ctx.putImageData(img,0,0); ctx.fillStyle='#fff'; ctx.font='10px system-ui'; ctx.textAlign='left'; ctx.textBaseline='middle'; for(let p=0;p<=1;p+=0.2){ const yy=Math.round((1-p)*(h-1)); ctx.fillText((PD_MIN + (PD_MAX-PD_MIN)*p).toFixed(1), w+4, yy); } $('pdMax').textContent=PD_MAX.toFixed(1); $('pdMin').textContent=PD_MIN.toFixed(2); }
    function updatePdCanvasSize(){ const canvas=$('pdCanvas'), legend=$('pdLegend'); if(!canvas||!legend) return; const newW=PD_COLS*PD_BASE_CELL_SIZE, newH=PD_ROWS*PD_BASE_CELL_SIZE; if(canvas.width!==newW||canvas.height!==newH){ canvas.width=newW; canvas.height=newH; } if(legend.height!==newH) legend.height=newH; }
    function renderPd(){ updatePdCanvasSize(); drawPdHeatmap(); drawPdLegend(); }
    function ensurePdInitialized(){ if(pdInitialized) return; initPdData(); renderPd(); const readBtn=$('pdRead'); if(readBtn) readBtn.addEventListener('click',()=>{ randomizePdData(); renderPd(); }); const contBtn=$('pdContinuous'); if(contBtn) contBtn.addEventListener('click',togglePdContinuous); const saveImgBtn=$('pdSaveImage'); if(saveImgBtn) saveImgBtn.addEventListener('click',savePdImage); const exportBtn=$('pdExportData'); if(exportBtn) exportBtn.addEventListener('click',exportPdDataCsv); const scaleSel=$('pdScaleSelect'); if(scaleSel) scaleSel.addEventListener('change',()=>{ const v=parseInt(scaleSel.value,10)||1; pdScale=(v===2||v===4)?v:1; renderPd(); }); ['pdCanvas','pdLegend'].forEach(id=>{ const el=$(id); if(!el)return; el.addEventListener('mouseenter',()=>{ if(!pdInitialized) return; pdPausedByHover=true; refreshPdRunningIndicator(); }); el.addEventListener('mouseleave',()=>{ if(!pdInitialized) return; pdPausedByHover=false; refreshPdRunningIndicator(); }); }); const showGridCb=$('pdShowGrid'); if(showGridCb) showGridCb.addEventListener('change',()=>{ pdShowGrid=showGridCb.checked; renderPd(); }); const showValuesCb=$('pdShowValues'); if(showValuesCb) showValuesCb.addEventListener('change',()=>{ pdShowValues=showValuesCb.checked; renderPd(); }); pdInitialized=true; }
    function refreshPdRunningIndicator(){ const ind=$('pdRunning'); const btn=$('pdContinuous'); if(!ind||!btn) return; const running=btn.getAttribute('data-active')==='1'; if(!running){ ind.style.background='#0d2219'; ind.style.boxShadow='0 0 4px #0d2219'; ind.title='Not running'; return; } if(pdPausedByHover){ ind.style.background='#e3b341'; ind.style.boxShadow='0 0 6px #e3b341'; ind.title='Continuous running (paused by hover)'; } else { ind.style.background='#59ffb0'; ind.style.boxShadow='0 0 6px #59ffb0'; ind.title='Continuous running'; } }
    function togglePdContinuous(){ const btn=$('pdContinuous'); if(!btn) return; const active=btn.getAttribute('data-active')==='1'; if(active){ btn.setAttribute('data-active','0'); if(pdContinuousTimer) clearInterval(pdContinuousTimer); pdContinuousTimer=null; refreshPdRunningIndicator(); return; } btn.setAttribute('data-active','1'); refreshPdRunningIndicator(); pdContinuousTimer=setInterval(()=>{ if(pdPausedByHover) return; randomizePdData(); renderPd(); },500); }
    window.addEventListener('beforeunload', ()=>{ if(pdContinuousTimer) clearInterval(pdContinuousTimer); });
    function exportPdDataCsv(){ if(!pdData) return; let out=`rows,${PD_ROWS}\ncols,${PD_COLS}\nmin,${PD_MIN}\nmax,${PD_MAX}\n`; for(let r=0;r<PD_ROWS;r++){ let rowVals=[]; for(let c=0;c<PD_COLS;c++){ rowVals.push(pdData[r*PD_COLS+c].toFixed(2)); } out+=rowVals.join(',')+'\n'; } const blob=new Blob([out],{type:'text/csv'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; const ts=new Date().toISOString().replace(/[:.]/g,'-'); a.download=`people-detection-data-${ts}.csv`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); }
    function savePdImage(){ const canvas=$('pdCanvas'); if(!canvas) return; const legend=$('pdLegend'); const off=document.createElement('canvas'); const pad=16, legendPad=12; const width=canvas.width+legend.width+pad+legendPad; const height=Math.max(canvas.height,legend.height)+pad*2; off.width=width; off.height=height; const ctx=off.getContext('2d'); ctx.fillStyle='#000'; ctx.fillRect(0,0,width,height); ctx.drawImage(canvas,pad,pad); ctx.drawImage(legend,pad+canvas.width+legendPad,pad); ctx.fillStyle='#fff'; ctx.font='16px system-ui'; ctx.fillText('People Detection', pad, height-8); const url=off.toDataURL('image/png'); const a=document.createElement('a'); const ts=new Date().toISOString().replace(/[:.]/g,'-'); a.href=url; a.download=`people-detection-${ts}.png`; document.body.appendChild(a); a.click(); a.remove(); }
    document.addEventListener('shown.bs.tab', (ev)=>{ if(ev.target && ev.target.id==='pd-tab') ensurePdInitialized(); }); if(location.hash==='#tab5'){ ensurePdInitialized(); }
  </script>
</body>
</html>
